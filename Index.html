<!DOCTYPE html>
<html>
  <head>
    <base target="_top">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM (Cloudflare CDN) -->
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    
    <!-- Babel (Cloudflare CDN) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    
    <!-- Lucide Icons (Cloudflare CDN) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lucide/0.263.1/lucide-react.min.js"></script>
    
    <!-- Utilities -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.0/jspdf.plugin.autotable.min.js"></script>

    <!-- Chart.js for data visualization -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

    <style>
      <?!= include('Styles') ?>
    </style>
  </head>
  <body class="bg-slate-50 text-slate-900">
    <div id="root">
      <div class="flex h-screen flex-col items-center justify-center bg-slate-50">
        <div class="spinner mb-4"></div>
        <h2 class="text-xl font-bold text-slate-800">Loading <?= getConfig('APP_NAME', 'CAP Readiness Hub') ?>...</h2>
        <p class="text-slate-500 text-sm mt-2">Checking local cache...</p>
      </div>
    </div>

    <?!= include('Styles') ?>

    <!-- CONFIGURATION (no dependencies) -->
    <?!= include('ConfigConstants') ?>
    <?!= include('ConfigPromotionRules') ?>

    <!-- UTILITIES (depend on config) -->
    <?!= include('UtilsDataParsing') ?>
    <?!= include('UtilsDateHelpers') ?>
    <?!= include('UtilsCadetHelpers') ?>

    <!-- SERVICES (depend on utils & config) -->
    <?!= include('ServicesESDataService') ?>
    <?!= include('ServicesESUnitAnalysisService') ?>
    <?!= include('ServicesGoogleAdoptionDataService') ?>
    <?!= include('ServicesDataService') ?>
    <?!= include('ServicesCadetDataService') ?>
    <?!= include('ServicesOrgStatsDataService') ?>

    <!-- CORE COMPONENTS (base UI) -->
    <?!= include('ComponentsCore') ?>
    <?!= include('ComponentsLevelIndicator') ?>
    <?!= include('ComponentsOrgNode') ?>
    <?!= include('ComponentsFilters') ?>
    <?!= include('ComponentsCadetComponents') ?>

    <!-- ES COMPONENTS (depend on ES service) -->
    <?!= include('ComponentsESDisplay') ?>

    <!-- MODALS (depend on components & services) -->
    <?!= include('ModalESQualification') ?>
    <?!= include('ModalESSkillTree') ?>
    <?!= include('ModalESReadiness') ?>
    <?!= include('ModalSeniorProfile') ?>
    <?!= include('ModalCadetProfile') ?>
    <?!= include('ModalLevelDetail') ?>
    <?!= include('ModalPromotionCriteria') ?>
    <?!= include('ModalDrillDownPosition') ?>
    <?!= include('ModalReference') ?>
    <?!= include('ModalRecruitingRetention') ?>

    <!-- APP SECTIONS (depend on everything) -->
    <?!= include('AppHome') ?>
    <?!= include('AppUnitOverview') ?>
    <?!= include('AppSeniorDashboard') ?>
    <?!= include('AppCadetDashboard') ?>
    <?!= include('AppReports') ?>
    <?!= include('AppOrgChart') ?>

    <script type="text/babel">
      const { useState, useMemo, useEffect, useCallback } = React;

      function App() {
        const [activeTab, setActiveTab] = useState('home');
        const [showReference, setShowReference] = useState(false);
        const [unitFilter, setUnitFilter] = useState("");
        const [showAllDescendants, setShowAllDescendants] = useState(false);
        const [isAggregating, setIsAggregating] = useState(false);
        const [searchQuery, setSearchQuery] = useState("");
        const [loading, setLoading] = useState(true);
        const [loadingStatus, setLoadingStatus] = useState("Checking local cache...");
        const [lastUpdated, setLastUpdated] = useState("");
        
        const [configFiles, setConfigFiles] = useState({ paths: [], groups: [], tasks: [], assignments: [], lookups: [], cadetAchvEnum: [] });
        const [dataFiles, setDataFiles] = useState({
          members: [], duty: [], tracks: [], memberTasks: [], memberPaths: [], organization: [],
          cadetDuty: [], seniorLevels: [], committees: [], contacts: [],
          cadetRank: [], cadetAchv: [], cadetAchvAprs: [], cadetAchvFullReport: [],
          cadetPhase: [], cadetAwards: [], cadetHFZ: [], cadetActivities: [],
          training: [], seniorAwards: [], oFlights: [], voluInstructors: []
        });
        
        const [selectedMember, setSelectedMember] = useState(null);
        const [detailLevel, setDetailLevel] = useState(null);
        const [promotionMember, setPromotionMember] = useState(null);
        const [filterPromoReady, setFilterPromoReady] = useState(false);
        const [filterTlcQualified, setFilterTlcQualified] = useState(false);
        const [activeFilterMenu, setActiveFilterMenu] = useState(null);
        const [dutySearchQuery, setDutySearchQuery] = useState("");
        const [trackSearchQuery, setTrackSearchQuery] = useState("");
        const [selectedReport, setSelectedReport] = useState(null);
        const [reportTagFilter, setReportTagFilter] = useState([]);
        const [isNavOpen, setIsNavOpen] = useState(false);
        const [showSeniorFilters, setShowSeniorFilters] = useState(false);
        const [reportsCollapsed, setReportsCollapsed] = useState(false);
        const [selectedTaskMembers, setSelectedTaskMembers] = useState(null);
        const [selectedMemberTaskDetails, setSelectedMemberTaskDetails] = useState(null);
        const [filters, setFilters] = useState({
          ranks: [],           // Individual ranks like "2D LT", "CAPT", etc.
          rankCategories: [],  // Categories: OFFICER, NCO, FLIGHT
          functionalAreas: [], // Like LOGISTICS, COMMUNICATIONS, etc.
          tracks: [],          // Specific track names
          trackLevels: [],     // MASTER, SENIOR, TECHNICIAN, NONE
          duties: [],          // Specific duty position names
          dutyTypes: [],       // PRIMARY or ASSISTANT
          memberTypes: []      // SENIOR, LIFE
        });
        const [levelFilter, setLevelFilter] = useState({ level: null, state: null });

        const [orgChartData, setOrgChartData] = useState(null);
        const [hideVacant, setHideVacant] = useState(true);
        const [draggedNode, setDraggedNode] = useState(null);
        const [expandedSections, setExpandedSections] = useState(new Set());
        const [drillDownPosition, setDrillDownPosition] = useState(null);
        const [showCommandChainOnly, setShowCommandChainOnly] = useState(false);
        const [showCommittees, setShowCommittees] = useState(false);
        const [selectedMemberProfile, setSelectedMemberProfile] = useState(null);
        const [selectedESQualification, setSelectedESQualification] = useState(null);
        const [showESTreeModal, setShowESTreeModal] = useState(false);
        const [dataService, setDataService] = useState(null);
        const [orgStatsService, setOrgStatsService] = useState(null);
        const [recruitingRetentionModal, setRecruitingRetentionModal] = useState({ isOpen: false });
        const [esReadinessModal, setESReadinessModal] = useState({ isOpen: false, analysis: null });
        const [currentPage, setCurrentPage] = useState(1);
        const [selectedCadet, setSelectedCadet] = useState(null);
        const [filterStatus, setFilterStatus] = useState('ALL');
        const [filterPhase, setFilterPhase] = useState(null);
        const [phaseFilter, setPhaseFilter] = useState(null);
        const [cadetSearchQuery, setCadetSearchQuery] = useState("");
        const [selectedCadetProfile, setSelectedCadetProfile] = useState(null);
        const [filter90Days, setFilter90Days] = useState(false);
        const [showCadetFilters, setShowCadetFilters] = useState(true);
        const [isMobile, setIsMobile] = useState(() => window.matchMedia('(max-width: 768px)').matches);
        const hasCommittees = (dataFiles.committees && dataFiles.committees.length > 0) || (dataFiles.cadetDuty && dataFiles.cadetDuty.length > 0);
        const navItems = [
          { id: 'home', label: 'Home' },
          { id: 'unit', label: 'Unit Overview' },
          { id: 'senior', label: 'Senior Dashboard' },
          { id: 'cadet', label: 'Cadet Dashboard' },
          { id: 'reports', label: 'Reports' },
          { id: 'org', label: 'Org Chart' },
        ];

        useEffect(() => {
            const handleClickOutside = () => setActiveFilterMenu(null);
            document.addEventListener('click', handleClickOutside);
            return () => document.removeEventListener('click', handleClickOutside);
        }, []);

        useEffect(() => {
          const mq = window.matchMedia('(max-width: 768px)');
          const handleResize = (e) => setIsMobile(e.matches);
          mq.addEventListener('change', handleResize);
          return () => mq.removeEventListener('change', handleResize);
        }, []);

        const persistCache = useCallback((rawString, meta = {}) => {
          try {
            localStorage.setItem(DATA_CONSTANTS.CACHE_KEY, JSON.stringify({
              payload: rawString,
              savedAt: Date.now(),
              lastUpdated: meta.lastUpdated || null
            }));
          } catch (e) {
            // localStorage may be full or unavailable - fail silently as cache is optional
          }
        }, []);

        const processPayload = useCallback((result) => {
          setLoadingStatus("Building data indexes...");
          // Capture app configuration from server
          if (result.appConfig) {
            window.APP_CONFIG = { ...APP_CONFIG, ...result.appConfig };
          }
          const service = createDataService();
          service.initialize(result);
          setDataService(service);
          setDataFiles(service.rawData());
          setConfigFiles(service.rawConfig());
          if (result.meta && result.meta.lastUpdated) {
            setLastUpdated(result.meta.lastUpdated);
          }
          // Initialize OrgStats service for recruiting/retention metrics
          if (result.data && result.data.orgStats) {
            const orgStats = createOrgStatsDataService();
            orgStats.initialize(result.data.orgStats);
            setOrgStatsService(orgStats);
          }
        }, []);

        const fetchFromServer = useCallback((lastKnownTimestamp = null) => {
          if (window.google && window.google.script) {
            setLoadingStatus("Fetching latest updates...");
            window.google.script.run
              .withSuccessHandler((response) => {
                const result = JSON.parse(response);
                const serverTimestamp = result.meta && result.meta.lastUpdated ? result.meta.lastUpdated : null;
                const isNewer = serverTimestamp && lastKnownTimestamp ? new Date(serverTimestamp) > new Date(lastKnownTimestamp) : true;
                if (isNewer) {
                  processPayload(result);
                }
                persistCache(response, result.meta || {});
                setLoadingStatus("Finalizing dashboard...");
                setLoading(false);
              })
              .withFailureHandler((error) => {
                if (loading) { alert("Error fetching data: " + error); setLoading(false); }
              })
              .getAppData();
          } else { setLoading(false); }
        }, [loading, persistCache, processPayload]);

        useEffect(() => {
          if (!loading) return;
          const rotation = [
            "Reviewing the local ops log...",
            "Analyzing over 1,400 members profiles...",
            "Preparing insights for nearly 40 units...",
            "Checking in with headquarters...",
            "Syncing personnel and training records...",
            "Lining up the promotion requirements...",
            "Forming up your dashboards..."
          ];
          let index = 0;
          const intervalId = setInterval(() => {
            setLoadingStatus((current) => {
              if (!loading) return current;
              index = (index + 1) % rotation.length;
              return rotation[index];
            });
          }, 1800);
          return () => clearInterval(intervalId);
        }, [loading]);

        useEffect(() => {
          const loadData = () => {
            const cached = localStorage.getItem(DATA_CONSTANTS.CACHE_KEY);
            if (cached) {
              try {
                setLoadingStatus("Loading cached data...");
                const parsedCache = JSON.parse(cached);
                const payloadString = parsedCache.payload || cached;
                const payload = typeof payloadString === 'string' ? JSON.parse(payloadString) : payloadString;
                const savedAt = parsedCache.savedAt || null;
                const cacheLastUpdated = parsedCache.lastUpdated || (payload.meta && payload.meta.lastUpdated) || null;
                const isStale = savedAt ? (Date.now() - savedAt) > DATA_CONSTANTS.CACHE_MAX_AGE_MS : false;
                processPayload(payload);
                setLoading(false);
                fetchFromServer(cacheLastUpdated || null);
                return;
              } catch (e) {
                // Cache is corrupted or in old format - clear and fetch fresh
                localStorage.removeItem(DATA_CONSTANTS.CACHE_KEY);
              }
            }
            setLoadingStatus("Requesting server data...");
            fetchFromServer();
          };
          loadData();
        }, [fetchFromServer, processPayload]);

        const levelPathMap = useMemo(() => deriveLevelPathMap(configFiles.paths || []), [configFiles.paths]);

        const unitChildrenMap = useMemo(() => {
           const map = new Map();
           if(dataFiles.organization.length) {
              dataFiles.organization.forEach(o => {
                 const parentId = String(o.NextLevel).trim();
                 const childId = String(o.ORGID).trim();
                 if(parentId && parentId !== childId) {
                    if(!map.has(parentId)) map.set(parentId, []);
                    map.get(parentId).push(childId);
                 }
              });
           }
           return map;
        }, [dataFiles.organization]);

        const getDescendantOrgIds = (rootId) => {
           const root = String(rootId).trim();
           let results = [root];
           const queue = [root];
           const visited = new Set([root]); 
           while(queue.length > 0){
             const curr = queue.shift();
             const kids = unitChildrenMap.get(curr) || [];
             kids.forEach(k => {
               if(!visited.has(k)){
                 visited.add(k); results.push(k); queue.push(k);
               }
             });
           }
           return results;
        };

        const availableUnits = useMemo(() => {
          if (!dataFiles.members.length) return [];
          const units = new Map();

          dataFiles.members.forEach(m => {
            if (m.ORGID && m.Unit && !isNaN(parseInt(m.Unit)) && /^\d+$/.test(m.Unit.trim())) {
               const cleanUnit = m.Unit.replace(/^0+/, '').padStart(3, '0');
               if (cleanUnit === '000' || cleanUnit === '004') return;
               if(!units.has(m.ORGID)){
                  units.set(m.ORGID, { id: m.ORGID, unitNum: cleanUnit, name: `Unit ${cleanUnit}` });
               }
            }
          });

          if(dataFiles.organization.length){
             dataFiles.organization.forEach(o => {
                if(units.has(o.ORGID)) {
                   const entry = units.get(o.ORGID);
                   const cleanUnit = o.Unit ? o.Unit.replace(/^0+/, '').padStart(3, '0') : entry.unitNum;
                   entry.name = `${o.Region}-${o.Wing}-${cleanUnit} ${o.Name}`;
                   entry.unitNum = cleanUnit;
                }
             });
          }

          return Array.from(units.values()).sort((a, b) => parseInt(a.unitNum) - parseInt(b.unitNum));
        }, [dataFiles.members, dataFiles.organization]);

        useEffect(() => { 
            if (!unitFilter && availableUnits.length > 0) {
                setUnitFilter(availableUnits[0].id); 
            }
        }, [availableUnits]);

        useEffect(() => {
          setSelectedReport(null);
          setSelectedTaskMembers(null);
          setSelectedCadet(null);
          setFilterStatus('ALL');
          setReportsCollapsed(false);
        }, [unitFilter]);
        
        // --- HANDLE SUB-UNIT TOGGLE ---
        const handleShowSubUnits = (e) => {
            if (e.target.checked) {
                setIsAggregating(true);
                // Slight delay to allow UI to render loading state before heavy calculation
                setTimeout(() => {
                    setShowAllDescendants(true);
                    setIsAggregating(false);
                }, 100);
            } else {
                setShowAllDescendants(false);
            }
        };

        const buildMemberProfileData = (member) => {
          if (!member) return null;
          const id = member.CAPID;

          const rawDuties = dataFiles.duty.filter(d => d.CAPID === id);
          const duties = rawDuties.map(d => {
              const org = dataFiles.organization.find(o => o.ORGID === d.ORGID);
              const orgString = org ? `${org.Region}-${org.Wing}-${org.Unit}` : "Unknown";
              return { 
                  name: d.Duty, 
                  isAsst: d.Asst === "1", 
                  date: d.DateMod, 
                  orgString,
                  displayName: `${d.Duty}${d.Asst === "1" ? " (A)" : ""}` 
              };
          });
          const rawTracks = dataFiles.tracks.filter(t => t.CAPID === id);
          const tracks = rawTracks.map(t => ({ name: t.Track, level: t.TrackLevel, date: t.DateMod }));
          
          const dutiesWithStatus = duties.map(duty => {
            const cleanDuty = duty.name.toUpperCase().trim();
            const requiredTrack = DUTY_TO_TRACK_MAP[cleanDuty];
            let hasTrack = true, warningMsg = "";
            if (requiredTrack) {
              const hasEnrolled = tracks.some(t => {
                  const trackName = t.name.toUpperCase().trim();
                  return trackName.includes(requiredTrack) || requiredTrack.includes(trackName);
              });
              if (!hasEnrolled) { hasTrack = false; warningMsg = `Missing Track: ${requiredTrack}`; }
            }
            return { ...duty, hasTrack, warningMsg };
          });

          const tracksWithStatus = tracks.map(track => {
            const isNone = track.level === "NONE";
            let hasDuty = true, warningMsg = "";
            if (isNone) {
              const trackNameUpper = track.name.toUpperCase().trim();
              const relevantDutyExists = duties.some(d => {
                const mappedTrack = DUTY_TO_TRACK_MAP[d.name.toUpperCase().trim()];
                return mappedTrack === trackNameUpper;
              });
              if (!relevantDutyExists) { hasDuty = false; warningMsg = "Enrolled (NONE) but no Duty Position assigned."; }
            }
            return { ...track, hasDuty, warningMsg };
          });

          const { progress: levelsProgress, currentLevel: highestLevel } = calculateLevelsProgress(member, configFiles, dataFiles, levelPathMap);
          const level2Track = determineLevel2Track(dataFiles.memberTasks ? dataFiles.memberTasks.filter(mt => mt.CAPID === id) : []);

          let memberUnitName = "Unknown";
          if (dataFiles.organization) {
              const memOrg = dataFiles.organization.find(o => o.ORGID === member.ORGID);
              if (memOrg) {
                  const r = memOrg.Region || "";
                  const w = memOrg.Wing || "";
                  const u = memOrg.Unit ? memOrg.Unit.replace(/^0+/, '').padStart(3,'0') : "000";
                  memberUnitName = `${r}-${w}-${u}`;
              }
          }

          return { ...member, memberUnitName, duties: dutiesWithStatus, tracks: tracksWithStatus, levelsProgress, level2Track, rankDate: member.RankDate, currentLevel: highestLevel };
        };

        const processedData = useMemo(() => {
          if (!dataService || !unitFilter) return [];
          // Now the component just asks the service for the data it needs.
          return dataService.getProcessedMembers(unitFilter, showAllDescendants);
        }, [dataService, unitFilter, showAllDescendants]);

        const cadetData = useMemo(() => {
          if (!dataFiles.members.length) return [];

          let validOrgIds = [unitFilter];
          if (showAllDescendants) {
            validOrgIds = getDescendantOrgIds(unitFilter);
          }

          const cadets = dataFiles.members.filter(m => {
            const type = String(m.Type || m.TYPE || "").toUpperCase();
            const status = String(m.MbrStatus || "").toUpperCase();
            return validOrgIds.includes(m.ORGID) && type === "CADET" && status === "ACTIVE";
          });

          return cadets.map(cadet => {
            let memberUnitName = "Unknown";
            if (dataFiles.organization) {
              const memOrg = dataFiles.organization.find(o => o.ORGID === cadet.ORGID);
              if (memOrg) {
                const r = memOrg.Region || "";
                const w = memOrg.Wing || "";
                const u = memOrg.Unit ? memOrg.Unit.replace(/^0+/, '').padStart(3,'0') : "000";
                memberUnitName = `${r}-${w}-${u}`;
              }
            }

            const cadetDuties = dataFiles.cadetDuty
              ? dataFiles.cadetDuty
                  .filter(d => d.CAPID === cadet.CAPID && d.Duty && !d.Duty.toUpperCase().includes('#REF'))
                  .map(d => {
                  const org = dataFiles.organization.find(o => o.ORGID === d.ORGID);
                  const orgString = org ? `${org.Region}-${org.Wing}-${org.Unit ? org.Unit.replace(/^0+/, '').padStart(3,'0') : '000'}` : "Unknown";
                  return { name: d.Duty, date: d.DateMod, orgString };
                })
              : [];

            return { ...cadet, memberUnitName, cadetDuties };
          });
        }, [dataFiles, unitFilter, showAllDescendants]);

        // Cadet Data Service for Promotion Tracker
        const [cadetDataService, setCadetDataService] = useState(null);

        useEffect(() => {
          const service = createCadetDataService();
          setCadetDataService(service);
        }, []);

        useEffect(() => {
          if (cadetDataService && Object.keys(dataFiles).length > 0) {
            const payload = { data: dataFiles, config: configFiles };
            cadetDataService.initialize(payload);
          }
        }, [cadetDataService, dataFiles, configFiles]);

        const processedCadets = useMemo(() => {
          if (!cadetDataService || !unitFilter) return [];
          try {
            return cadetDataService.getProcessedCadets(unitFilter, showAllDescendants);
          } catch (error) {
            console.error('Error processing cadets:', error);
            return [];
          }
        }, [cadetDataService, unitFilter, showAllDescendants, dataFiles.members, dataFiles.organization, dataFiles.cadetRank, dataFiles.cadetAchvAprs]);

        // Course definitions for PME and Leadership training
        const PME_COURSE_DEFS = [
          { key: 'ncoa', label: 'NCOA', matches: ({ courseKey, howKey }) => courseKey === 'ncoa' || (howKey.includes('nco academy') && !howKey.includes('senior')) },
          { key: 'sncoa', label: 'SNCOA', matches: ({ courseKey, howKey }) => courseKey === 'sncoa' || howKey.includes('senior nco academy') },
          { key: 'sos', label: 'SOS', matches: ({ courseKey, howKey }) => courseKey === 'sos' || howKey.includes('squadron officer school') },
          { key: 'acsc', label: 'ACSC', matches: ({ courseKey, howKey }) => courseKey === 'acsc' || howKey.includes('air command') || howKey.includes('command and general staff') },
          { key: 'awc', label: 'AWC', matches: ({ courseKey, howKey }) => courseKey === 'awc' || howKey.includes('war college') }
        ];

        const CAP_LEADERSHIP_COURSE_DEFS = [
          { key: 'squadron-command', label: 'Squadron Command', matches: ({ courseKey }) => courseKey.includes('squadron command course') },
          { key: 'group-command', label: 'Group Command', matches: ({ courseKey }) => courseKey.includes('group command course') },
          { key: 'region-command', label: 'Region Command', matches: ({ courseKey }) => courseKey.includes('region command course') },
          { key: 'volu', label: 'VOLU Instructor', matches: ({ courseKey }) => courseKey.includes('volu instructor') }
        ];

        const LEGACY_LEADERSHIP_COURSE_DEFS = [
          { key: 'sls', label: 'SLS', matches: ({ courseKey }) => courseKey === 'sls' },
          { key: 'clc', label: 'CLC', matches: ({ courseKey }) => courseKey === 'clc' },
          { key: 'ucc', label: 'UCC', matches: ({ courseKey }) => courseKey === 'ucc' },
          { key: 'rsc', label: 'RSC', matches: ({ courseKey }) => courseKey === 'rsc' },
          { key: 'nsc', label: 'NSC', matches: ({ courseKey }) => courseKey === 'nsc' },
          { key: 'wcc', label: 'WCC', matches: ({ courseKey }) => courseKey.includes('wing chaplain course') || courseKey === 'wcc' }
        ];

        // Training course index for PME and Leadership course tracking
        const trainingRecords = useMemo(() => {
          if (Array.isArray(dataFiles.training)) return dataFiles.training;
          if (typeof parseCSV === 'function') return parseCSV(dataFiles.training);
          return [];
        }, [dataFiles.training]);

        const trainingCourseIndex = useMemo(() => {
          const map = new Map();
          if (!trainingRecords || trainingRecords.length === 0) return map;

          const normalizeText = (value) => String(value || '').trim().replace(/\s+/g, ' ').toLowerCase();
          const parseDateValue = (value) => {
            if (!value) return null;
            const raw = String(value).trim();
            if (!raw || raw === '01/01/1900') return null;
            const parsed = new Date(raw);
            if (Number.isNaN(parsed.getTime())) return null;
            return { raw, date: parsed };
          };
          const getRecordDate = (record) => parseDateValue(record.Completed) || parseDateValue(record.DateMod);
          const upsert = (bucket, key, dateValue) => {
            const current = bucket[key];
            if (!current || dateValue.date > current.date) {
              bucket[key] = dateValue;
            }
          };

          trainingRecords.forEach(record => {
            const capid = String(record.CAPID || '').trim();
            if (!capid) return;
            const courseKey = normalizeText(record.TypeCrs);
            const howKey = normalizeText(record.HowComplete);
            if (!courseKey && !howKey) return;
            const dateValue = getRecordDate(record);
            if (!dateValue) return;
            const bucket = map.get(capid) || { pme: {}, leadership: {}, legacyLeadership: {} };
            const context = { courseKey, howKey };
            PME_COURSE_DEFS.forEach(def => {
              if (def.matches(context)) upsert(bucket.pme, def.key, dateValue);
            });
            CAP_LEADERSHIP_COURSE_DEFS.forEach(def => {
              if (def.matches(context)) upsert(bucket.leadership, def.key, dateValue);
            });
            LEGACY_LEADERSHIP_COURSE_DEFS.forEach(def => {
              if (def.matches(context)) upsert(bucket.legacyLeadership, def.key, dateValue);
            });
            if (!map.has(capid)) map.set(capid, bucket);
          });

          return map;
        }, [trainingRecords]);

        // Build VOLU instructor index - maps CAPID to their instructor qualifications
        // Structure: Map<CAPID, { courses: Map<PathName, { online: boolean, faceToFace: boolean }>, isChair: boolean }>
        const voluInstructorIndex = useMemo(() => {
          const map = new Map();
          if (!dataFiles.voluInstructors || dataFiles.voluInstructors.length === 0) return map;

          dataFiles.voluInstructors.forEach(record => {
            const capid = String(record.CAPID || '').trim();
            if (!capid) return;

            const pathName = String(record.PathName || '').trim();
            const category = String(record.Category || '').trim().toLowerCase();
            const instructorType = String(record.InstructorType || '').trim().toLowerCase();

            if (!pathName) return;

            if (!map.has(capid)) {
              map.set(capid, { courses: new Map(), isChair: false });
            }

            const entry = map.get(capid);

            // Track if this person is a Chair for any course
            if (instructorType === 'chair') {
              entry.isChair = true;
            }

            if (!entry.courses.has(pathName)) {
              entry.courses.set(pathName, { online: false, faceToFace: false });
            }

            const course = entry.courses.get(pathName);
            if (category === 'online') {
              course.online = true;
            } else if (category === 'facetoface') {
              course.faceToFace = true;
            }
          });

          return map;
        }, [dataFiles.voluInstructors]);

        const getLevelBreakdown = (member, levelKey) => {
          const pathId = levelPathMap[levelKey];
          if (!pathId) return null;
          const chosenTrack = member.level2Track || determineLevel2Track(dataFiles.memberTasks ? dataFiles.memberTasks.filter(mt => mt.CAPID === member.CAPID) : []);
          const groups = configFiles.groups.filter(g => g.PathID === pathId);
          const validGroups = groups.filter(g => (parseInt(g.NumberOfRequiredTasks)||0) > 0);

          const mappedGroups = validGroups.map(group => {
            const taskAssignments = configFiles.assignments.filter(a => a.GroupID === group.GroupID);
            let tasks = taskAssignments.map(ta => {
              const taskDef = configFiles.tasks.find(t => t.TaskID === ta.TaskID);
              if (!taskDef) return null;
              const isDone = dataFiles.memberTasks.some(mt => mt.CAPID === member.CAPID && mt.TaskID === ta.TaskID && mt.StatusID === "8");
              const appliesTo = LEVEL2_TASK_TRACKS[taskDef.TaskID] || ["ALL"];
              return { ...taskDef, isDone, appliesTo };
            }).filter(Boolean);

            if ((levelKey === 'L2P1' || levelKey === 'L2P2') && chosenTrack) {
              tasks = tasks.filter(t => (t.appliesTo || []).includes("ALL") || (t.appliesTo || []).includes(chosenTrack));
            }

            const completedCount = tasks.filter(t => t.isDone).length;
            const required = parseInt(group.NumberOfRequiredTasks);
            return { groupName: group.GroupName, required, completedCount, isGroupDone: completedCount >= required, tasks };
          });

          return { groups: mappedGroups, track: chosenTrack };
        };

        const getPromotionDetails = (member) => {
            const normRank = normalizeRank(member.Rank);
            const rules = PROMOTION_RULES[normRank];
            if (!rules) return null;
            const rankDate = new Date(member.rankDate);
            const today = new Date();
            const diffMonths = Math.floor(Math.abs(today - rankDate) / (1000 * 60 * 60 * 24 * 30.44)); 
            const eligibleDate = new Date(rankDate);
            eligibleDate.setMonth(eligibleDate.getMonth() + rules.tigMonths);
            let isDutyMet = true, dutyStatusString = "", currentDutyMonths = 0;
            if (rules.dutyReq) {
               isDutyMet = false;
               const matchingDuties = member.duties.filter(d => {
                   const name = d.name.toUpperCase();
                   if (rules.dutyReq === "Unit NCO") return name.includes("NCO") || name.includes("SERGEANT");
                   if (rules.dutyReq === "NCO Advisor") return name.includes("NCO ADVISOR");
                   if (rules.dutyReq === "Command NCO") return name.includes("COMMAND NCO") || name.includes("SENIOR ENLISTED LEADER");
                   return false;
               });
               if (matchingDuties.length > 0) {
                   let maxMonths = 0;
                   matchingDuties.forEach(d => {
                       const assigned = new Date(d.date);
                       const months = Math.floor(Math.abs(today - assigned) / (1000 * 60 * 60 * 24 * 30.44));
                       if (months > maxMonths) maxMonths = months;
                   });
                   currentDutyMonths = maxMonths;
                   isDutyMet = maxMonths >= rules.dutyMonths;
                   dutyStatusString = isDutyMet ? `Completed (${maxMonths} months)` : `In Progress (${maxMonths} / ${rules.dutyMonths} months)`;
               } else { dutyStatusString = `Missing Assignment: ${rules.dutyReq}`; }
            }
            let levelRequiredLabel = rules.level ? `Level ${rules.level}` : '';
            let levelCurrentLabel = member.currentLevel ? `Level ${member.currentLevel}` : 'Not Started';
            let isLevelMet = rules.level ? member.currentLevel >= rules.level : true;

            if (rules.requiredParts && rules.requiredParts.length > 0) {
               levelRequiredLabel = rules.requiredParts.map(p => LEVEL_DISPLAY_MAP[p]?.name || p).join(' + ');
               isLevelMet = rules.requiredParts.every(p => member.levelsProgress && member.levelsProgress[p] && member.levelsProgress[p].status === 'completed');
               levelCurrentLabel = rules.requiredParts.map(p => {
                  const status = member.levelsProgress && member.levelsProgress[p];
                  const short = LEVEL_DISPLAY_MAP[p]?.label || p;
                  if (status?.status === 'completed') return `${short}: Done`;
                  if (status?.status === 'ready') return `${short}: Ready to submit`;
                  if (status?.status === 'pending') return `${short}: Pending`;
                  return `${short}: Incomplete`;
               }).join(' | ');
            }

            return {
              currentRank: member.Rank,
              nextRank: rules.next,
              rankDate: member.rankDate,
              tigMonthsCurrent: diffMonths,
              tigMonthsRequired: rules.tigMonths,
              eligibleDate: eligibleDate.toLocaleDateString(),
              isTigMet: diffMonths >= rules.tigMonths,
              levelRequired: levelRequiredLabel,
              levelCurrent: levelCurrentLabel,
              isLevelMet,
              dutyReq: rules.dutyReq,
              isDutyMet,
              dutyStatusString
            };
        };

        const getEtSummary = (member) => {
            const progress = member.levelsProgress || {};
            const completedIds = LEVEL_ORDER.filter(id => progress[id] && progress[id].status === 'completed');
            const highestCompleted = completedIds.length ? completedIds[completedIds.length - 1] : null;
            const nextId = LEVEL_ORDER.find(id => !progress[id] || progress[id].status !== 'completed') || null;
            const nextStatus = nextId ? progress[nextId] || { status: 'not-started', percent: 0 } : null;
            return { highestCompleted, nextId, nextStatus };
        };

        const getMemberEmail = (capid) => {
          if (!dataFiles.contacts) return null;
          const cap = String(capid).trim();
          const contactsUpper = dataFiles.contacts.map(c => ({
            ...c,
            TypeU: (c.Type || '').toUpperCase(),
            PriorityU: (c.Priority || '').toUpperCase(),
            CAPIDU: String(c.CAPID || '').trim()
          }));
          const primaryEmail = contactsUpper.find(c =>
            c.CAPIDU === cap &&
            c.TypeU === 'EMAIL' &&
            c.PriorityU === 'PRIMARY'
          );
          if (primaryEmail) return primaryEmail.Contact;
          const anyEmail = contactsUpper.find(c => c.CAPIDU === cap && c.TypeU === 'EMAIL');
          return anyEmail ? anyEmail.Contact : null;
        };

        const CADET_PROTECTION_CONFIG = {
          renewalDays: 365,
          dueSoonDays: 60
        };

        const TLC_CONFIG = {
          renewalMonths: 36,
          warningDays: 365,
          graceDays: 365
        };

        const parseDateSafe = (value) => {
          if (!value || value === '01/01/1900') return null;
          if (value instanceof Date) {
            return Number.isNaN(value.getTime()) ? null : value;
          }
          const raw = String(value).trim();
          const mdyMatch = raw.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
          if (mdyMatch) {
            const month = Number(mdyMatch[1]);
            const day = Number(mdyMatch[2]);
            const year = Number(mdyMatch[3]);
            if (month >= 1 && month <= 12 && day >= 1 && day <= 31) {
              const parsed = new Date(year, month - 1, day);
              return Number.isNaN(parsed.getTime()) ? null : parsed;
            }
          }
          const parsed = new Date(raw);
          return Number.isNaN(parsed.getTime()) ? null : parsed;
        };

        const formatShortDate = (value) => {
          if (!value) return 'N/A';
          return value.toLocaleDateString();
        };

        const getAgeYears = (dob) => {
          const date = parseDateSafe(dob);
          if (!date) return null;
          const now = new Date();
          return Math.floor((now - date) / (1000 * 60 * 60 * 24 * 365.25));
        };

        const orgTypeMap = useMemo(() => {
          const map = new Map();
          (dataFiles.organization || []).forEach(org => {
            map.set(String(org.ORGID || '').trim(), String(org.Type || '').toUpperCase());
          });
          return map;
        }, [dataFiles.organization]);

        const unitType = useMemo(() => {
          const org = (dataFiles.organization || []).find(o => String(o.ORGID || '').trim() === String(unitFilter || '').trim());
          return String(org?.Type || '').toUpperCase();
        }, [dataFiles.organization, unitFilter]);

        const unitScope = useMemo(() => {
          const org = (dataFiles.organization || []).find(o => String(o.ORGID || '').trim() === String(unitFilter || '').trim());
          return String(org?.Scope || '').toUpperCase();
        }, [dataFiles.organization, unitFilter]);

        const showTlcCompliance = useMemo(() => {
          if (!unitFilter) return false;
          const type = (unitType || '').toUpperCase();
          const scope = (unitScope || '').toUpperCase();
          const isHigherHq = type.includes('GROUP') || type.includes('WING') || type.includes('REGION') || type.includes('NATIONAL');
          if (isHigherHq) return false;
          if (type.includes('SENIOR')) return false;
          const isCadetComposite = type.includes('CADET') || type.includes('COMPOSITE');
          const isUnitScope = scope === 'UNIT';
          return isCadetComposite && isUnitScope;
        }, [unitFilter, unitType, unitScope]);

        const trainingIndex = useMemo(() => {
          const map = new Map();
          const trainingRecords = Array.isArray(dataFiles.training)
            ? dataFiles.training
            : parseCSV(dataFiles.training);
          (trainingRecords || []).forEach(record => {
            const capid = String(record.CAPID || '').trim();
            if (!capid) return;
            const courseName = String(record.TypeCrs || '').trim();
            const courseKey = courseName.replace(/\s+/g, ' ').trim().toLowerCase();
            let courseType = null;
            if (courseKey === 'cadet protection - basic course') courseType = 'basic';
            if (courseKey === 'cadet protection - cadet course') courseType = 'basic';
            if (courseKey === 'cadet protection - advanced course') courseType = 'advanced';
            if (courseKey === 'cppt') courseType = 'basic';
            const isTlc = /\btlc\b/.test(courseKey)
              || courseKey.includes('training leaders of cadets');
            const tlcLabel = (() => {
              if (!isTlc) return null;
              if (courseKey.includes('on-demand') || courseKey.includes('on demand')) return 'TLC On-Demand';
              if (courseKey.includes('basic')) return 'TLC Basic';
              if (courseKey.includes('intermediate')) return 'TLC Intermediate';
              if (courseKey.includes('advanced')) return 'TLC Advanced';
              return 'TLC';
            })();
            if (!courseType && !tlcLabel) return;
            const completed = parseDateSafe(record.Completed) || parseDateSafe(record.DateMod);
            if (!completed) return;
            if (!map.has(capid)) map.set(capid, { basic: [], advanced: [], tlc: [] });
            if (courseType) {
              map.get(capid)[courseType].push(completed);
            }
            if (tlcLabel) {
              map.get(capid).tlc.push({ date: completed, label: tlcLabel });
            }
          });
          map.forEach(entry => {
            const pickLatest = (dates) => {
              if (!dates || dates.length === 0) return null;
              return dates.reduce((latest, date) => (date > latest ? date : latest), dates[0]);
            };
            const pickLatestRecord = (records) => {
              if (!records || records.length === 0) return null;
              return records.reduce((latest, record) => (record.date > latest.date ? record : latest), records[0]);
            };
            entry.basic = pickLatest(entry.basic);
            entry.advanced = pickLatest(entry.advanced);
            entry.tlc = pickLatestRecord(entry.tlc);
          });
          return map;
        }, [dataFiles.training]);

        const getCadetProtectionStatus = useCallback((member) => {
          if (!member) return null;
          const capid = String(member.CAPID || '').trim();
          const memberType = String(member.Type || member.TYPE || '').toUpperCase();
          const isCadet = memberType === 'CADET';
          const isSenior = memberType === 'SENIOR' || memberType === 'LIFE';
          const age = getAgeYears(member.DOB);
          const basicRequired = isSenior || (isCadet && age !== null && age >= 18);
          const basicEligible = isCadet && age !== null && age >= 17;

          const isGroupOrHigher = (orgId) => {
            const type = orgTypeMap.get(String(orgId || '').trim()) || '';
            return type.includes('GROUP') || type.includes('WING') || type.includes('REGION') || type.includes('NATIONAL');
          };

          const dutyRecords = (dataFiles.duty || []).filter(d => String(d.CAPID || '').trim() === capid);
          const advancedRequired = isSenior && dutyRecords.some(duty => {
            const dutyName = String(duty.Duty || '').toUpperCase().replace(/\s+/g, ' ').trim();
            if (!dutyName) return false;
            const commanderTitles = [
              'COMMANDER',
              'SQUADRON COMMANDER',
              'GROUP COMMANDER',
              'WING COMMANDER',
              'REGION COMMANDER',
              'UNIT COMMANDER'
            ];
            const isCommander = commanderTitles.includes(dutyName);
            const isDeputyCommanderGroupPlus = dutyName.includes('DEPUTY COMMANDER') && isGroupOrHigher(duty.ORGID);
            const isDeputyCommanderCadets = dutyName.includes('DEPUTY COMMANDER') && dutyName.includes('CADET');
            const isDirectorCadetPrograms = dutyName.includes('DIRECTOR') && dutyName.includes('CADET PROGRAM');
            const isChiefOfStaff = dutyName.includes('CHIEF OF STAFF');
            const isLegalOfficer = dutyName.includes('LEGAL OFFICER');
            const isInspectorGeneral = dutyName.includes('INSPECTOR GENERAL');
            return (
              isCommander ||
              isDeputyCommanderGroupPlus ||
              isDeputyCommanderCadets ||
              isDirectorCadetPrograms ||
              isChiefOfStaff ||
              isLegalOfficer ||
              isInspectorGeneral
            );
          });

          const completion = trainingIndex.get(capid) || {};
          const effectiveBasicRequired = basicRequired && !advancedRequired;
          const effectiveBasicEligible = basicEligible && !advancedRequired;
          const now = new Date();
          const statusStyles = {
            current: { tone: 'good', badge: 'bg-emerald-100 text-emerald-700', border: 'border-emerald-200', text: 'text-emerald-700' },
            'due-soon': { tone: 'warn', badge: 'bg-amber-100 text-amber-700', border: 'border-amber-200', text: 'text-amber-700' },
            overdue: { tone: 'bad', badge: 'bg-rose-100 text-rose-700', border: 'border-rose-200', text: 'text-rose-700' },
            missing: { tone: 'bad', badge: 'bg-rose-100 text-rose-700', border: 'border-rose-200', text: 'text-rose-700' },
            eligible: { tone: 'info', badge: 'bg-blue-100 text-blue-700', border: 'border-blue-200', text: 'text-blue-700' },
            'not-required': { tone: 'muted', badge: 'bg-slate-100 text-slate-600', border: 'border-slate-200', text: 'text-slate-600' }
          };

          const buildCourseStatus = ({ id, label, lastCompleted, required, eligible, note }) => {
            let status = 'not-required';
            let expirationDate = null;
            let daysRemaining = null;
            if (lastCompleted) {
              expirationDate = new Date(lastCompleted);
              expirationDate.setDate(expirationDate.getDate() + CADET_PROTECTION_CONFIG.renewalDays);
              daysRemaining = Math.ceil((expirationDate - now) / (1000 * 60 * 60 * 24));
            }
            if (required) {
              if (!lastCompleted) {
                status = 'missing';
              } else if (daysRemaining < 0) {
                status = 'overdue';
              } else if (daysRemaining <= CADET_PROTECTION_CONFIG.dueSoonDays) {
                status = 'due-soon';
              } else {
                status = 'current';
              }
            } else if (eligible) {
              status = 'eligible';
            }

            const statusLabelMap = {
              current: 'Current',
              'due-soon': 'Due soon',
              overdue: 'Overdue',
              missing: 'Missing',
              eligible: 'Eligible',
              'not-required': 'Not required'
            };
            const styles = statusStyles[status] || statusStyles['not-required'];
            const daysText = daysRemaining === null ? 'N/A' : daysRemaining >= 0 ? `${daysRemaining} days remaining` : `${Math.abs(daysRemaining)} days overdue`;
            return {
              id,
              label,
              required,
              eligible,
              lastCompleted,
              expirationDate,
              daysRemaining,
              daysText,
              status,
              statusLabel: statusLabelMap[status] || 'Unknown',
              tone: styles.tone,
              badgeClass: styles.badge,
              borderClass: styles.border,
              textClass: styles.text,
              note
            };
          };

          const basicNote = !effectiveBasicRequired && effectiveBasicEligible
            ? 'Eligible at 17; required annually at 18.'
            : null;
          const basicLabel = isCadet ? 'Cadet Protection - Cadet Course' : 'Cadet Protection - Basic Course';
          const advancedLabel = 'Cadet Protection - Advanced Course';
          const basic = buildCourseStatus({
            id: 'basic',
            label: basicLabel,
            lastCompleted: completion.basic || null,
            required: effectiveBasicRequired,
            eligible: effectiveBasicEligible,
            note: basicNote
          });
          const advanced = buildCourseStatus({
            id: 'advanced',
            label: advancedLabel,
            lastCompleted: completion.advanced || null,
            required: advancedRequired,
            eligible: advancedRequired,
            note: null
          });

          const requiredCourses = [basic, advanced].filter(course => course.required);
          const displayCourses = [basic, advanced].filter(course => course.required || course.eligible);

          const indicator = (() => {
            if (!requiredCourses.length) {
              if (effectiveBasicEligible && !completion.basic) {
                return {
                  tone: 'warn',
                  status: 'due-soon',
                  label: 'Cadet Protection due soon',
                  title: `${basic.label}: Eligible at 17`,
                  items: [{ id: basic.id, label: basic.label, status: 'eligible', statusLabel: 'Eligible' }]
                };
              }
              return {
                tone: 'none',
                status: 'not-required',
                label: 'Cadet Protection not required',
                title: 'Cadet Protection: Not required',
                items: []
              };
            }
            const severity = { missing: 3, overdue: 3, 'due-soon': 2, current: 1 };
            let worst = requiredCourses[0].status;
            requiredCourses.forEach(course => {
              if ((severity[course.status] || 0) > (severity[worst] || 0)) {
                worst = course.status;
              }
            });
            const toneMap = { current: 'good', 'due-soon': 'warn', overdue: 'bad', missing: 'bad' };
            const titleLines = requiredCourses.map(course => {
              const dateInfo = course.lastCompleted ? ` (exp ${formatShortDate(course.expirationDate)})` : '';
              return `${course.label}: ${course.statusLabel}${dateInfo}`;
            });
            return {
              tone: toneMap[worst] || 'none',
              status: worst,
              label: `Cadet Protection ${worst.replace('-', ' ')}`,
              title: titleLines.join('\n'),
              items: requiredCourses.map(course => ({
                id: course.id,
                label: course.label,
                status: course.status,
                statusLabel: course.statusLabel
              }))
            };
          })();

          const summaryLabel = requiredCourses.length
            ? requiredCourses.map(course => course.label).join(' + ')
            : 'None';
          const isCompliant = requiredCourses.length
            ? requiredCourses.every(course => course.status === 'current' || course.status === 'due-soon')
            : true;

          return {
            memberType,
            age,
            basic,
            advanced,
            requiredCourses,
            displayCourses,
            summaryLabel,
            isCompliant,
            indicator
          };
        }, [dataFiles.duty, orgTypeMap, trainingIndex]);

        const getTlcStatus = useCallback((member) => {
          if (!member) return null;
          const capid = String(member.CAPID || '').trim();
          const tlcRecord = trainingIndex.get(capid)?.tlc;
          if (!tlcRecord || !tlcRecord.date) return null;

          const completed = tlcRecord.date;
          const expirationDate = new Date(completed);
          expirationDate.setMonth(expirationDate.getMonth() + TLC_CONFIG.renewalMonths);
          const now = new Date();
          const daysRemaining = Math.ceil((expirationDate - now) / (1000 * 60 * 60 * 24));
          if (daysRemaining < -TLC_CONFIG.graceDays) return null;

          let status = 'current';
          if (daysRemaining < 0) status = 'expired';
          else if (daysRemaining <= TLC_CONFIG.warningDays) status = 'due-soon';

          const statusStyles = {
            current: { badge: 'bg-emerald-100 text-emerald-700', border: 'border-emerald-200', text: 'text-emerald-700' },
            'due-soon': { badge: 'bg-amber-100 text-amber-700', border: 'border-amber-200', text: 'text-amber-700' },
            expired: { badge: 'bg-rose-100 text-rose-700', border: 'border-rose-200', text: 'text-rose-700' }
          };
          const statusLabelMap = { current: 'Current', 'due-soon': 'Due soon', expired: 'Expired' };
          const styles = statusStyles[status] || statusStyles.current;
          const daysText = daysRemaining >= 0
            ? `${daysRemaining} days remaining`
            : `${Math.abs(daysRemaining)} days overdue`;

          return {
            course: tlcRecord.label || 'TLC',
            completed,
            expirationDate,
            daysRemaining,
            daysText,
            status,
            statusLabel: statusLabelMap[status] || status,
            badgeClass: styles.badge,
            borderClass: styles.border,
            textClass: styles.text
          };
        }, [trainingIndex]);

        const getTrainingIndicator = useCallback((member) => {
          const cpStatus = getCadetProtectionStatus(member);
          const tlcStatus = getTlcStatus(member);
          const titleLines = [];

          if (cpStatus?.indicator?.title) {
            titleLines.push(...cpStatus.indicator.title.split('\n'));
          }

          if (tlcStatus) {
            const expLabel = tlcStatus.expirationDate ? ` (exp ${formatShortDate(tlcStatus.expirationDate)})` : '';
            titleLines.push(`TLC (${tlcStatus.course}): ${tlcStatus.statusLabel}${expLabel}`);
          }

          const toneSeverity = { bad: 3, warn: 2, good: 1, none: 0 };
          const cpTone = cpStatus?.indicator?.tone || 'none';
          const tlcTone = tlcStatus
            ? (tlcStatus.status === 'expired' ? 'bad' : tlcStatus.status === 'due-soon' ? 'warn' : 'good')
            : 'none';
          const tone = (toneSeverity[cpTone] || 0) >= (toneSeverity[tlcTone] || 0) ? cpTone : tlcTone;

          return {
            tone: tone || 'none',
            title: titleLines.length ? titleLines.join('\n') : 'Training: No data',
            items: []
          };
        }, [getCadetProtectionStatus, getTlcStatus]);

        // Base unit stats (filtered by ACTIVE status only)
        const baseUnitStats = useMemo(() => {
          if (!dataFiles.members.length) return null;

          let validOrgIds = [unitFilter];
          if (showAllDescendants) validOrgIds = getDescendantOrgIds(unitFilter);

          // Filter to only ACTIVE members
          const unitMembers = dataFiles.members.filter(m => {
            const status = String(m.MbrStatus || "").toUpperCase();
            return validOrgIds.includes(m.ORGID) && status === "ACTIVE";
          });
          const seniors = unitMembers.filter(m => (m.Type || m.TYPE) === "SENIOR" || (m.Type || m.TYPE) === "LIFE").length;
          const cadets = unitMembers.filter(m => (m.Type || m.TYPE) === "CADET").length;
          return { total: unitMembers.length, seniors, cadets };
        }, [dataFiles.members, unitFilter, showAllDescendants]);

        const displayData = useMemo(() => {
            let filtered = processedData.filter(m => {
                const search = searchQuery.toLowerCase();
                const nameMatch = (m.NameLast + m.NameFirst + m.CAPID).toLowerCase().includes(search);
                const dutyMatch = m.duties.some(d => d.name.toLowerCase().includes(search));
                return nameMatch || dutyMatch;
            });

            if (filterPromoReady) {
                filtered = filtered.filter(m => { const d = getPromotionDetails(m); return d && d.isTigMet && d.isLevelMet && (!d.dutyReq || d.isDutyMet); });
            }

            if (levelFilter.level !== null) {
                filtered = filtered.filter(m => {
                    const status = m.levelsProgress[levelFilter.level];
                    if (!status) return false;
                    return levelFilter.state === 'complete' ? status.status === 'completed' : status.status !== 'completed';
                });
            }

            // Filter by individual ranks
            if (filters.ranks.length > 0) {
               filtered = filtered.filter(m => {
                   const r = normalizeRank(m.Rank);
                   return filters.ranks.includes(r);
               });
            }

            // Filter by rank categories
            if (filters.rankCategories.length > 0) {
               filtered = filtered.filter(m => {
                   const r = normalizeRank(m.Rank);
                   for (const cat of filters.rankCategories) {
                     if (cat === 'OFFICER' && ["2D LT","1ST LT","CAPT","MAJ","LT COL","COL"].includes(r)) return true;
                     if (cat === 'NCO' && ["SSGT","TSGT","MSGT","SMSGT","CMSGT"].includes(r)) return true;
                     if (cat === 'FLIGHT' && ["FO","TFO","SFO"].includes(r)) return true;
                     if (cat === 'SM' && r === "SM") return true;
                   }
                   return false;
               });
            }

            // Filter by specific track names AND/OR track rating levels
            // When both are selected, use AND logic (must match both criteria)
            if (filters.tracks.length > 0 || filters.trackLevels.length > 0) {
              filtered = filtered.filter(m => {
                  // Handle NONE level special case
                  if (filters.trackLevels.includes('NONE') && m.tracks.length === 0) {
                    return filters.tracks.length === 0; // Only match if no specific tracks selected
                  }

                  // If both track name and level filters are active, must match BOTH (AND logic)
                  if (filters.tracks.length > 0 && filters.trackLevels.length > 0) {
                    return m.tracks.some(t => {
                      const trackNameUpper = t.name.toUpperCase().trim();
                      const matchesName = filters.tracks.some(filterTrack => trackNameUpper.includes(filterTrack));
                      const matchesLevel = filters.trackLevels.includes(t.level);
                      return matchesName && matchesLevel; // AND logic
                    });
                  }

                  // If only track name filter is active
                  if (filters.tracks.length > 0) {
                    return m.tracks.some(t => {
                      const trackNameUpper = t.name.toUpperCase().trim();
                      return filters.tracks.some(filterTrack => trackNameUpper.includes(filterTrack));
                    });
                  }

                  // If only track level filter is active
                  if (filters.trackLevels.length > 0) {
                    return m.tracks.some(t => filters.trackLevels.includes(t.level));
                  }

                  return true;
              });
            }

            // Filter by functional areas
            if (filters.functionalAreas.length > 0) {
               filtered = filtered.filter(m => {
                  return m.duties.some(d => {
                      const cleanDuty = d.name.toUpperCase().trim();
                      const track = DUTY_TO_TRACK_MAP[cleanDuty];
                      return filters.functionalAreas.includes(track);
                  });
               });
            }

            // Filter by specific duties
            if (filters.duties.length > 0) {
               filtered = filtered.filter(m => {
                  return m.duties.some(d => {
                      const cleanDuty = d.name.toUpperCase().trim();
                      return filters.duties.some(filterDuty => cleanDuty.includes(filterDuty.toUpperCase()));
                  });
               });
            }

            // Filter by duty type (Primary vs Assistant)
            if (filters.dutyTypes.length > 0) {
               filtered = filtered.filter(m => {
                  return m.duties.some(d => {
                      if (filters.dutyTypes.includes('PRIMARY') && !d.isAsst) return true;
                      if (filters.dutyTypes.includes('ASSISTANT') && d.isAsst) return true;
                      return false;
                  });
               });
            }

            // Filter by member type
            if (filters.memberTypes.length > 0) {
               filtered = filtered.filter(m => {
                  const memberType = (m.Type || m.TYPE);
                  return filters.memberTypes.includes(memberType);
               });
            }

            if (filterTlcQualified) {
              filtered = filtered.filter(m => {
                const tlc = getTlcStatus(m);
                return tlc && tlc.status !== 'expired';
              });
            }

            return filtered;
        }, [processedData, searchQuery, filterPromoReady, levelFilter, filters, filterTlcQualified, getTlcStatus]);

        const paginatedData = useMemo(() => {
           const startIndex = (currentPage - 1) * DATA_CONSTANTS.ITEMS_PER_PAGE;
           return displayData.slice(startIndex, startIndex + DATA_CONSTANTS.ITEMS_PER_PAGE);
        }, [displayData, currentPage]);

        const totalPages = Math.ceil(displayData.length / DATA_CONSTANTS.ITEMS_PER_PAGE);

        // Dynamic statistics based on filtered data
        const unitStats = useMemo(() => {
          if (!displayData || displayData.length === 0) return null;

          const promoReady = displayData.filter(m => {
            const d = getPromotionDetails(m);
            return d && d.isTigMet && d.isLevelMet && (!d.dutyReq || d.isDutyMet);
          }).length;

          const levelCounts = LEVEL_ORDER.reduce((acc, id) => { acc[id] = 0; return acc; }, {});
          displayData.forEach(m => {
            LEVEL_ORDER.forEach(id => {
              if (m.levelsProgress && m.levelsProgress[id] && m.levelsProgress[id].status === 'completed') {
                levelCounts[id] = (levelCounts[id] || 0) + 1;
              }
            });
          });

          // Enhanced statistics
          const withDuties = displayData.filter(m => m.duties.length > 0).length;
          const withTracks = displayData.filter(m => m.tracks.length > 0).length;
          const withMasterTrack = displayData.filter(m => m.tracks.some(t => t.level === 'MASTER')).length;
          const withSeniorTrack = displayData.filter(m => m.tracks.some(t => t.level === 'SENIOR')).length;
          const withTechTrack = displayData.filter(m => m.tracks.some(t => t.level === 'TECHNICIAN')).length;

          // Average time in grade calculation
          let totalTIG = 0;
          let tigCount = 0;
          displayData.forEach(m => {
            if (m.rankDate) {
              const rankDate = new Date(m.rankDate);
              const today = new Date();
              const months = Math.floor(Math.abs(today - rankDate) / (1000 * 60 * 60 * 24 * 30.44));
              totalTIG += months;
              tigCount++;
            }
          });
          const avgTIG = tigCount > 0 ? Math.round(totalTIG / tigCount) : 0;

          // Duty assignment statistics
          const primaryDuties = displayData.filter(m => m.duties.some(d => !d.isAsst)).length;
          const assistantDuties = displayData.filter(m => m.duties.some(d => d.isAsst)).length;

          const cadetProtectionStats = (() => {
            const summary = {
              requiredMembers: 0,
              compliant: 0,
              nonCompliant: 0,
              dueSoon: 0,
              overdue: 0,
              missing: 0,
              percent: 0
            };
            displayData.forEach(member => {
              const status = getCadetProtectionStatus(member);
              if (!status || status.requiredCourses.length === 0) return;
              summary.requiredMembers += 1;
              const hasOverdue = status.requiredCourses.some(course => course.status === 'overdue');
              const hasMissing = status.requiredCourses.some(course => course.status === 'missing');
              const hasDueSoon = status.requiredCourses.some(course => course.status === 'due-soon');
              if (hasOverdue) summary.overdue += 1;
              if (hasMissing) summary.missing += 1;
              if (hasDueSoon) summary.dueSoon += 1;
              if (hasOverdue || hasMissing) summary.nonCompliant += 1;
              else summary.compliant += 1;
            });
            summary.percent = summary.requiredMembers > 0
              ? Math.round((summary.compliant / summary.requiredMembers) * 100)
              : 0;
            return summary;
          })();

          const tlcCompliance = (() => {
            if (!showTlcCompliance) return null;
            const required = 2;
            const qualified = displayData.filter(member => {
              const tlc = getTlcStatus(member);
              return tlc && tlc.status !== 'expired';
            }).length;
            return {
              required,
              qualified,
              percent: Math.min(100, Math.round((qualified / required) * 100)),
              isCompliant: qualified >= required
            };
          })();

          return {
            filtered: displayData.length,
            promoReady,
            levelCounts,
            withDuties,
            withTracks,
            withMasterTrack,
            withSeniorTrack,
            withTechTrack,
            avgTIG,
            primaryDuties,
            assistantDuties,
            dutyAssignmentRate: displayData.length > 0 ? Math.round((withDuties / displayData.length) * 100) : 0,
            trackEnrollmentRate: displayData.length > 0 ? Math.round((withTracks / displayData.length) * 100) : 0,
            cadetProtection: cadetProtectionStats,
            tlcCompliance
          };
        }, [displayData, getCadetProtectionStatus, getTlcStatus, showTlcCompliance]);

        const handleLevelFilterClick = (lvl) => {
            if (levelFilter.level === lvl) {
                if (levelFilter.state === 'complete') setLevelFilter({ level: lvl, state: 'incomplete' });
                else if (levelFilter.state === 'incomplete') setLevelFilter({ level: null, state: null });
                else setLevelFilter({ level: lvl, state: 'complete' }); 
            } else { setLevelFilter({ level: lvl, state: 'complete' }); }
        };

        const toggleFilter = (category, value) => {
            setFilters(prev => {
                const current = prev[category];
                const updated = current.includes(value)
                   ? current.filter(item => item !== value)
                   : [...current, value];
                return { ...prev, [category]: updated };
            });
            setCurrentPage(1);
        };

        const clearFilters = () => {
          setFilters({
            ranks: [],
            rankCategories: [],
            functionalAreas: [],
            tracks: [],
            trackLevels: [],
            duties: [],
            dutyTypes: [],
            memberTypes: []
          });
          setSearchQuery("");
          setFilterPromoReady(false);
          setFilterTlcQualified(false);
          setLevelFilter({ level: null, state: null });
        };

        // Extract unique values from data for filter options
        const availableRanks = useMemo(() => {
          const ranks = new Set();
          processedData.forEach(m => {
            const r = normalizeRank(m.Rank);
            if (r) ranks.add(r);
          });
          return Array.from(ranks).sort();
        }, [processedData]);

        const availableTracks = useMemo(() => {
          const tracks = new Set();
          processedData.forEach(m => {
            m.tracks.forEach(t => {
              tracks.add(t.name.toUpperCase().trim());
            });
          });
          return Array.from(tracks).sort();
        }, [processedData]);

        const availableDuties = useMemo(() => {
          const duties = new Set();
          processedData.forEach(m => {
            m.duties.forEach(d => {
              duties.add(d.name.toUpperCase().trim());
            });
          });
          return Array.from(duties).sort();
        }, [processedData]);

        const availableFunctionalAreas = useMemo(() => {
          const functionalAreas = new Set();
          processedData.forEach(m => {
            m.duties.forEach(d => {
              const cleanDuty = d.name.toUpperCase().trim();
              const functionalArea = DUTY_TO_TRACK_MAP[cleanDuty];
              if (functionalArea) {
                functionalAreas.add(functionalArea);
              }
            });
          });
          return Array.from(functionalAreas).sort();
        }, [processedData]);

        // Report Generation Functions
        const generateMostNeededTraining = (membersOverride = null) => {
          const memberPool = Array.isArray(membersOverride) ? membersOverride : processedData;
          if (!memberPool.length || !configFiles.groups.length) return [];

          const isModeratedTaskForLevel = (levelId, taskName) => {
            const normalized = normalizeTaskName(taskName);
            const allowed = MODERATED_LOOKUP[levelId] || new Set();
            if (!allowed.size) return false; // No moderated modules for this level (e.g., Level 1)
            if (allowed.has(normalized)) return true;
            // Allow loose matching when names vary slightly between PDFs and task catalog
            return Array.from(allowed).some(entry => normalized.includes(entry) || entry.includes(normalized));
          };

          // Helper function to determine a member's current working level (lowest incomplete)
          const getCurrentWorkingLevel = (member) => {
            for (const levelId of LEVEL_ORDER) {
              const levelProgress = member.levelsProgress[levelId];
              if (levelProgress && levelProgress.status !== 'completed') {
                return levelId;
              }
            }
            return null; // All complete or no data
          };

          const taskNeedCount = new Map();
          const membersWorkingOnLevel = {}; // Track how many are actively working each level

          // First, count how many members are actively working on each level (current working level only)
          LEVEL_ORDER.forEach(levelId => {
            membersWorkingOnLevel[levelId] = memberPool.filter(m => getCurrentWorkingLevel(m) === levelId).length;
          });

          // For each level
          LEVEL_ORDER.forEach(levelId => {
            const pathId = levelPathMap[levelId];
            if (!pathId) return;

            const moderatedList = MODERATED_LOOKUP[levelId];
            if (!moderatedList || moderatedList.size === 0) return;

            const groups = configFiles.groups.filter(g => g.PathID === pathId);
            const validGroups = groups.filter(g => (parseInt(g.NumberOfRequiredTasks)||0) > 0);

            validGroups.forEach(group => {
              const taskAssignments = configFiles.assignments.filter(a => a.GroupID === group.GroupID);

              taskAssignments.forEach(ta => {
                const taskDef = configFiles.tasks.find(t => t.TaskID === ta.TaskID);
                if (!taskDef || !isModeratedTaskForLevel(levelId, taskDef.TaskName)) return;

                const taskKey = `${levelId}|${taskDef.TaskID}`;

                if (!taskNeedCount.has(taskKey)) {
                  taskNeedCount.set(taskKey, {
                    taskId: taskDef.TaskID,
                    taskName: taskDef.TaskName,
                    description: taskDef.Description,
                    level: levelId,
                    groupName: group.GroupName,
                    neededBy: []
                  });
                }

                // Check each member - only if this level is their CURRENT working level
                memberPool.forEach(member => {
                  const currentWorkingLevel = getCurrentWorkingLevel(member);
                  if (currentWorkingLevel !== levelId) return;

                  // Level 2: honor track-specific applicability
                  if (levelId === 'L2P1' || levelId === 'L2P2') {
                    const memberTrack = member.level2Track || determineLevel2Track(dataFiles.memberTasks ? dataFiles.memberTasks.filter(mt => mt.CAPID === member.CAPID) : []);
                    const appliesTo = LEVEL2_TASK_TRACKS[taskDef.TaskID] || ["ALL"];
                    if (memberTrack && !(appliesTo.includes("ALL") || appliesTo.includes(memberTrack))) return;
                  }

                  const isDone = dataFiles.memberTasks.some(mt =>
                    mt.CAPID === member.CAPID && mt.TaskID === taskDef.TaskID && mt.StatusID === "8"
                  );
                  if (!isDone) {
                    taskNeedCount.get(taskKey).neededBy.push({
                      capid: member.CAPID,
                      name: `${member.NameLast}, ${member.NameFirst}`,
                      rank: member.Rank
                    });
                  }
                });
              });
            });
          });

          // Convert to array and rank by overall need (moderated-only)
          const allResults = Array.from(taskNeedCount.values())
            .map(item => {
              const workingOnLevel = membersWorkingOnLevel[item.level] || 0;
              const neededByCount = item.neededBy.length;
              const percentageOfLevelPopulation = workingOnLevel > 0 ? Math.round((neededByCount / workingOnLevel) * 100) : 0;
              const percentageOfUnit = memberPool.length > 0 ? Math.round((neededByCount / memberPool.length) * 100) : 0;

              return {
                ...item,
                neededByCount,
                percentageOfUnit,
                percentageOfLevel: percentageOfLevelPopulation,
                workingOnLevel
              };
            })
            .filter(item => item.neededByCount > 0);

          return allResults.sort((a, b) => {
            if (b.neededByCount !== a.neededByCount) return b.neededByCount - a.neededByCount;
            if (b.percentageOfUnit !== a.percentageOfUnit) return b.percentageOfUnit - a.percentageOfUnit;
            return a.taskName.localeCompare(b.taskName);
          });
        };

        const generateDiscrepanciesReport = (membersOverride = null) => {
          const memberPool = Array.isArray(membersOverride) ? membersOverride : processedData;
          if (!memberPool.length) return [];

          const discrepancies = [];

          memberPool.forEach(member => {
            const issues = [];

            member.duties.forEach(duty => {
              const cleanDuty = duty.name.toUpperCase().trim();
              const requiredTrack = DUTY_TO_TRACK_MAP[cleanDuty];

              if (requiredTrack) {
                const hasEnrolled = member.tracks.some(t => {
                  const trackName = t.name.toUpperCase().trim();
                  return trackName.includes(requiredTrack) || requiredTrack.includes(trackName);
                });

                if (!hasEnrolled) {
                  issues.push({
                    duty: duty.name,
                    requiredTrack
                  });
                }
              }
            });

            if (issues.length > 0) {
              discrepancies.push({
                capid: member.CAPID,
                memberName: `${member.NameLast}, ${member.NameFirst}`,
                rank: member.Rank,
                issues
              });
            }
          });

          // Sort by number of issues descending
          return discrepancies.sort((a, b) => b.issues.length - a.issues.length);
        };

        const generateApprovalNeededReport = (membersOverride = null) => {
          const memberPool = Array.isArray(membersOverride) ? membersOverride : processedData;
          if (!memberPool.length) return [];

          const seniorsOnly = memberPool.filter(m => {
            const type = (m.Type || m.TYPE || '').toUpperCase();
            return type === 'SENIOR' || type === 'LIFE';
          });

          const rows = [];
          seniorsOnly.forEach(member => {
            LEVELS.forEach(lvl => {
              const status = member.levelsProgress && member.levelsProgress[lvl.id];
              if (!status) return;
              if (status.status === 'ready' || status.status === 'pending') {
                const statusLabel = status.status === 'pending'
                  ? (status.approvalStatus === 'disapproved' ? 'Submitted - Needs Update' : 'Submitted - Pending')
                  : 'Ready to Submit';
                rows.push({
                  capid: member.CAPID,
                  memberName: `${member.NameLast}, ${member.NameFirst}`,
                  rank: member.Rank,
                  unit: member.memberUnitName,
                  levelId: lvl.id,
                  levelLabel: lvl.label,
                  levelName: lvl.name,
                  status: statusLabel,
                  percent: status.percent || 0
                });
              }
            });
          });

          return rows.sort((a, b) => {
            const ln = a.memberName.localeCompare(b.memberName);
            if (ln !== 0) return ln;
            return (a.levelId || '').localeCompare(b.levelId || '');
          });
        };

        const generatePromotionEligibilityReport = (membersOverride = null) => {
          const memberPool = Array.isArray(membersOverride) ? membersOverride : processedData;
          if (!memberPool.length) return [];

          const seniorsOnly = memberPool.filter(m => {
            const type = (m.Type || m.TYPE || '').toUpperCase();
            return type === 'SENIOR' || type === 'LIFE';
          });

          const rows = [];
          seniorsOnly.forEach(member => {
            const promoDetails = getPromotionDetails(member);
            if (!promoDetails) return;

            // Exclude Lt Cols - they can only be promoted to Col with wing command position
            const normRank = normalizeRank(member.Rank);
            if (normRank === 'LT COL') return;

            // Check if member is eligible for promotion
            const isEligible = promoDetails.isTigMet && promoDetails.isLevelMet && (!promoDetails.dutyReq || promoDetails.isDutyMet);

            if (isEligible) {
              rows.push({
                capid: member.CAPID,
                memberName: `${member.NameLast}, ${member.NameFirst}`,
                rank: member.Rank,
                unit: member.memberUnitName,
                nextRank: promoDetails.nextRank,
                tigMonths: promoDetails.tigMonthsCurrent,
                tigRequired: promoDetails.tigMonthsRequired,
                tigDisplay: `${promoDetails.tigMonthsCurrent}m (${promoDetails.tigMonthsRequired}m req)`,
                levelCurrent: promoDetails.levelCurrent,
                levelRequired: promoDetails.levelRequired,
                levelDisplay: `${promoDetails.levelCurrent} (${promoDetails.levelRequired} req)`,
                dutyStatus: promoDetails.dutyStatusString || 'N/A',
                eligibleDate: promoDetails.eligibleDate
              });
            }
          });

          return rows.sort((a, b) => {
            // Sort by next rank first (higher ranks first)
            const rankOrder = ["CMSgt", "SMSgt", "MSgt", "TSgt", "SSgt", "Col", "Lt Col", "Maj", "Capt", "1st Lt", "2d Lt", "SFO", "TFO", "FO"];
            const aRankIdx = rankOrder.indexOf(a.nextRank);
            const bRankIdx = rankOrder.indexOf(b.nextRank);
            if (aRankIdx !== bRankIdx) return aRankIdx - bRankIdx;
            // Then by name
            return a.memberName.localeCompare(b.memberName);
          });
        };

        const generateNearPromotionReport = (membersOverride = null) => {
          const memberPool = Array.isArray(membersOverride) ? membersOverride : processedData;
          if (!memberPool.length) return [];

          const seniorsOnly = memberPool.filter(m => {
            const type = (m.Type || m.TYPE || '').toUpperCase();
            return type === 'SENIOR' || type === 'LIFE';
          });

          const rows = [];
          const NEAR_TIG_THRESHOLD = 6;
          const NEAR_DUTY_THRESHOLD = 6;
          const MAX_TASKS_REMAINING = 5;

          seniorsOnly.forEach(member => {
            const promoDetails = getPromotionDetails(member);
            if (!promoDetails) return;

            const normRank = normalizeRank(member.Rank);
            if (normRank === 'LT COL') return;

            const isFullyEligible = promoDetails.isTigMet && promoDetails.isLevelMet && (!promoDetails.dutyReq || promoDetails.isDutyMet);
            if (isFullyEligible) return;

            const tigMonthsRemaining = promoDetails.tigMonthsRequired - promoDetails.tigMonthsCurrent;
            const isNearTIG = tigMonthsRemaining > 0 && tigMonthsRemaining <= NEAR_TIG_THRESHOLD;

            let dutyMonthsRemaining = 0;
            let isNearDuty = false;
            if (promoDetails.dutyReq && !promoDetails.isDutyMet && promoDetails.currentDutyMonths > 0) {
              const rules = PROMOTION_RULES[normRank];
              if (rules && rules.dutyMonths) {
                dutyMonthsRemaining = rules.dutyMonths - promoDetails.currentDutyMonths;
                isNearDuty = dutyMonthsRemaining > 0 && dutyMonthsRemaining <= NEAR_DUTY_THRESHOLD;
              }
            }

            let tasksRemaining = 5;
            let taskDetails = [];
            if (!promoDetails.isLevelMet && promoDetails.levelRequired) {
              const rules = PROMOTION_RULES[normRank];
              if (rules) {
                if (rules.requiredParts && rules.requiredParts.length > 0) {
                  rules.requiredParts.forEach(partId => {
                    const levelProgress = member.levelsProgress && member.levelsProgress[partId];
                    if (levelProgress && levelProgress.status !== 'completed') {
                      const breakdown = getLevelBreakdown(member, partId);
                      if (breakdown && breakdown.groups) {
                        breakdown.groups.forEach(g => {
                          const remaining = Math.max(0, g.required - g.completedCount);
                          if (remaining > 0) {
                            const incompleteTasks = g.tasks.filter(t => !t.isDone);
                            taskDetails.push({
                              levelId: partId,
                              levelName: LEVEL_DISPLAY_MAP[partId]?.name || partId,
                              groupName: g.groupName,
                              required: g.required,
                              completed: g.completedCount,
                              tasks: incompleteTasks
                            });
                          }
                          tasksRemaining += remaining;
                        });
                      }
                    }
                  });
                } else if (rules.level) {
                  for (let lvl = 1; lvl <= rules.level; lvl++) {
                    const currentLvl = member.currentLevel || 0;
                    if (lvl > currentLvl) {
                      const levelKeys = LEVEL_ORDER.filter(lk => {
                        const def = LEVEL_DISPLAY_MAP[lk];
                        return def && def.baseLevel === lvl;
                      });
                      levelKeys.forEach(levelKey => {
                        const levelProgress = member.levelsProgress && member.levelsProgress[levelKey];
                        if (levelProgress && levelProgress.status !== 'completed') {
                          const breakdown = getLevelBreakdown(member, levelKey);
                          if (breakdown && breakdown.groups) {
                            breakdown.groups.forEach(g => {
                              const remaining = Math.max(0, g.required - g.completedCount);
                              if (remaining > 0) {
                                const incompleteTasks = g.tasks.filter(t => !t.isDone);
                                taskDetails.push({
                                  levelId: levelKey,
                                  levelName: LEVEL_DISPLAY_MAP[levelKey]?.name || levelKey,
                                  groupName: g.groupName,
                                  required: g.required,
                                  completed: g.completedCount,
                                  tasks: incompleteTasks
                                });
                              }
                              tasksRemaining += remaining;
                            });
                          }
                        }
                      });
                      break;
                    }
                  }
                }
              }
            }

            const isNearLevel = tasksRemaining > 0 && tasksRemaining <= MAX_TASKS_REMAINING;

            let category = '';
            let blockingFactors = [];
            let priority = 0;

            if (!promoDetails.isTigMet) {
              if (isNearTIG) {
                category = 'TIG Pending (Near)';
                blockingFactors.push(`${tigMonthsRemaining}m until TIG`);
                priority = 1;
              } else {
                category = 'TIG Pending';
                blockingFactors.push(`${tigMonthsRemaining}m until TIG`);
                priority = 4;
              }
            }

            if (!promoDetails.isLevelMet) {
              if (isNearLevel) {
                if (category) category += ' + Training';
                else category = 'Training Pending (Near)';
                blockingFactors.push(`${tasksRemaining} task${tasksRemaining !== 1 ? 's' : ''} remaining`);
                if (priority === 0 || priority > 2) priority = 2;
              } else if (tasksRemaining > 0) {
                if (category) category += ' + Training';
                else category = 'Training Pending';
                blockingFactors.push(`${tasksRemaining} tasks remaining`);
                if (priority === 0 || priority > 5) priority = 5;
              } else {
                if (category) category += ' + Training';
                else category = 'Training Pending';
                blockingFactors.push(`Level ${promoDetails.levelRequired} needed`);
                if (priority === 0 || priority > 6) priority = 6;
              }
            }

            if (promoDetails.dutyReq && !promoDetails.isDutyMet) {
              if (promoDetails.currentDutyMonths === 0) {
                if (category) category += ' + Duty';
                else category = 'Duty Assignment Needed';
                blockingFactors.push(`Needs ${promoDetails.dutyReq}`);
                if (priority === 0 || priority > 3) priority = 3;
              } else if (isNearDuty) {
                if (category) category += ' + Duty';
                else category = 'Duty Time Pending (Near)';
                blockingFactors.push(`${dutyMonthsRemaining}m until duty req`);
                if (priority === 0 || priority > 1) priority = 1;
              } else {
                if (category) category += ' + Duty';
                else category = 'Duty Time Pending';
                blockingFactors.push(`${dutyMonthsRemaining}m until duty req`);
                if (priority === 0 || priority > 4) priority = 4;
              }
            }

            if (isNearTIG || isNearLevel || isNearDuty || (blockingFactors.length > 0 && blockingFactors.length <= 2)) {
              rows.push({
                capid: member.CAPID,
                memberName: `${member.NameLast}, ${member.NameFirst}`,
                rank: member.Rank,
                unit: member.memberUnitName,
                nextRank: promoDetails.nextRank,
                category,
                blockingFactors: blockingFactors.join(', '),
                priority,
                tigMonthsCurrent: promoDetails.tigMonthsCurrent,
                tigMonthsRequired: promoDetails.tigMonthsRequired,
                tigMonthsRemaining,
                isTigMet: promoDetails.isTigMet,
                isNearTIG,
                tigStatus: promoDetails.isTigMet
                  ? 'Met'
                  : `${tigMonthsRemaining}m remaining (${promoDetails.tigMonthsCurrent}/${promoDetails.tigMonthsRequired})`,
                levelCurrent: promoDetails.levelCurrent,
                levelRequired: promoDetails.levelRequired,
                isLevelMet: promoDetails.isLevelMet,
                tasksRemaining,
                taskDetails,
                isNearLevel,
                dutyStatus: promoDetails.dutyStatusString || 'N/A',
                isDutyMet: promoDetails.isDutyMet,
                dutyMonthsRemaining,
                isNearDuty,
                eligibleDate: promoDetails.eligibleDate
              });
            }
          });

          return rows.sort((a, b) => {
            if (a.priority !== b.priority) return a.priority - b.priority;
            const rankOrder = ["CMSgt", "SMSgt", "MSgt", "TSgt", "SSgt", "Col", "Lt Col", "Maj", "Capt", "1st Lt", "2d Lt", "SFO", "TFO", "FO"];
            const aRankIdx = rankOrder.indexOf(a.nextRank);
            const bRankIdx = rankOrder.indexOf(b.nextRank);
            if (aRankIdx !== bRankIdx) return aRankIdx - bRankIdx;
            return a.memberName.localeCompare(b.memberName);
          });
        };

        // Cadet Report: No Promotion in Last 120 Days
        const generateCadetNoPromotionReport = (membersOverride = null) => {
          const memberPool = Array.isArray(membersOverride) ? membersOverride : processedData;
          if (!memberPool.length || !dataFiles.cadetRank.length) {
            return [];
          }

          const cadets = memberPool.filter(m => {
            const memberType = (m.Type || m.TYPE || '').toUpperCase();
            return memberType === 'CADET';
          });

          const rows = [];
          const today = new Date();
          const threshold = 120;

          cadets.forEach(cadet => {
            const cadetRanks = dataFiles.cadetRank
              .filter(r => String(r.CAPID).trim() === String(cadet.CAPID).trim())
              .sort((a, b) => new Date(b.RankDate) - new Date(a.RankDate));

            if (cadetRanks.length === 0) return;

            const lastPromotion = cadetRanks[0];
            const rankDate = new Date(lastPromotion.RankDate);
            const daysSincePromotion = Math.floor((today - rankDate) / (1000 * 60 * 60 * 24));

            if (daysSincePromotion > threshold) {
              rows.push({
                capid: cadet.CAPID,
                memberName: `${cadet.NameLast}, ${cadet.NameFirst}`,
                unit: cadet.memberUnitName,
                rank: lastPromotion.Rank,
                lastPromotion: lastPromotion.RankDate,
                daysSince: daysSincePromotion
              });
            }
          });

          return rows.sort((a, b) => b.daysSince - a.daysSince);
        };

        // Cadet Report: Membership Lapsing in 90 Days or Less
        const generateMembershipLapseReport = (membersOverride = null) => {
          const memberPool = Array.isArray(membersOverride) ? membersOverride : processedData;
          if (!memberPool.length) return [];

          // Include both seniors (including LIFE members) and cadets
          const activeMembers = memberPool.filter(m => {
            const memberType = (m.Type || m.TYPE || '').toUpperCase();
            return memberType === 'CADET' || memberType === 'SENIOR' || memberType === 'LIFE';
          });

          const rows = [];
          const today = new Date();
          const threshold = 90 * 24 * 60 * 60 * 1000;

          activeMembers.forEach(member => {
            if (!member.Expiration || member.Expiration === '12/31/9998' || member.Expiration === '12/31/9999') return;

            const expirationDate = new Date(member.Expiration);
            const daysUntilExpiration = Math.floor((expirationDate - today) / (1000 * 60 * 60 * 24));

            if (daysUntilExpiration >= 0 && daysUntilExpiration <= 90) {
              rows.push({
                capid: member.CAPID,
                memberName: `${member.NameLast}, ${member.NameFirst}`,
                unit: member.memberUnitName,
                memberType: member.Type || 'UNKNOWN',
                rank: member.Rank || 'N/A',
                expiration: member.Expiration,
                daysUntil: daysUntilExpiration,
                urgency: daysUntilExpiration <= 30 ? 'critical' : daysUntilExpiration <= 60 ? 'warning' : 'caution'
              });
            }
          });

          return rows.sort((a, b) => a.daysUntil - b.daysUntil);
        };

          const generateCadetProtectionReport = (membersOverride = null) => {
            const memberPool = Array.isArray(membersOverride) ? membersOverride : processedData;
            if (!memberPool.length || !getCadetProtectionStatus) return [];

          const statusLabelMap = {
            'due-soon': 'Due Soon',
            overdue: 'Overdue',
            missing: 'Missing'
          };
          const severityMap = { missing: 3, overdue: 3, 'due-soon': 2 };
          const rows = [];
          const now = new Date();

          const pushRow = (member, course, statusKey, requirementLabel, daysTextOverride, expirationOverride, daysSortOverride) => {
            const rawType = String(member.Type || member.TYPE || '').toUpperCase();
            const memberType = rawType || (member.currentRank ? 'CADET' : 'UNKNOWN');
            const lastCompleted = course.lastCompleted || null;
            const expirationDate = expirationOverride || course.expirationDate || null;
            const daysText = daysTextOverride || course.daysText || 'N/A';
            const daysSort = Number.isFinite(daysSortOverride)
              ? daysSortOverride
              : Number.isFinite(course.daysRemaining)
                ? course.daysRemaining
                : statusKey === 'missing'
                  ? -9999
                  : 9999;

            rows.push({
              capid: member.CAPID,
              memberName: `${member.NameLast}, ${member.NameFirst}`,
              unit: member.memberUnitName || 'Unknown',
              memberType,
              rank: member.Rank || member.currentRank || 'N/A',
              course: course.label,
              requirement: requirementLabel,
              status: statusLabelMap[statusKey] || 'Due Soon',
              lastCompleted: lastCompleted ? formatShortDate(lastCompleted) : 'Not completed',
              expiration: expirationDate ? formatShortDate(expirationDate) : 'N/A',
              daysText,
              statusKey,
              daysSort
            });
          };

          memberPool.forEach(member => {
            const cpStatus = getCadetProtectionStatus(member);
            if (!cpStatus) return;

            const flaggedCourses = (cpStatus.requiredCourses || []).filter(course =>
              ['overdue', 'missing', 'due-soon'].includes(course.status)
            );

            flaggedCourses.forEach(course => {
              pushRow(member, course, course.status, 'Required', null, null, null);
            });

            const eligibleNeedsAttention = !flaggedCourses.length &&
              cpStatus.basic &&
              cpStatus.basic.eligible &&
              !cpStatus.basic.lastCompleted &&
              cpStatus.indicator?.status === 'due-soon';

            if (eligibleNeedsAttention) {
              let dueDate = null;
              let daysUntil = null;
              const dob = parseDateSafe(member.DOB);
              if (dob) {
                dueDate = new Date(dob);
                dueDate.setFullYear(dueDate.getFullYear() + 18);
                daysUntil = Math.ceil((dueDate - now) / (1000 * 60 * 60 * 24));
              }
              const daysText = Number.isFinite(daysUntil)
                ? `${daysUntil} days until 18`
                : 'By age 18';
              pushRow(member, cpStatus.basic, 'due-soon', 'Eligible', daysText, dueDate, daysUntil);
            }
          });

            return rows.sort((a, b) => {
              const severityDelta = (severityMap[b.statusKey] || 0) - (severityMap[a.statusKey] || 0);
              if (severityDelta !== 0) return severityDelta;
              return (a.daysSort || 0) - (b.daysSort || 0);
            });
          };

          const generateTlcComplianceReport = (membersOverride = null) => {
            const memberPool = Array.isArray(membersOverride) ? membersOverride : processedData;
            const seniorsOnly = memberPool.filter(m => {
              const type = String(m.Type || m.TYPE || '').toUpperCase();
              return type === 'SENIOR' || type === 'LIFE';
            });
            const requiredCount = 2;
            const specialUnits = new Set(['000', '999']);
            const statusOrder = { missing: 0, expired: 1, 'due-soon': 2, current: 3 };
            const statusLabelMap = {
              current: 'Current',
              'due-soon': 'Due Soon',
              expired: 'Expired',
              missing: 'Missing'
            };
            const getUnitInfo = (orgId) => {
              const org = (dataFiles.organization || []).find(o => String(o.ORGID || '').trim() === String(orgId || '').trim());
              const unitNum = org && org.Unit ? org.Unit.replace(/^0+/, '').padStart(3, '0') : '';
              const unitType = String(org?.Type || '').toUpperCase();
              return { unitNum, unitType };
            };
            const summarizeDuties = (duties = []) => {
              if (!duties.length) return { summary: 'None', full: 'None' };
              const trimmed = duties.filter(Boolean).map(duty => String(duty).trim()).filter(Boolean);
              if (!trimmed.length) return { summary: 'None', full: 'None' };
              const shortList = trimmed.slice(0, 2);
              const summary = trimmed.length > 2
                ? `${shortList.join(', ')} +${trimmed.length - 2} more`
                : shortList.join(', ');
              return { summary, full: trimmed.join(', ') };
            };

            const buildMemberRow = (member) => {
              const tlc = getTlcStatus(member);
              const statusKey = tlc ? tlc.status : 'missing';
              const statusLabel = statusLabelMap[statusKey] || 'Missing';
              const dutyNames = (member.duties || []).map(d => d.displayName || d.name).filter(Boolean);
              const dutySummary = summarizeDuties(dutyNames);
              const isQualified = !!(tlc && tlc.status !== 'expired');
              const unitInfo = getUnitInfo(member.ORGID);

              return {
                capid: member.CAPID,
                memberName: `${member.NameLast}, ${member.NameFirst}`,
                unit: member.memberUnitName || 'Unknown',
                unitNum: unitInfo.unitNum || '',
                unitType: unitInfo.unitType || '',
                rank: member.Rank || 'N/A',
                dutySummary: dutySummary.summary,
                dutyFull: dutySummary.full,
                course: tlc ? (tlc.course || 'TLC') : 'None',
                status: statusLabel,
                statusKey,
                completed: tlc ? formatShortDate(tlc.completed) : 'N/A',
                expiration: tlc ? formatShortDate(tlc.expirationDate) : 'N/A',
                daysText: tlc ? tlc.daysText : 'N/A',
                isQualified
              };
            };

            if (!seniorsOnly.length) {
              return { rows: [], meta: { view: showAllDescendants ? 'unit-summary' : 'individual', required: requiredCount } };
            }

            if (showAllDescendants) {
              const unitMap = new Map();
              seniorsOnly.forEach(member => {
                const unit = member.memberUnitName || 'Unknown';
                const unitInfo = getUnitInfo(member.ORGID);
                if (!unitMap.has(unit)) {
                  unitMap.set(unit, {
                    unit,
                    unitNum: unitInfo.unitNum || '',
                    unitType: unitInfo.unitType || '',
                    totalMembers: 0,
                    current: 0,
                    dueSoon: 0,
                    expired: 0,
                    missing: 0
                  });
                }
                const bucket = unitMap.get(unit);
                bucket.totalMembers += 1;
                const tlc = getTlcStatus(member);
                const statusKey = tlc ? tlc.status : 'missing';
                if (statusKey === 'current') bucket.current += 1;
                else if (statusKey === 'due-soon') bucket.dueSoon += 1;
                else if (statusKey === 'expired') bucket.expired += 1;
                else bucket.missing += 1;
              });

              const rows = Array.from(unitMap.values()).map(row => {
                const qualified = row.current + row.dueSoon;
                const isGroup = row.unitType.includes('GROUP');
                const isSpecialUnit = specialUnits.has(row.unitNum);
                const isExempt = isGroup || isSpecialUnit;
                const isCompliant = isExempt ? true : qualified >= requiredCount;
                return {
                  unit: row.unit,
                  qualified,
                  required: isExempt ? 0 : requiredCount,
                  compliance: isExempt ? 'Exempt' : isCompliant ? 'Compliant' : 'Needs TLC',
                  complianceStatus: isExempt ? 'exempt' : isCompliant ? 'compliant' : 'non-compliant',
                  current: row.current,
                  dueSoon: row.dueSoon,
                  expired: row.expired,
                  missing: row.missing,
                  totalMembers: row.totalMembers,
                  unitNum: row.unitNum,
                  unitType: row.unitType
                };
              }).sort((a, b) => {
                if (a.complianceStatus !== b.complianceStatus) {
                  const order = { 'non-compliant': 0, exempt: 1, compliant: 2 };
                  return (order[a.complianceStatus] || 0) - (order[b.complianceStatus] || 0);
                }
                if (b.qualified !== a.qualified) return b.qualified - a.qualified;
                return a.unit.localeCompare(b.unit);
              });

              return { rows, meta: { view: 'unit-summary', required: requiredCount } };
            }

            const rows = seniorsOnly.map(buildMemberRow).sort((a, b) => {
              const statusDelta = (statusOrder[a.statusKey] || 0) - (statusOrder[b.statusKey] || 0);
              if (statusDelta !== 0) return statusDelta;
              return a.memberName.localeCompare(b.memberName);
            });

            const scopeInfo = getUnitInfo(unitFilter);
            const scopeIsGroup = scopeInfo.unitType.includes('GROUP');
            const scopeIsSpecial = specialUnits.has(scopeInfo.unitNum);
            const scopeIsExempt = scopeIsGroup || scopeIsSpecial;

            return { rows, meta: { view: 'individual', required: scopeIsExempt ? 0 : requiredCount, isExempt: scopeIsExempt } };
          };

        // Cadet Report: Aerospace Education Modules/Tests Completion
        const generateAerospaceEducationReport = (membersOverride = null) => {
          const memberPool = Array.isArray(membersOverride) ? membersOverride : processedData;
          if (!memberPool.length) return [];

        const cadets = memberPool.filter(m => {
          const memberType = (m.Type || m.TYPE || '').toUpperCase();
          return memberType === 'CADET';
        });

          const rows = [];

          const normalizeDateValue = (dateString) => {
            if (!dateString) return null;
            const normalized = `${dateString}`.trim();
            if (!normalized || normalized === '01/01/1900' || normalized === '1900-01-01') return null;
            return normalized;
          };

          const selectBestModuleTask = (tasks = []) => {
            if (!tasks.length) return null;
            const taskWithDates = tasks.find(t => {
              const opts = parseAdditionalOptions(t.AdditionalOptions);
              return normalizeDateValue(opts.DateResult) || normalizeDateValue(opts.CadetInteractiveDate);
            });
            return taskWithDates || tasks[0];
          };

          cadets.forEach(cadet => {
            const capid = String(cadet.CAPID).trim();
            const achievements = dataFiles.cadetAchv.filter(a => String(a.CAPID).trim() === capid);
            const memberTasks = dataFiles.memberTasks.filter(mt => String(mt.CAPID).trim() === capid);

            const rowData = {
              capid: cadet.CAPID,
              memberName: `${cadet.NameLast}, ${cadet.NameFirst}`,
              unit: cadet.memberUnitName,
              rank: cadet.Rank,
              phase: cadet.CadetAchvID ? (parseInt(cadet.CadetAchvID) <= 9 ? 'Phase 1 or 2' : 'Phase 3+') : 'N/A'
            };

            let totalHonorCredits = 0;

            // Process each of the 7 modules
            AEROSPACE_DIMENSIONS_MODULES.forEach(module => {
              const moduleTasks = memberTasks.filter(mt =>
                mt.TaskID === module.taskId && mt.StatusID === '8'
              );
              const primaryTask = selectBestModuleTask(moduleTasks);
              const options = primaryTask ? parseAdditionalOptions(primaryTask.AdditionalOptions) : {};
              const achvRecord = achievements.find(a => a.CadetAchvID === module.achievementId);

              const interactiveDate = normalizeDateValue(options.CadetInteractiveDate) ||
                normalizeDateValue(primaryTask && primaryTask.Completed);
              const interactiveScore = options.CadetInteractiveScore !== undefined && options.CadetInteractiveScore !== null
                ? Number(options.CadetInteractiveScore)
                : null;
              const interactiveCompleted = !!(primaryTask && primaryTask.StatusID === '8' && (interactiveDate || options.CadetInteractive === true || Number.isFinite(interactiveScore)));

              const taskTestScoreRaw = options.ScoreResult;
              const taskTestScore = taskTestScoreRaw !== undefined && taskTestScoreRaw !== null && taskTestScoreRaw !== ''
                ? Number(taskTestScoreRaw)
                : null;
              const testScore = Number.isFinite(taskTestScore)
                ? taskTestScore
                : (achvRecord && achvRecord.AEScore ? parseInt(achvRecord.AEScore) : 0);
              const testDate = normalizeDateValue(options.DateResult) ||
                normalizeDateValue(achvRecord && achvRecord.AEDateP);
              const testCompleted = testScore >= CADET_MIN_TEST_SCORE && !!testDate;

              // Determine honor credit
              const honorCredit = interactiveCompleted && testCompleted;
              if (honorCredit) totalHonorCredits++;

              // Store module data in flattened format
              rowData[`module${module.moduleNum}`] = {
                moduleNum: module.moduleNum,
                achievementName: module.title,
                interactiveCompleted: interactiveCompleted,
                interactiveDate: interactiveDate,
                testCompleted: testCompleted,
                testScore: testScore,
                testDate: testDate,
                honorCredit: honorCredit
              };
            });

            rowData.totalHonorCredits = totalHonorCredits;
            rows.push(rowData);
          });

          return rows.sort((a, b) => a.memberName.localeCompare(b.memberName));
        };

        // Cadet Report: Encampment Completion Status
        const generateEncampmentReport = (membersOverride = null) => {
          const memberPool = Array.isArray(membersOverride) ? membersOverride : processedData;
          if (!memberPool.length) return [];

          const cadets = memberPool.filter(m => {
            const memberType = (m.Type || m.TYPE || '').toUpperCase();
            return memberType === 'CADET';
          });

          const rows = [];

          cadets.forEach(cadet => {
            const activities = dataFiles.cadetActivities ? dataFiles.cadetActivities.filter(a =>
              String(a.CAPID).trim() === String(cadet.CAPID).trim() &&
              (a.Type || '').toUpperCase().includes('ENCAMP')
            ) : [];

            const encampments = activities.map(a => ({
              type: a.Type,
              location: a.Location || 'N/A',
              completed: a.Completed || 'N/A'
            }));

            rows.push({
              capid: cadet.CAPID,
              memberName: `${cadet.NameLast}, ${cadet.NameFirst}`,
              unit: cadet.memberUnitName,
              rank: cadet.Rank,
              encampmentStatus: encampments.length > 0 ? 'Completed' : 'Not Completed',
              completionDate: encampments.length > 0 ? (encampments[0].completed || 'N/A') : 'N/A',
              hasEncampment: encampments.length > 0,
              encampments,
              count: encampments.length
            });
          });

          return rows.sort((a, b) => {
            if (a.hasEncampment !== b.hasEncampment) return a.hasEncampment ? 1 : -1;
            return a.memberName.localeCompare(b.memberName);
          });
        };

        // Cadet Report: Orientation Flights Status
        const generateOFlightReport = (membersOverride = null) => {
          const memberPool = Array.isArray(membersOverride) ? membersOverride : processedData;
          if (!memberPool.length) return [];

          const cadets = memberPool.filter(m => {
            const memberType = (m.Type || m.TYPE || '').toUpperCase();
            return memberType === 'CADET';
          });

          const oFlights = dataFiles.oFlights || [];

          // Powered flight syllabi (6-10)
          const poweredSyllabi = [
            { num: 6, name: 'Ground Handling', short: 'Ground' },
            { num: 7, name: 'Normal Maneuvers', short: 'Normal' },
            { num: 8, name: 'Advanced Maneuvers', short: 'Advanced' },
            { num: 9, name: 'Instruments', short: 'Instruments' },
            { num: 10, name: 'Weather', short: 'Weather' }
          ];

          const rows = [];

          cadets.forEach(cadet => {
            const cadetFlights = oFlights.filter(f =>
              String(f.CAPID || '').trim() === String(cadet.CAPID).trim()
            );

            // Get flights for each syllabus
            const syllabusData = {};
            let totalPoweredFlights = 0;
            let completedSyllabi = 0;

            poweredSyllabi.forEach(syllabus => {
              const flights = cadetFlights.filter(f => parseInt(f.Syllabus) === syllabus.num);
              const latestFlight = flights.sort((a, b) => new Date(b.FltDate) - new Date(a.FltDate))[0];
              syllabusData[`syllabus${syllabus.num}`] = {
                completed: flights.length > 0,
                date: latestFlight?.FltDate || null,
                count: flights.length
              };
              totalPoweredFlights += flights.length;
              if (flights.length > 0) completedSyllabi++;
            });

            // Calculate age from DOB
            let age = null;
            if (cadet.DOB) {
              const dob = parseDateSafe(cadet.DOB);
              if (dob) {
                const today = new Date();
                age = Math.floor((today - dob) / (1000 * 60 * 60 * 24 * 365.25));
              }
            }

            // Back seat rides (syllabus 99)
            const backSeatRides = cadetFlights.filter(f => parseInt(f.Syllabus) === 99).length;

            const hasAnyFlight = totalPoweredFlights > 0 || backSeatRides > 0;

            rows.push({
              capid: cadet.CAPID,
              memberName: `${cadet.NameLast}, ${cadet.NameFirst}`,
              unit: cadet.memberUnitName,
              joinDate: cadet.Joined || 'N/A',
              age: age !== null ? age : 'N/A',
              hasAnyFlight,
              totalPoweredFlights,
              backSeatRides,
              completedSyllabi,
              ...syllabusData
            });
          });

          // Sort: cadets with NO flights first (highlighted), then by name
          return rows.sort((a, b) => {
            if (a.hasAnyFlight !== b.hasAnyFlight) return a.hasAnyFlight ? 1 : -1;
            return a.memberName.localeCompare(b.memberName);
          });
        };

        // Cadet Report: Recent Promotions (30/60 Days)
        const generateRecentPromotionsReport = (membersOverride = null, days = 60) => {
          const memberPool = Array.isArray(membersOverride) ? membersOverride : processedData;
          if (!memberPool.length || !dataFiles.cadetRank.length) return [];

          const cadets = memberPool.filter(m => {
            const memberType = (m.Type || m.TYPE || '').toUpperCase();
            return memberType === 'CADET';
          });

          const rows = [];
          const today = new Date();

          cadets.forEach(cadet => {
            const cadetRanks = dataFiles.cadetRank
              .filter(r => String(r.CAPID).trim() === String(cadet.CAPID).trim())
              .sort((a, b) => new Date(b.RankDate) - new Date(a.RankDate));

            if (cadetRanks.length === 0) return;

            const lastPromotion = cadetRanks[0];
            const rankDate = new Date(lastPromotion.RankDate);
            const daysSincePromotion = Math.floor((today - rankDate) / (1000 * 60 * 60 * 24));

            if (daysSincePromotion >= 0 && daysSincePromotion <= days) {
              const previousRank = cadetRanks[1] ? cadetRanks[1].Rank : 'N/A';

              rows.push({
                capid: cadet.CAPID,
                memberName: `${cadet.NameLast}, ${cadet.NameFirst}`,
                unit: cadet.memberUnitName,
                rank: lastPromotion.Rank,
                promotionDate: lastPromotion.RankDate,
                previousRank,
                currentRank: lastPromotion.Rank,
                daysSincePromotion,
                timeframe: daysSincePromotion <= 30 ? '30-day' : '60-day'
              });
            }
          });

          return rows.sort((a, b) => a.daysSincePromotion - b.daysSincePromotion);
        };

        // Cadet Report: Promotion Requirements Table
        const generatePromotionRequirementsReport = (membersOverride = null) => {
          const memberPool = Array.isArray(membersOverride) ? membersOverride : processedData;
          if (!memberPool.length) return [];

          const cadets = memberPool.filter(m => {
            const memberType = (m.Type || m.TYPE || '').toUpperCase();
            return memberType === 'CADET';
          });

          const requirementGroups = {
            leadership: ['leadershipTest', 'wrightBrothersLeadershipExam', 'mitchellLeadershipExam', 'earhartLeadershipExam', 'spaatzLeadershipExam'],
            aerospace: ['aerospaceTest', 'mitchellAerospaceExam', 'spaatzJOFExam'],
            fitness: ['physicalFitness', 'spaatzCFA'],
            character: ['characterDevelopment', 'cadetOath', 'leadershipExpectations', 'leadershipFeedback', 'uniformWear'],
            activity: ['activeParticipation', 'cadetWingmanCourse', 'encampment', 'cls', 'achievement8Speech', 'achievement8Essay', 'eakerSpeech', 'eakerEssay', 'spaatzEssay', 'drillTest', 'sdaService', 'sdaPresentation', 'sdaWriting']
          };

          const summarizeRequirementGroup = (requirements, keys) => {
            if (!requirements) return null;
            const applicable = keys.filter(key => requirements[key]);
            if (!applicable.length) return null;
            return applicable.every(key => requirements[key].completed);
          };

          const buildRequirementDetails = (requirements, orderedKeys = []) => {
            if (!requirements) return [];
            const keys = [];
            const seen = new Set();
            orderedKeys.forEach(key => {
              if (requirements[key]) {
                keys.push(key);
                seen.add(key);
              }
            });
            Object.keys(requirements).forEach(key => {
              if (!seen.has(key)) keys.push(key);
            });
            return keys.map(key => {
              const req = requirements[key];
              if (!req) return null;
              return {
                key,
                label: req.label || CADET_REQUIREMENT_LABELS[key] || key,
                completed: !!req.completed,
                value: req.value || ''
              };
            }).filter(Boolean);
          };

          const buildFallbackRequirementDetails = (summary) => {
            if (!summary) return [];
            return [
              { key: 'leadership', label: 'Leadership', completed: !!summary.leadership, value: '' },
              { key: 'aerospace', label: 'Aerospace', completed: !!summary.aerospace, value: '' },
              { key: 'fitness', label: 'Physical Fitness', completed: !!summary.fitness, value: '' },
              { key: 'character', label: 'Character Development', completed: !!summary.character, value: '' },
              { key: 'activity', label: 'Active Participation', completed: !!summary.activity, value: '' }
            ];
          };

          const formatRequirementDetail = (detail) => {
            if (!detail) return '';
            const label = detail.label || detail.key;
            if (detail.value) return `${label}: ${detail.value}`;
            return `${label}: ${detail.completed ? 'Completed' : 'Not completed'}`;
          };

          const getPhaseLabel = (achievementId) => {
            const phaseId = determinePhaseFromAchievement(achievementId);
            if (!phaseId) return 'Phase I';
            const phaseName = CADET_PHASES[phaseId]?.name || `Phase ${phaseId}`;
            return phaseName.split('(')[0].trim();
          };

          const getCurrentAchievementId = (cadet) => {
            const current = parseInt(cadet.currentAchievement);
            if (!isNaN(current)) return current;

            const approved = Array.isArray(cadet.approvedAchievements) ? cadet.approvedAchievements : [];
            if (approved.length) {
              const parsed = approved.map(a => parseInt(a)).filter(a => !isNaN(a));
              if (parsed.length) return Math.max(...parsed);
            }

            if (cadetDataService && typeof cadetDataService.getApprovedAchievements === 'function') {
              const serviceApproved = cadetDataService.getApprovedAchievements(cadet.CAPID) || [];
              if (serviceApproved.length) return Math.max(...serviceApproved);
            }

            if (dataFiles.cadetAchv && dataFiles.cadetAchv.length) {
              const achievements = dataFiles.cadetAchv.filter(a => String(a.CAPID).trim() === String(cadet.CAPID).trim());
              const completedAchievements = achievements.filter(a =>
                a.PhyFitTest && a.PhyFitTest !== '01/01/1900' &&
                a.LeadLabDateP && a.LeadLabDateP !== '01/01/1900' &&
                a.ActivePart && String(a.ActivePart).toUpperCase() === 'TRUE'
              );
              if (completedAchievements.length > 0) {
                return Math.max(...completedAchievements.map(a => parseInt(a.CadetAchvID) || 0));
              }
            }

            return 0;
          };

          const rows = [];

          cadets.forEach(cadet => {
            const capid = cadet.CAPID;
            const currentAchievementId = getCurrentAchievementId(cadet);
            let nextAchievementId = currentAchievementId + 1;
            if (nextAchievementId > 21) nextAchievementId = null;

            const requirementsData = cadet.nextRequirements
              || (cadetDataService && nextAchievementId
                ? cadetDataService.getAchievementRequirements(capid, String(nextAchievementId), cadet.timeInGrade || null)
                : null);

            const requirementMap = requirementsData && requirementsData.requirements ? requirementsData.requirements : null;
            const requirementKeys = nextAchievementId
              ? (CADET_ACHIEVEMENT_REQUIREMENTS[String(nextAchievementId)] || CADET_DEFAULT_REQUIREMENTS)
              : [];

            let fallbackSummary = null;
            if (!requirementMap && nextAchievementId && dataFiles.cadetAchv && dataFiles.cadetAchv.length) {
              const achievements = dataFiles.cadetAchv.filter(a => String(a.CAPID).trim() === String(cadet.CAPID).trim());
              const nextAchvData = achievements.find(a => parseInt(a.CadetAchvID) === nextAchievementId);
              if (nextAchvData) {
                fallbackSummary = {
                  leadership: nextAchvData.LeadLabDateP && nextAchvData.LeadLabDateP !== '01/01/1900',
                  aerospace: nextAchvData.AEDateP && nextAchvData.AEDateP !== '01/01/1900',
                  fitness: nextAchvData.PhyFitTest && nextAchvData.PhyFitTest !== '01/01/1900',
                  character: nextAchvData.MoralLDateP && nextAchvData.MoralLDateP !== '01/01/1900',
                  activity: nextAchvData.ActivePart && String(nextAchvData.ActivePart).toUpperCase() === 'TRUE'
                };
              }
            }

            const requirementDetails = requirementMap
              ? buildRequirementDetails(requirementMap, requirementKeys)
              : buildFallbackRequirementDetails(fallbackSummary);

            const leadership = requirementMap
              ? summarizeRequirementGroup(requirementMap, requirementGroups.leadership)
              : (fallbackSummary ? fallbackSummary.leadership : null);
            const aerospace = requirementMap
              ? summarizeRequirementGroup(requirementMap, requirementGroups.aerospace)
              : (fallbackSummary ? fallbackSummary.aerospace : null);
            const fitness = requirementMap
              ? summarizeRequirementGroup(requirementMap, requirementGroups.fitness)
              : (fallbackSummary ? fallbackSummary.fitness : null);
            const character = requirementMap
              ? summarizeRequirementGroup(requirementMap, requirementGroups.character)
              : (fallbackSummary ? fallbackSummary.character : null);
            const activity = requirementMap
              ? summarizeRequirementGroup(requirementMap, requirementGroups.activity)
              : (fallbackSummary ? fallbackSummary.activity : null);

            let progressLabel = 'N/A';
            let percentComplete = 0;
            if (!nextAchievementId) {
              progressLabel = 'Complete';
              percentComplete = 100;
            } else if (requirementMap) {
              const requirementEntries = Object.values(requirementMap);
              const total = requirementEntries.length;
              const completed = requirementEntries.filter(r => r.completed).length;
              progressLabel = total ? `${completed}/${total}` : 'N/A';
              percentComplete = total ? Math.round((completed / total) * 100) : 0;
            } else if (fallbackSummary) {
              const summaryValues = Object.values(fallbackSummary).filter(v => v !== null && v !== undefined);
              const total = summaryValues.length;
              const completed = summaryValues.filter(Boolean).length;
              progressLabel = total ? `${completed}/${total}` : 'N/A';
              percentComplete = total ? Math.round((completed / total) * 100) : 0;
            }

            const currentLabel = currentAchievementId > 0
              ? getAchievementDisplayName(currentAchievementId)
              : 'Not Started';
            const nextLabel = nextAchievementId
              ? getAchievementDisplayName(nextAchievementId)
              : 'Completed All';

            const requirementsDetailMessage = requirementDetails.length
              ? ''
              : (nextAchievementId ? 'Requirement details unavailable' : 'All achievements complete');
            const requirementsDetailText = requirementDetails.length
              ? requirementDetails.map(formatRequirementDetail).join('\n')
              : requirementsDetailMessage;

            rows.push({
              capid,
              memberName: `${cadet.NameLast}, ${cadet.NameFirst}`,
              unit: cadet.memberUnitName || cadet.Unit || 'Unknown',
              rank: cadet.currentRank || cadet.Rank || 'N/A',
              currentAchievement: currentLabel,
              currentPhase: currentAchievementId > 0 ? getPhaseLabel(currentAchievementId) : 'Phase I',
              nextAchievement: nextLabel,
              nextPhase: nextAchievementId ? getPhaseLabel(nextAchievementId) : 'Complete',
              leadership,
              aerospace,
              fitness,
              character,
              activity,
              requirementsDetails: requirementDetails,
              requirementsDetailText,
              requirementsDetailMessage,
              progress: progressLabel,
              percentComplete
            });
          });

          return rows.sort((a, b) => a.memberName.localeCompare(b.memberName));
        };

        // Cadet Report: Approaching Age Milestones (18 and 21)
        const generateApproachingAgeMilestoneReport = (membersOverride = null) => {
          const memberPool = Array.isArray(membersOverride) ? membersOverride : processedData;
          if (!memberPool.length) return [];

          const cadets = memberPool.filter(m => {
            const memberType = (m.Type || m.TYPE || '').toUpperCase();
            return memberType === 'CADET';
          });

          const rows = [];
          const today = new Date();
          const sixMonthsDays = 180;

          cadets.forEach(cadet => {
            const dob = parseDateSafe(cadet.DOB);
            if (!dob) return;

            // Calculate current age
            const currentAge = Math.floor((today - dob) / (1000 * 60 * 60 * 24 * 365.25));

            // Check age 18 milestone
            const age18Date = new Date(dob);
            age18Date.setFullYear(age18Date.getFullYear() + 18);
            const daysUntil18 = Math.ceil((age18Date - today) / (1000 * 60 * 60 * 24));

            if (daysUntil18 > 0 && daysUntil18 <= sixMonthsDays) {
              const monthsUntil = Math.floor(daysUntil18 / 30);
              const weeksUntil = Math.floor(daysUntil18 / 7);
              rows.push({
                capid: cadet.CAPID,
                memberName: `${cadet.NameLast}, ${cadet.NameFirst}`,
                unit: cadet.memberUnitName,
                rank: cadet.Rank,
                milestone: 18,
                milestoneLabel: 'Age 18',
                dob: formatShortDate(dob),
                currentAge,
                milestoneDate: formatShortDate(age18Date),
                daysUntil: daysUntil18,
                monthsUntil,
                weeksUntil,
                urgency: daysUntil18 <= 30 ? 'critical' : daysUntil18 <= 90 ? 'warning' : 'notice',
                significance: 'Transition to Senior Member eligibility'
              });
            }

            // Check age 21 milestone
            const age21Date = new Date(dob);
            age21Date.setFullYear(age21Date.getFullYear() + 21);
            const daysUntil21 = Math.ceil((age21Date - today) / (1000 * 60 * 60 * 24));

            if (daysUntil21 > 0 && daysUntil21 <= sixMonthsDays) {
              const monthsUntil = Math.floor(daysUntil21 / 30);
              const weeksUntil = Math.floor(daysUntil21 / 7);
              rows.push({
                capid: cadet.CAPID,
                memberName: `${cadet.NameLast}, ${cadet.NameFirst}`,
                unit: cadet.memberUnitName,
                rank: cadet.Rank,
                milestone: 21,
                milestoneLabel: 'Age 21',
                dob: formatShortDate(dob),
                currentAge,
                milestoneDate: formatShortDate(age21Date),
                daysUntil: daysUntil21,
                monthsUntil,
                weeksUntil,
                urgency: daysUntil21 <= 30 ? 'critical' : daysUntil21 <= 90 ? 'warning' : 'notice',
                significance: 'Maximum cadet program age'
              });
            }
          });

          // Sort by days until milestone (most urgent first), then by milestone age
          return rows.sort((a, b) => {
            if (a.daysUntil !== b.daysUntil) return a.daysUntil - b.daysUntil;
            return a.milestone - b.milestone;
          });
        };

        // QCUA (Quality Cadet Unit Award) Report Generator
        // Award cycle: 31 August to 31 August following year
        // Units with 10+ cadets that meet at least 6 of 10 criteria earn the award
        const generateQCUAReport = (membersOverride = null) => {
          const memberPool = Array.isArray(membersOverride) ? membersOverride : [...(processedData || []), ...(processedCadets || [])];
          if (!memberPool.length) return { rows: [], meta: {} };

          // Award cycle dates (configurable - currently 2025-2026 cycle)
          const cycleStartStr = '2025-08-31';
          const cycleEndStr = '2026-08-31';
          const cycleStart = new Date(cycleStartStr);
          const cycleEnd = new Date(cycleEndStr);
          const today = new Date();

          // Helper to get unit info
          const getUnitInfo = (orgId) => {
            const org = (dataFiles.organization || []).find(o => String(o.ORGID || '').trim() === String(orgId || '').trim());
            const unitNum = org && org.Unit ? org.Unit.replace(/^0+/, '').padStart(3, '0') : '';
            const unitType = String(org?.Type || '').toUpperCase();
            const region = org?.Region || '';
            const wing = org?.Wing || '';
            return { unitNum, unitType, region, wing, orgName: org?.Name || '' };
          };

          // Build unit-based groupings
          const unitMap = new Map();

          // Separate cadets and seniors
          const cadets = memberPool.filter(m => {
            const type = String(m.Type || m.TYPE || '').toUpperCase();
            return type === 'CADET';
          });
          const seniors = memberPool.filter(m => {
            const type = String(m.Type || m.TYPE || '').toUpperCase();
            return type === 'SENIOR' || type === 'LIFE';
          });

          // Group cadets by unit
          cadets.forEach(cadet => {
            const unitName = cadet.memberUnitName || 'Unknown';
            if (!unitMap.has(unitName)) {
              const unitInfo = getUnitInfo(cadet.ORGID);
              unitMap.set(unitName, {
                unitName,
                unitInfo,
                cadets: [],
                seniors: []
              });
            }
            unitMap.get(unitName).cadets.push(cadet);
          });

          // Add seniors to their units
          seniors.forEach(senior => {
            const unitName = senior.memberUnitName || 'Unknown';
            if (!unitMap.has(unitName)) {
              const unitInfo = getUnitInfo(senior.ORGID);
              unitMap.set(unitName, {
                unitName,
                unitInfo,
                cadets: [],
                seniors: []
              });
            }
            unitMap.get(unitName).seniors.push(senior);
          });

          // Calculate QCUA criteria for each unit
          const rows = [];

          unitMap.forEach((unitData, unitName) => {
            const { unitInfo } = unitData;
            const unitType = (unitInfo?.unitType || '').toUpperCase();
            const unitNum = unitInfo?.unitNum || '';

            // Skip units that are not eligible for QCUA:
            // - Senior Squadrons/Flights (no cadet program)
            // - Groups, Wings, Regions, National HQ (higher echelon)
            // - Units with charter numbers 000 or 999 (special/placeholder units)
            const isSeniorUnit = unitType.includes('SENIOR');
            const isHigherHQ = unitType.includes('GROUP') || unitType.includes('WING') ||
                               unitType.includes('REGION') || unitType.includes('NATIONAL');
            const isSpecialUnit = unitNum === '000' || unitNum === '999';

            if (isSeniorUnit || isHigherHQ || isSpecialUnit) {
              return; // Skip this unit
            }

            const unitCadets = unitData.cadets;
            const unitSeniors = unitData.seniors;
            const totalCadets = unitCadets.length;

            // Check eligibility: need 10+ cadets
            const isEligible = totalCadets >= 10;

            // 1. Cadet Achievement: 45% Wright Brothers (achievement 4+)
            const wrightBrothersCount = unitCadets.filter(c => {
              const approvedAchvs = c.approvedAchievements || [];
              const maxAchv = approvedAchvs.length > 0 ? Math.max(...approvedAchvs) : 0;
              return maxAchv >= 4;
            }).length;
            const wrightBrothersPercent = totalCadets > 0 ? Math.round((wrightBrothersCount / totalCadets) * 100) : 0;
            const wrightBrothersMet = wrightBrothersPercent >= 45;

            // 2. Encampment: 50% graduated
            const encampmentCount = unitCadets.filter(c => {
              // Check from cadet activities
              const activities = (dataFiles.cadetActivities || []).filter(a =>
                String(a.CAPID).trim() === String(c.CAPID).trim() &&
                (a.Type || '').toUpperCase().includes('ENCAMP') &&
                a.Completed && a.Completed !== '01/01/1900'
              );
              return activities.length > 0;
            }).length;
            const encampmentPercent = totalCadets > 0 ? Math.round((encampmentCount / totalCadets) * 100) : 0;
            const encampmentMet = encampmentPercent >= 50;

            // 3. Enrollment: 25+ cadets
            const enrollmentMet = totalCadets >= 25;

            // 4. Emergency Services: 60% GES certification
            const gesCount = unitCadets.filter(c => {
              const esQuals = c.esQualificationsAll || c.esQualifications || [];
              return esQuals.some(q => q.achvID === '53' && q.status === 'Active');
            }).length;
            const gesPercent = totalCadets > 0 ? Math.round((gesCount / totalCadets) * 100) : 0;
            const gesMet = gesPercent >= 60;

            // 5. Onboarding: 70% of new cadets (joined during cycle) earned Achievement 1 in 8 weeks
            const newCadets = unitCadets.filter(c => {
              if (!c.Joined) return false;
              const joinDate = parseDateSafe(c.Joined);
              return joinDate && joinDate >= cycleStart && joinDate <= cycleEnd;
            });
            const onboardingSuccessCount = newCadets.filter(c => {
              const joinDate = parseDateSafe(c.Joined);
              if (!joinDate) return false;

              // Find Achievement 1 approval date
              const achv1Approval = (dataFiles.cadetAchvAprs || []).find(a =>
                String(a.CAPID).trim() === String(c.CAPID).trim() &&
                String(a.CadetAchvID).trim() === '1' &&
                a.Status === 'APR'
              );

              if (!achv1Approval) return false;

              const achv1Date = parseDateSafe(achv1Approval.DateCreated || achv1Approval.DateMod);
              if (!achv1Date) return false;

              // Calculate weeks between join and Achievement 1
              const daysDiff = Math.floor((achv1Date - joinDate) / (1000 * 60 * 60 * 24));
              return daysDiff <= 56; // 8 weeks = 56 days
            }).length;
            const onboardingPercent = newCadets.length > 0 ? Math.round((onboardingSuccessCount / newCadets.length) * 100) : null;
            const onboardingMet = newCadets.length === 0 ? null : onboardingPercent >= 70;

            // 6. Orientation Flights: 70% first flight credit (any syllabus completed)
            const oFlights = dataFiles.oFlights || [];
            const firstFlightCount = unitCadets.filter(c => {
              const cadetFlights = oFlights.filter(f =>
                String(f.CAPID || '').trim() === String(c.CAPID).trim()
              );
              return cadetFlights.length > 0;
            }).length;
            const firstFlightPercent = totalCadets > 0 ? Math.round((firstFlightCount / totalCadets) * 100) : 0;
            const firstFlightMet = firstFlightPercent >= 70;

            // 7. TLC Graduates: 3+ current TLC senior members
            const tlcCount = unitSeniors.filter(s => {
              const tlcStatus = getTlcStatus(s);
              return tlcStatus && (tlcStatus.status === 'current' || tlcStatus.status === 'due-soon');
            }).length;
            const tlcMet = tlcCount >= 3;

            // Non-trackable criteria (always null)
            const aerospaceMet = null; // AEX/STEM Kit - not trackable
            const localActionMet = null; // Community engagement - not trackable
            const stemTeamMet = null; // STEM activities - not trackable

            // Calculate total criteria met
            const trackableCriteria = [
              wrightBrothersMet,
              encampmentMet,
              enrollmentMet,
              gesMet,
              onboardingMet,
              firstFlightMet,
              tlcMet
            ];
            const criteriaMet = trackableCriteria.filter(c => c === true).length;
            const criteriaNotMet = trackableCriteria.filter(c => c === false).length;
            const criteriaUnknown = trackableCriteria.filter(c => c === null).length + 3; // +3 for non-trackable

            // Award status
            // Need 6 of 10 criteria - with 3 non-trackable, we can confirm if:
            // - criteriaMet >= 6 -> Eligible (definitely meets requirement)
            // - criteriaMet + criteriaUnknown < 6 -> Not Eligible (can't meet requirement even with unknowns)
            // - Otherwise -> Potentially Eligible (depends on non-trackable criteria)
            let awardStatus = 'Not Eligible';
            if (!isEligible) {
              awardStatus = 'Ineligible (< 10 cadets)';
            } else if (criteriaMet >= 6) {
              awardStatus = 'On Track';
            } else if (criteriaMet + criteriaUnknown >= 6) {
              awardStatus = 'Potentially Eligible';
            } else {
              awardStatus = 'Not On Track';
            }

            rows.push({
              unitName,
              unitInfo: unitData.unitInfo,
              totalCadets,
              totalSeniors: unitSeniors.length,
              isEligible,
              awardStatus,
              criteriaMet,
              criteriaNotMet,
              criteriaUnknown,
              criteria: {
                cadetAchievement: {
                  name: 'Cadet Achievement',
                  description: '45% Wright Brothers Award',
                  count: wrightBrothersCount,
                  total: totalCadets,
                  percent: wrightBrothersPercent,
                  threshold: 45,
                  met: wrightBrothersMet,
                  trackable: true
                },
                encampment: {
                  name: 'Encampment',
                  description: '50% encampment graduates',
                  count: encampmentCount,
                  total: totalCadets,
                  percent: encampmentPercent,
                  threshold: 50,
                  met: encampmentMet,
                  trackable: true
                },
                enrollment: {
                  name: 'Enrollment',
                  description: '25+ cadets on roster',
                  count: totalCadets,
                  total: null,
                  percent: null,
                  threshold: 25,
                  met: enrollmentMet,
                  trackable: true,
                  isCountBased: true
                },
                emergencyServices: {
                  name: 'Emergency Services',
                  description: '60% GES certified',
                  count: gesCount,
                  total: totalCadets,
                  percent: gesPercent,
                  threshold: 60,
                  met: gesMet,
                  trackable: true
                },
                onboarding: {
                  name: 'Onboarding',
                  description: '70% new cadets earn Achv 1 in 8 weeks',
                  count: onboardingSuccessCount,
                  total: newCadets.length,
                  percent: onboardingPercent,
                  threshold: 70,
                  met: onboardingMet,
                  trackable: true,
                  noNewCadets: newCadets.length === 0
                },
                orientationFlights: {
                  name: 'Orientation Flights',
                  description: '70% first flight credit',
                  count: firstFlightCount,
                  total: totalCadets,
                  percent: firstFlightPercent,
                  threshold: 70,
                  met: firstFlightMet,
                  trackable: true
                },
                tlcGraduates: {
                  name: 'TLC Graduates',
                  description: '3+ TLC-qualified seniors',
                  count: tlcCount,
                  total: unitSeniors.length,
                  percent: null,
                  threshold: 3,
                  met: tlcMet,
                  trackable: true,
                  isCountBased: true
                },
                aerospace: {
                  name: 'Aerospace',
                  description: 'AEX Completion or STEM Kit',
                  count: null,
                  total: null,
                  percent: null,
                  threshold: null,
                  met: aerospaceMet,
                  trackable: false,
                  notTrackableReason: 'No data available in downloads'
                },
                localAction: {
                  name: 'Local Action',
                  description: '4 community events with 4+ cadets',
                  count: null,
                  total: null,
                  percent: null,
                  threshold: null,
                  met: localActionMet,
                  trackable: false,
                  notTrackableReason: 'No data available in downloads'
                },
                stemTeam: {
                  name: 'STEM Team',
                  description: 'Hosted qualifying STEM activity',
                  count: null,
                  total: null,
                  percent: null,
                  threshold: null,
                  met: stemTeamMet,
                  trackable: false,
                  notTrackableReason: 'No data available in downloads'
                }
              },
              cycleStart: cycleStartStr,
              cycleEnd: cycleEndStr
            });
          });

          // Sort by award status (On Track first), then by criteria met, then by unit name
          const statusOrder = { 'On Track': 0, 'Potentially Eligible': 1, 'Not On Track': 2, 'Ineligible (< 10 cadets)': 3 };
          rows.sort((a, b) => {
            const statusDiff = (statusOrder[a.awardStatus] || 99) - (statusOrder[b.awardStatus] || 99);
            if (statusDiff !== 0) return statusDiff;
            if (a.criteriaMet !== b.criteriaMet) return b.criteriaMet - a.criteriaMet;
            return a.unitName.localeCompare(b.unitName);
          });

          return {
            rows,
            meta: {
              cycleStart: cycleStartStr,
              cycleEnd: cycleEndStr,
              totalUnits: rows.length,
              eligibleUnits: rows.filter(r => r.isEligible).length,
              onTrackUnits: rows.filter(r => r.awardStatus === 'On Track').length,
              view: showAllDescendants ? 'multi-unit' : 'single-unit'
            }
          };
        };

        // =============================================
        // QUA (Quality Unit Award) REPORT GENERATOR
        // Great Lakes Region - Award cycle: Fiscal Year (1 October - 30 September)
        // Units must meet 7 of 10 criteria (3 required + 4 from mission-specific)
        // =============================================
        const generateQUAReport = (membersOverride = null) => {
          const memberPool = Array.isArray(membersOverride) ? membersOverride : [...(processedData || []), ...(processedCadets || [])];
          if (!memberPool.length) return { rows: [], meta: {} };

          // Fiscal year dates (Oct 1 - Sep 30)
          const today = new Date();
          const currentYear = today.getFullYear();
          const currentMonth = today.getMonth(); // 0-indexed (0=Jan, 9=Oct)
          // If we're in Oct-Dec, FY started this year; if Jan-Sep, FY started last year
          const fyStartYear = currentMonth >= 9 ? currentYear : currentYear - 1;
          const fyEndYear = fyStartYear + 1;
          const fyStartStr = `${fyStartYear}-10-01`;
          const fyEndStr = `${fyEndYear}-09-30`;
          const fyStart = new Date(fyStartStr);
          const fyEnd = new Date(fyEndStr);

          // Helper to get unit info
          const getUnitInfo = (orgId) => {
            const org = (dataFiles.organization || []).find(o => String(o.ORGID || '').trim() === String(orgId || '').trim());
            const unitNum = org && org.Unit ? org.Unit.replace(/^0+/, '').padStart(3, '0') : '';
            const unitType = String(org?.Type || '').toUpperCase();
            const region = org?.Region || '';
            const wing = org?.Wing || '';
            return { unitNum, unitType, region, wing, orgName: org?.Name || '', orgId: org?.ORGID };
          };

          // Determine if unit is Group, Senior Squadron/Flight, or Composite Squadron
          const getUnitCategory = (unitType) => {
            const type = (unitType || '').toUpperCase();
            // Groups
            if (type.includes('GROUP')) return 'GROUP';
            // Exclude higher HQ and cadet-only units
            if (type.includes('WING') || type.includes('REGION') || type.includes('NATIONAL')) return null;
            if (type.includes('CADET') && !type.includes('COMPOSITE')) return null; // Cadet-only squadron
            // Composite squadrons
            if (type.includes('COMPOSITE')) return 'COMPOSITE_SQUADRON';
            // Senior squadrons/flights - explicit or inferred
            // If it has 'SENIOR' in the name, it's a senior unit (squadron or flight)
            if (type.includes('SENIOR')) return 'SENIOR_SQUADRON';
            // Any remaining squadron/flight that isn't cadet-only is treated as senior
            if (type.includes('SQUADRON') || type.includes('FLIGHT')) return 'SENIOR_SQUADRON';
            return null; // Not eligible
          };

          // Build unit-based groupings - seniors only
          const unitMap = new Map();
          const seniors = memberPool.filter(m => {
            const type = String(m.Type || m.TYPE || '').toUpperCase();
            const status = String(m.MbrStatus || '').toUpperCase();
            return (type === 'SENIOR' || type === 'LIFE') && status === 'ACTIVE';
          });

          seniors.forEach(senior => {
            const unitName = senior.memberUnitName || 'Unknown';
            if (!unitMap.has(unitName)) {
              const unitInfo = getUnitInfo(senior.ORGID);
              unitMap.set(unitName, {
                unitName,
                unitInfo,
                seniors: []
              });
            }
            unitMap.get(unitName).seniors.push(senior);
          });

          // Calculate QUA criteria for each unit
          const rows = [];

          unitMap.forEach((unitData, unitName) => {
            const { unitInfo } = unitData;
            const unitType = (unitInfo?.unitType || '').toUpperCase();
            const unitNum = unitInfo?.unitNum || '';
            const unitCategory = getUnitCategory(unitType);

            // Skip units that are not eligible for QUA
            if (!unitCategory) return;
            const isSpecialUnit = unitNum === '000' || unitNum === '999';
            if (isSpecialUnit) return;

            const unitSeniors = unitData.seniors;
            const totalSeniors = unitSeniors.length;
            const pdThreshold = unitCategory === 'GROUP' ? 15 : 10;

            // ===== REQUIRED CRITERIA (All Must Be Met) =====

            // 1. Compliance & Administration - Cadet Protection Training
            // Use existing getCadetProtectionStatus function to check current status
            const cpResults = unitSeniors.map(s => {
              const cpStatus = getCadetProtectionStatus(s);
              if (!cpStatus) {
                return { member: s, status: 'unknown', reason: 'Unable to determine status', memberName: `${s.NameLast}, ${s.NameFirst}`, capid: s.CAPID, rank: s.Rank };
              }

              // Check if member has any required courses
              if (!cpStatus.requiredCourses || cpStatus.requiredCourses.length === 0) {
                // Not required for this member type
                return { member: s, status: 'exempt', reason: 'Not required', memberName: `${s.NameLast}, ${s.NameFirst}`, capid: s.CAPID, rank: s.Rank };
              }

              // Check the overall compliance status
              if (cpStatus.isCompliant) {
                return { member: s, status: 'current', reason: 'Current', memberName: `${s.NameLast}, ${s.NameFirst}`, capid: s.CAPID, rank: s.Rank };
              }

              // Find the worst status among required courses
              const worstCourse = cpStatus.requiredCourses.reduce((worst, course) => {
                const severity = { missing: 3, overdue: 2, 'due-soon': 1, current: 0 };
                return (severity[course.status] || 0) > (severity[worst.status] || 0) ? course : worst;
              }, cpStatus.requiredCourses[0]);

              return {
                member: s,
                status: worstCourse.status,
                reason: worstCourse.statusLabel || worstCourse.status,
                course: worstCourse.label,
                expiration: worstCourse.expirationDate,
                memberName: `${s.NameLast}, ${s.NameFirst}`,
                capid: s.CAPID,
                rank: s.Rank
              };
            });
            const cpCurrentCount = cpResults.filter(r => r.status === 'current' || r.status === 'exempt').length;
            const cpPercent = totalSeniors > 0 ? Math.round((cpCurrentCount / totalSeniors) * 100) : 0;
            const cpMet = cpPercent === 100;
            // Build detailed list for display
            const cpCompliantMembers = cpResults.filter(r => r.status === 'current' || r.status === 'exempt');
            const cpNonCompliantMembers = cpResults.filter(r => r.status !== 'current' && r.status !== 'exempt');

            // 2. Professional Development - New Level II-V completions during FY
            const pdResults = unitSeniors.map(s => {
              // Check seniorLevels for new level completions within FY
              const memberLevels = (dataFiles.seniorLevels || []).filter(sl =>
                String(sl.CAPID || '').trim() === String(s.CAPID).trim()
              );
              const newLevelInFY = memberLevels.find(sl => {
                const lvl = (sl.Lvl || '').toUpperCase();
                const isLevel2to5 = ['LV2', 'LV3', 'LV4', 'LV5', 'LEVEL II', 'LEVEL III', 'LEVEL IV', 'LEVEL V'].some(l => lvl.includes(l));
                if (!isLevel2to5) return false;
                const completedDate = parseDateSafe(sl.Completed);
                return completedDate && completedDate >= fyStart && completedDate <= fyEnd;
              });

              // Also check seniorAwards for level completions
              const memberAwards = (dataFiles.seniorAwards || []).filter(a =>
                String(a.CAPID || '').trim() === String(s.CAPID).trim()
              );
              const newAwardInFY = memberAwards.find(a => {
                const award = (a.Award || '').toUpperCase();
                const isLevel2to5 = ['LEVEL II', 'LEVEL III', 'LEVEL IV', 'LEVEL V', 'LV2', 'LV3', 'LV4', 'LV5'].some(l => award.includes(l));
                if (!isLevel2to5) return false;
                const completedDate = parseDateSafe(a.Completed);
                return completedDate && completedDate >= fyStart && completedDate <= fyEnd;
              });

              const levelAchieved = newLevelInFY ? (newLevelInFY.Lvl || '') : (newAwardInFY ? (newAwardInFY.Award || '') : null);
              const completionDate = newLevelInFY ? parseDateSafe(newLevelInFY.Completed) : (newAwardInFY ? parseDateSafe(newAwardInFY.Completed) : null);

              return {
                member: s,
                hasNewLevel: !!(newLevelInFY || newAwardInFY),
                levelAchieved,
                completionDate: completionDate ? completionDate.toLocaleDateString() : null,
                memberName: `${s.NameLast}, ${s.NameFirst}`,
                capid: s.CAPID,
                rank: s.Rank
              };
            });
            const pdNewLevelCount = pdResults.filter(r => r.hasNewLevel).length;
            const pdPercent = totalSeniors > 0 ? Math.round((pdNewLevelCount / totalSeniors) * 100) : 0;
            const pdMet = pdPercent >= pdThreshold;
            // Build member details
            const pdCompletedMembers = pdResults.filter(r => r.hasNewLevel);
            const pdPendingMembers = pdResults.filter(r => !r.hasNewLevel);

            // 2b. SM Promotion Check - No senior member at SM beyond 1 year without promoting
            const smPromotionResults = unitSeniors.map(s => {
              const rank = (s.Rank || '').toUpperCase().trim();
              const isSM = rank === 'SM' || rank === 'SENIOR MEMBER';
              if (!isSM) return { member: s, status: 'ok', reason: 'Not SM', memberName: `${s.NameLast}, ${s.NameFirst}`, capid: s.CAPID, rank: s.Rank };

              const joinDate = parseDateSafe(s.Joined);
              if (!joinDate) return { member: s, status: 'ok', reason: 'No join date', memberName: `${s.NameLast}, ${s.NameFirst}`, capid: s.CAPID, rank: s.Rank };

              const daysSinceJoin = Math.floor((today - joinDate) / (1000 * 60 * 60 * 24));
              if (daysSinceJoin <= 365) return { member: s, status: 'ok', reason: `SM for ${daysSinceJoin} days`, memberName: `${s.NameLast}, ${s.NameFirst}`, capid: s.CAPID, rank: s.Rank };

              // Check if they've achieved any officer or NCO rank
              const currentRankUpper = rank;

              // Check if current rank is officer (2d Lt or higher) or NCO
              const isOfficer = ['2D LT', '2ND LT', '1ST LT', 'CAPT', 'MAJ', 'LT COL', 'COL'].some(r => currentRankUpper.includes(r));
              const isNCO = QUA_NCO_RANKS.has(currentRankUpper);

              if (isOfficer || isNCO) return { member: s, status: 'ok', reason: 'Promoted', memberName: `${s.NameLast}, ${s.NameFirst}`, capid: s.CAPID, rank: s.Rank };

              return { member: s, status: 'violation', reason: `SM for ${daysSinceJoin} days (> 1 year)`, daysSinceJoin, memberName: `${s.NameLast}, ${s.NameFirst}`, capid: s.CAPID, rank: s.Rank, joinDate: joinDate.toLocaleDateString() };
            });
            const smViolationCount = smPromotionResults.filter(r => r.status === 'violation').length;
            const smPromotionMet = smViolationCount === 0;
            const smViolationMembers = smPromotionResults.filter(r => r.status === 'violation');

            // 3. Recruitment & Retention - Check org statistics if available
            let retentionMet = null;
            let retentionData = { growth: null, retention: null, currentTotal: null, startTotal: null, newMembers: null, renewals: null, attrition: null, netChange: null };
            if (orgStatsService && unitInfo.orgId) {
              const metrics = orgStatsService.getMetricsForUnit(unitInfo.orgId, {
                includeDescendants: false,
                timeRangeMonths: 12
              });
              if (metrics && metrics.metrics) {
                // Calculate growth rate percentage from net change and starting total
                const startTotal = metrics.summary?.yearAgoTotal || null;
                const currentTotal = metrics.summary?.currentTotal || null;
                const netChange = metrics.metrics?.growth?.netChangeInPeriod || null;
                let growthRate = null;
                if (startTotal !== null && startTotal > 0 && netChange !== null) {
                  growthRate = Math.round((netChange / startTotal) * 100 * 10) / 10;
                }
                // Retention rate is directly from the retention metrics
                const retentionRate = metrics.metrics?.retention?.retentionRate || null;

                retentionData = {
                  growth: growthRate,
                  retention: retentionRate,
                  currentTotal: currentTotal,
                  startTotal: startTotal,
                  newMembers: metrics.metrics?.recruiting?.totalInPeriod || null,
                  renewals: metrics.metrics?.retention?.renewalsInPeriod || null,
                  attrition: metrics.metrics?.retention?.estimatedAttrition || null,
                  netChange: netChange
                };
                // 5% growth OR 75% retention
                retentionMet = (growthRate !== null && growthRate >= 5) || (retentionRate !== null && retentionRate >= 75);
              }
            }

            // ===== MISSION-SPECIFIC CRITERIA (Choose Any 4) =====

            // 4. Emergency Services Readiness
            // 4a. 50% GES - Build member details
            const gesResults = unitSeniors.map(s => {
              const esQuals = s.esQualificationsAll || s.esQualifications || [];
              const gesQual = esQuals.find(q => q.achvID === '53' && q.status === 'Active');
              return {
                member: s,
                hasQual: !!gesQual,
                qualName: gesQual ? 'GES' : null,
                memberName: `${s.NameLast}, ${s.NameFirst}`,
                capid: s.CAPID,
                rank: s.Rank
              };
            });
            const gesCount = gesResults.filter(r => r.hasQual).length;
            const gesPercent = totalSeniors > 0 ? Math.round((gesCount / totalSeniors) * 100) : 0;
            const gesMet = gesPercent >= 50;
            const gesQualifiedMembers = gesResults.filter(r => r.hasQual);

            // 4b. 25% ICUT - Build member details
            const icutResults = unitSeniors.map(s => {
              const esQuals = s.esQualificationsAll || s.esQualifications || [];
              const icutQual = esQuals.find(q => q.achvID === '217' && q.status === 'Active');
              return {
                member: s,
                hasQual: !!icutQual,
                qualName: icutQual ? 'ICUT' : null,
                memberName: `${s.NameLast}, ${s.NameFirst}`,
                capid: s.CAPID,
                rank: s.Rank
              };
            });
            const icutCount = icutResults.filter(r => r.hasQual).length;
            const icutPercent = totalSeniors > 0 ? Math.round((icutCount / totalSeniors) * 100) : 0;
            const icutMet = icutPercent >= 25;
            const icutQualifiedMembers = icutResults.filter(r => r.hasQual);

            // 4c. 15% Operational Qualification - Build member details with specific quals
            const operationalResults = unitSeniors.map(s => {
              const esQuals = s.esQualificationsAll || s.esQualifications || [];
              const operationalQuals = esQuals.filter(q => QUA_OPERATIONAL_ES_ACHIEVEMENT_IDS.has(q.achvID) && q.status === 'Active');
              return {
                member: s,
                hasQual: operationalQuals.length > 0,
                qualifications: operationalQuals.map(q => q.name || q.achvName || `ID:${q.achvID}`),
                qualCount: operationalQuals.length,
                memberName: `${s.NameLast}, ${s.NameFirst}`,
                capid: s.CAPID,
                rank: s.Rank
              };
            });
            const operationalCount = operationalResults.filter(r => r.hasQual).length;
            const operationalPercent = totalSeniors > 0 ? Math.round((operationalCount / totalSeniors) * 100) : 0;
            const operationalMet = operationalPercent >= 15;
            const operationalQualifiedMembers = operationalResults.filter(r => r.hasQual);

            // ES Readiness overall: all three sub-criteria must be met
            const esReadinessMet = gesMet && icutMet && operationalMet;

            // 5. Command & Leadership Development
            // 5a. At least one VOLU Instructor - Count unique individuals only
            const voluInstructorResults = unitSeniors.map(s => {
              const capid = String(s.CAPID).trim();
              // Check if this member is a VOLU instructor (any course)
              const voluRecords = (dataFiles.voluInstructors || []).filter(v =>
                String(v.CAPID || '').trim() === capid
              );
              // Get unique course names they teach
              const courses = [...new Set(voluRecords.map(v => v.PathName || 'Unknown Course'))];
              return {
                member: s,
                isInstructor: voluRecords.length > 0,
                courses,
                courseCount: courses.length,
                memberName: `${s.NameLast}, ${s.NameFirst}`,
                capid: s.CAPID,
                rank: s.Rank
              };
            });
            // Count unique VOLU instructors (not duplicate records for multiple courses)
            const voluInstructorCount = voluInstructorResults.filter(r => r.isInstructor).length;
            const voluMet = voluInstructorCount >= 1;
            const voluInstructorMembers = voluInstructorResults.filter(r => r.isInstructor);

            // 5b. 25% Yeager Award
            const yeagerResults = unitSeniors.map(s => {
              const awards = s.seniorAwards || [];
              const yeagerAward = awards.find(a => (a.award || '').toUpperCase().includes(QUA_YEAGER_AWARD_NAME));
              return {
                member: s,
                hasAward: !!yeagerAward,
                awardDate: yeagerAward ? yeagerAward.date : null,
                memberName: `${s.NameLast}, ${s.NameFirst}`,
                capid: s.CAPID,
                rank: s.Rank
              };
            });
            const yeagerCount = yeagerResults.filter(r => r.hasAward).length;
            const yeagerPercent = totalSeniors > 0 ? Math.round((yeagerCount / totalSeniors) * 100) : 0;
            const yeagerMet = yeagerPercent >= 25;
            const yeagerAwardMembers = yeagerResults.filter(r => r.hasAward);

            // 5c. 25% Captain or higher
            const captainPlusResults = unitSeniors.map(s => {
              const rank = (s.Rank || '').toUpperCase().replace(/[^A-Z ]/g, '').trim();
              const isCaptainPlus = QUA_CAPTAIN_OR_HIGHER_RANKS.has(rank) ||
                     Array.from(QUA_CAPTAIN_OR_HIGHER_RANKS).some(r => rank.includes(r));
              return {
                member: s,
                isCaptainPlus,
                memberName: `${s.NameLast}, ${s.NameFirst}`,
                capid: s.CAPID,
                rank: s.Rank
              };
            });
            const captainPlusCount = captainPlusResults.filter(r => r.isCaptainPlus).length;
            const captainPlusPercent = totalSeniors > 0 ? Math.round((captainPlusCount / totalSeniors) * 100) : 0;
            const captainPlusMet = captainPlusPercent >= 25;
            const captainPlusMembers = captainPlusResults.filter(r => r.isCaptainPlus);

            // Command & Leadership overall: all three sub-criteria must be met
            const commandLeadershipMet = voluMet && yeagerMet && captainPlusMet;

            // 6. Encampment & Cadet Program Support - 15% seniors at encampment in FY
            const encampmentResults = unitSeniors.map(s => {
              const activities = (dataFiles.cadetActivities || []).filter(a =>
                String(a.CAPID || '').trim() === String(s.CAPID).trim() &&
                (a.Type || '').toUpperCase().includes('ENCAMP')
              );
              // Check if any encampment participation was within FY
              const fyActivities = activities.filter(a => {
                const actDate = parseDateSafe(a.Completed || a.StartDate || a.DateMod);
                return actDate && actDate >= fyStart && actDate <= fyEnd;
              });
              return {
                member: s,
                participated: fyActivities.length > 0,
                activityCount: fyActivities.length,
                activities: fyActivities.map(a => ({
                  type: a.Type,
                  location: a.Location,
                  date: a.Completed || a.StartDate
                })),
                memberName: `${s.NameLast}, ${s.NameFirst}`,
                capid: s.CAPID,
                rank: s.Rank
              };
            });
            const encampmentStaffCount = encampmentResults.filter(r => r.participated).length;
            const encampmentPercent = totalSeniors > 0 ? Math.round((encampmentStaffCount / totalSeniors) * 100) : 0;
            const encampmentMet = encampmentPercent >= 15;
            const encampmentParticipants = encampmentResults.filter(r => r.participated);

            // Non-trackable criteria (always null)
            const complianceAdminMet = null; // Inspections, financial submissions - not trackable
            const aeInternalMet = null; // AE internal events - not trackable
            const aeExternalMet = null; // AE external events - not trackable
            const communityEngagementMet = null; // Community/legislative outreach - not trackable
            const flyingExcellenceMet = null; // Flying unit operational excellence - not trackable
            const innovationCyberMet = null; // Cyber/comms/innovation - not trackable

            // Calculate criteria met/not met
            const requiredCriteria = [
              { key: 'cadetProtection', met: cpMet, trackable: true },
              { key: 'professionalDevelopment', met: pdMet && smPromotionMet, trackable: true },
              { key: 'retention', met: retentionMet, trackable: retentionMet !== null }
            ];
            const missionCriteria = [
              { key: 'esReadiness', met: esReadinessMet, trackable: true },
              { key: 'commandLeadership', met: commandLeadershipMet, trackable: true },
              { key: 'encampmentSupport', met: encampmentMet, trackable: true },
              { key: 'aerospaceEducation', met: null, trackable: false },
              { key: 'communityEngagement', met: null, trackable: false },
              { key: 'flyingExcellence', met: null, trackable: false },
              { key: 'innovationCyber', met: null, trackable: false }
            ];

            const allCriteria = [...requiredCriteria, ...missionCriteria];
            const criteriaMet = allCriteria.filter(c => c.met === true).length;
            const criteriaNotMet = allCriteria.filter(c => c.met === false).length;
            const criteriaUnknown = allCriteria.filter(c => c.met === null).length;

            // Required criteria check - all 3 required must be met (or unknown for retention)
            const requiredMet = requiredCriteria.filter(c => c.met === true).length;
            const requiredFailed = requiredCriteria.filter(c => c.met === false).length;
            const allRequiredMet = requiredFailed === 0 && requiredMet >= 2; // CP and PD must be met, retention can be unknown

            // Award status - need 7 of 10 total AND all required criteria met
            let awardStatus = 'Not Eligible';
            if (!allRequiredMet) {
              awardStatus = 'Required Criteria Not Met';
            } else if (criteriaMet >= 7) {
              awardStatus = 'On Track';
            } else if (criteriaMet + criteriaUnknown >= 7) {
              awardStatus = 'Potentially Eligible';
            } else {
              awardStatus = 'Not On Track';
            }

            rows.push({
              unitName,
              unitInfo: unitData.unitInfo,
              unitCategory,
              unitCategoryLabel: QUA_ELIGIBLE_UNIT_TYPES[unitCategory]?.label || unitCategory,
              totalSeniors,
              pdThreshold,
              awardStatus,
              criteriaMet,
              criteriaNotMet,
              criteriaUnknown,
              allRequiredMet,
              criteria: {
                // Required Criteria
                cadetProtection: {
                  name: 'Cadet Protection Training',
                  description: '100% current (within 1 year)',
                  shortName: 'CP',
                  count: cpCurrentCount,
                  total: totalSeniors,
                  percent: cpPercent,
                  threshold: 100,
                  met: cpMet,
                  trackable: true,
                  required: true,
                  compliantMembers: cpCompliantMembers,
                  nonCompliantMembers: cpNonCompliantMembers
                },
                professionalDevelopment: {
                  name: 'Professional Development',
                  description: `${pdThreshold}% new Level II-V`,
                  shortName: 'PD',
                  count: pdNewLevelCount,
                  total: totalSeniors,
                  percent: pdPercent,
                  threshold: pdThreshold,
                  met: pdMet && smPromotionMet,
                  trackable: true,
                  required: true,
                  completedMembers: pdCompletedMembers,
                  pendingMembers: pdPendingMembers,
                  subCriteria: {
                    newLevels: { count: pdNewLevelCount, percent: pdPercent, met: pdMet, members: pdCompletedMembers },
                    smPromotion: { violations: smViolationCount, met: smPromotionMet, members: smViolationMembers }
                  }
                },
                retention: {
                  name: 'Recruitment & Retention',
                  description: '5% growth OR 75% retention',
                  shortName: 'RET',
                  growth: retentionData.growth,
                  retention: retentionData.retention,
                  currentTotal: retentionData.currentTotal,
                  startTotal: retentionData.startTotal,
                  newMembers: retentionData.newMembers,
                  renewals: retentionData.renewals,
                  attrition: retentionData.attrition,
                  netChange: retentionData.netChange,
                  met: retentionMet,
                  trackable: retentionMet !== null,
                  required: true,
                  notTrackableReason: retentionMet === null ? 'Org statistics data not available' : null
                },
                // Mission-Specific Criteria
                esReadiness: {
                  name: 'Emergency Services Readiness',
                  description: '50% GES, 25% ICUT, 15% operational',
                  shortName: 'ES',
                  met: esReadinessMet,
                  trackable: true,
                  required: false,
                  subCriteria: {
                    ges: { count: gesCount, total: totalSeniors, percent: gesPercent, threshold: 50, met: gesMet, name: 'GES', members: gesQualifiedMembers },
                    icut: { count: icutCount, total: totalSeniors, percent: icutPercent, threshold: 25, met: icutMet, name: 'ICUT', members: icutQualifiedMembers },
                    operational: { count: operationalCount, total: totalSeniors, percent: operationalPercent, threshold: 15, met: operationalMet, name: 'Operational', members: operationalQualifiedMembers }
                  }
                },
                commandLeadership: {
                  name: 'Command & Leadership Development',
                  description: '1+ VOLU Instructor, 25% Yeager, 25% Capt+',
                  shortName: 'CMD',
                  met: commandLeadershipMet,
                  trackable: true,
                  required: false,
                  subCriteria: {
                    volu: { count: voluInstructorCount, threshold: 1, met: voluMet, name: 'VOLU Instructor', members: voluInstructorMembers },
                    yeager: { count: yeagerCount, total: totalSeniors, percent: yeagerPercent, threshold: 25, met: yeagerMet, name: 'Yeager Award', members: yeagerAwardMembers },
                    captainPlus: { count: captainPlusCount, total: totalSeniors, percent: captainPlusPercent, threshold: 25, met: captainPlusMet, name: 'Captain+', members: captainPlusMembers }
                  }
                },
                encampmentSupport: {
                  name: 'Encampment Support',
                  description: '15% seniors at encampment',
                  shortName: 'ENC',
                  count: encampmentStaffCount,
                  total: totalSeniors,
                  percent: encampmentPercent,
                  threshold: 15,
                  met: encampmentMet,
                  trackable: true,
                  required: false,
                  members: encampmentParticipants
                },
                aerospaceEducation: {
                  name: 'Aerospace Education',
                  description: 'Internal and external AE events',
                  shortName: 'AE',
                  met: null,
                  trackable: false,
                  required: false,
                  notTrackableReason: 'AE event data not available in downloads'
                },
                communityEngagement: {
                  name: 'Community Engagement',
                  description: 'Community or legislative outreach',
                  shortName: 'COM',
                  met: null,
                  trackable: false,
                  required: false,
                  notTrackableReason: 'Community event data not available in downloads'
                },
                flyingExcellence: {
                  name: 'Flying Unit Excellence',
                  description: 'Pilot currency or flight hours',
                  shortName: 'FLY',
                  met: null,
                  trackable: false,
                  required: false,
                  notTrackableReason: 'Flying metrics not available in downloads'
                },
                innovationCyber: {
                  name: 'Innovation & Cyber',
                  description: 'Cyber, comms, or innovation initiative',
                  shortName: 'CYB',
                  met: null,
                  trackable: false,
                  required: false,
                  notTrackableReason: 'Innovation/cyber data not available in downloads'
                }
              },
              fyStart: fyStartStr,
              fyEnd: fyEndStr
            });
          });

          // Sort by award status, then criteria met, then unit name
          const statusOrder = { 'On Track': 0, 'Potentially Eligible': 1, 'Not On Track': 2, 'Required Criteria Not Met': 3, 'Not Eligible': 4 };
          rows.sort((a, b) => {
            const statusDiff = (statusOrder[a.awardStatus] || 99) - (statusOrder[b.awardStatus] || 99);
            if (statusDiff !== 0) return statusDiff;
            if (a.criteriaMet !== b.criteriaMet) return b.criteriaMet - a.criteriaMet;
            return a.unitName.localeCompare(b.unitName);
          });

          return {
            rows,
            meta: {
              fyStart: fyStartStr,
              fyEnd: fyEndStr,
              fyLabel: `FY${fyEndYear}`,
              totalUnits: rows.length,
              onTrackUnits: rows.filter(r => r.awardStatus === 'On Track').length,
              potentialUnits: rows.filter(r => r.awardStatus === 'Potentially Eligible').length,
              view: showAllDescendants ? 'multi-unit' : 'single-unit'
            }
          };
        };

        // =============================================
        // RECRUITING TRENDS REPORT GENERATOR
        // =============================================
        const generateRecruitingTrendsReport = (membersOverride = null, options = {}) => {
          // This report uses orgStatsService, not member data
          if (!orgStatsService || !unitFilter) {
            return { rows: [], meta: { error: 'Org statistics data not available' } };
          }

          const timeRange = options.timeRange || 12;
          const descendantIds = showAllDescendants ? getDescendantOrgIds(unitFilter) : [];

          // Get metrics from the service
          const metrics = orgStatsService.getMetricsForUnit(unitFilter, {
            includeDescendants: showAllDescendants,
            descendantOrgIds: descendantIds,
            timeRangeMonths: timeRange
          });

          if (!metrics || !metrics.monthlyData || metrics.monthlyData.length === 0) {
            return { rows: [], meta: { error: 'No data available for selected unit' } };
          }

          // Build monthly breakdown rows
          const rows = metrics.monthlyData.map(m => ({
            month: m.label,
            date: m.date,
            newSenior: m.senior?.new || 0,
            newCadet: m.cadet?.new || 0,
            rejoinSenior: m.senior?.rejoin || 0,
            rejoinCadet: m.cadet?.rejoin || 0,
            totalNew: (m.combined?.new || 0),
            totalRejoin: (m.combined?.rejoin || 0),
            totalRecruited: (m.combined?.new || 0) + (m.combined?.rejoin || 0),
            totalMembers: m.combined?.total || 0
          })).reverse(); // Most recent first

          // Calculate seasonality if available
          const seasonality = metrics.metrics.seasonality;

          // Calculate year-over-year for same months if we have enough data
          const yoyData = [];
          if (metrics.monthlyData.length >= 12) {
            const recentMonths = metrics.monthlyData.slice(-12);
            recentMonths.forEach((m, idx) => {
              const monthIndex = m.dateObj?.getMonth();
              const priorYearMonth = metrics.monthlyData.find(pm => {
                if (!pm.dateObj) return false;
                const pmMonth = pm.dateObj.getMonth();
                const pmYear = pm.dateObj.getFullYear();
                const mYear = m.dateObj.getFullYear();
                return pmMonth === monthIndex && pmYear === mYear - 1;
              });

              if (priorYearMonth) {
                const current = (m.combined?.new || 0) + (m.combined?.rejoin || 0);
                const prior = (priorYearMonth.combined?.new || 0) + (priorYearMonth.combined?.rejoin || 0);
                yoyData.push({
                  month: m.label,
                  current,
                  prior,
                  change: current - prior
                });
              }
            });
          }

          // Get subordinate unit breakdown for aggregate view
          let unitBreakdown = [];
          if (showAllDescendants && descendantIds.length > 0) {
            const unitMetrics = orgStatsService.getMetricsForMultipleUnits(descendantIds, {
              timeRangeMonths: timeRange
            });

            unitBreakdown = unitMetrics.map(u => {
              const org = (dataFiles.organization || []).find(o =>
                String(o.ORGID || '').trim() === String(u.orgId || '').trim()
              );
              const unitNum = org?.Unit ? org.Unit.replace(/^0+/, '').padStart(3, '0') : '000';
              const unitName = `${org?.Region || ''}-${org?.Wing || ''}-${unitNum}`;

              return {
                orgId: u.orgId,
                unitName,
                recruitingRate: u.recruitingRate,
                currentTotal: u.currentTotal
              };
            }).sort((a, b) => (b.recruitingRate || 0) - (a.recruitingRate || 0));
          }

          return {
            rows,
            meta: {
              timeRange,
              totalRecruited: metrics.metrics.recruiting?.totalInPeriod || 0,
              monthlyAverage: metrics.metrics.recruiting?.monthlyAverage || 0,
              trend: metrics.metrics.recruiting?.trend || 'stable',
              trendPercent: metrics.metrics.recruiting?.trendPercent || 0,
              seniorTotal: rows.reduce((sum, r) => sum + r.newSenior + r.rejoinSenior, 0),
              cadetTotal: rows.reduce((sum, r) => sum + r.newCadet + r.rejoinCadet, 0),
              newTotal: rows.reduce((sum, r) => sum + r.totalNew, 0),
              rejoinTotal: rows.reduce((sum, r) => sum + r.totalRejoin, 0),
              seasonality: seasonality ? {
                peakMonths: seasonality.peakMonths,
                lowMonths: seasonality.lowMonths,
                patterns: seasonality.patterns
              } : null,
              yoyData,
              unitBreakdown,
              isAggregate: showAllDescendants,
              dataPoints: metrics.summary.dataPointCount
            }
          };
        };

        // =============================================
        // RETENTION ANALYSIS REPORT GENERATOR
        // =============================================
        const generateRetentionAnalysisReport = (membersOverride = null, options = {}) => {
          // This report uses both orgStatsService and member data
          if (!orgStatsService || !unitFilter) {
            return { rows: [], meta: { error: 'Org statistics data not available' } };
          }

          const timeRange = options.timeRange || 12;
          const descendantIds = showAllDescendants ? getDescendantOrgIds(unitFilter) : [];

          // Get metrics from the service
          const metrics = orgStatsService.getMetricsForUnit(unitFilter, {
            includeDescendants: showAllDescendants,
            descendantOrgIds: descendantIds,
            timeRangeMonths: timeRange
          });

          if (!metrics) {
            return { rows: [], meta: { error: 'No data available for selected unit' } };
          }

          // Build members expiring soon list from actual member data
          const memberPool = [...(processedData || []), ...(processedCadets || cadetData || [])];
          const today = new Date();
          const membersExpiringSoon = [];

          memberPool.forEach(member => {
            if (!member.Expiration || member.Expiration === '12/31/9998' || member.Expiration === '12/31/9999') return;

            const expirationDate = new Date(member.Expiration);
            const daysUntilExpiration = Math.floor((expirationDate - today) / (1000 * 60 * 60 * 24));

            // Include members expiring in next 90 days
            if (daysUntilExpiration >= 0 && daysUntilExpiration <= 90) {
              const memberType = (member.Type || member.TYPE || '').toUpperCase();
              membersExpiringSoon.push({
                capid: member.CAPID,
                memberName: `${member.NameLast}, ${member.NameFirst}`,
                rank: member.Rank || '',
                unit: member.memberUnitName || '',
                memberType: memberType === 'CADET' ? 'Cadet' : 'Senior',
                expiration: member.Expiration,
                expirationDate,
                daysUntil: daysUntilExpiration,
                urgency: daysUntilExpiration <= 30 ? 'critical' :
                         daysUntilExpiration <= 60 ? 'warning' : 'notice'
              });
            }
          });

          // Sort by expiration date (soonest first)
          membersExpiringSoon.sort((a, b) => a.daysUntil - b.daysUntil);

          // Monthly retention trend
          const monthlyTrend = (metrics.monthlyData || []).map(m => ({
            month: m.label,
            renewals: m.combined?.renew || 0,
            total: m.combined?.total || 0
          })).reverse();

          // Get subordinate unit breakdown for aggregate view
          let unitBreakdown = [];
          if (showAllDescendants && descendantIds.length > 0) {
            const unitMetrics = orgStatsService.getMetricsForMultipleUnits(descendantIds, {
              timeRangeMonths: timeRange
            });

            unitBreakdown = unitMetrics.map(u => {
              const org = (dataFiles.organization || []).find(o =>
                String(o.ORGID || '').trim() === String(u.orgId || '').trim()
              );
              const unitNum = org?.Unit ? org.Unit.replace(/^0+/, '').padStart(3, '0') : '000';
              const unitName = `${org?.Region || ''}-${org?.Wing || ''}-${unitNum}`;

              return {
                orgId: u.orgId,
                unitName,
                retentionRate: u.retentionRate,
                currentTotal: u.currentTotal,
                growthStatus: u.growthStatus
              };
            }).sort((a, b) => (b.retentionRate || 0) - (a.retentionRate || 0));
          }

          const retention = metrics.metrics.retention || {};
          const growth = metrics.metrics.growth || {};

          return {
            rows: membersExpiringSoon,
            meta: {
              timeRange,
              retentionRate: retention.retentionRate,
              healthIndicator: retention.healthIndicator || 'unknown',
              renewalsInPeriod: retention.renewalsInPeriod || 0,
              estimatedAttrition: retention.estimatedAttrition || 0,
              annualizedAttritionRate: retention.annualizedAttritionRate,
              netChange: growth.netChangeInPeriod || 0,
              growthStatus: growth.status || 'unknown',
              currentTotal: metrics.summary?.currentTotal || 0,
              memberBreakdown: metrics.summary?.memberBreakdown || null,
              monthlyTrend,
              unitBreakdown,
              isAggregate: showAllDescendants,
              expiringIn30Days: membersExpiringSoon.filter(m => m.daysUntil <= 30).length,
              expiringIn60Days: membersExpiringSoon.filter(m => m.daysUntil <= 60).length,
              expiringIn90Days: membersExpiringSoon.length
            }
          };
        };

        const normalizeReportTag = (tag) => (tag || "").toLowerCase();
        const formatReportTagLabel = (tag) => (tag || "").split(" ").map(part => part.charAt(0).toUpperCase() + part.slice(1)).join(" ");

        const reportTagClasses = {
          senior: "bg-blue-100 text-blue-800 border border-blue-200",
          cadet: "bg-sky-100 text-sky-800 border border-sky-200",
          "education & training": "bg-indigo-100 text-indigo-800 border border-indigo-200",
          "duty assignment": "bg-amber-100 text-amber-800 border border-amber-200",
          "specialty track": "bg-violet-100 text-violet-800 border border-violet-200",
          readiness: "bg-emerald-100 text-emerald-800 border border-emerald-200",
          compliance: "bg-slate-100 text-slate-800 border border-slate-200",
          membership: "bg-rose-100 text-rose-800 border border-rose-200",
          achievements: "bg-purple-100 text-purple-800 border border-purple-200",
          activities: "bg-teal-100 text-teal-800 border border-teal-200",
          recruiting: "bg-green-100 text-green-800 border border-green-200",
          retention: "bg-orange-100 text-orange-800 border border-orange-200",
          analytics: "bg-cyan-100 text-cyan-800 border border-cyan-200"
        };

        const getMembersForReport = (tags = []) => {
          const normalizedTags = (tags || []).map(normalizeReportTag);

          // Use the appropriate data source based on report tags
          let pool;
          if (normalizedTags.includes("cadet") && normalizedTags.includes("senior")) {
            // For reports with both cadet and senior tags, combine both pools
            pool = [...(processedData || []), ...(processedCadets || cadetData || [])];
          } else if (normalizedTags.includes("cadet")) {
            // For cadet-only reports, use processedCadets which has all cadet data
            pool = processedCadets || cadetData || [];
          } else if (normalizedTags.includes("senior")) {
            // For senior-only reports, use processedData which has senior members
            pool = processedData || [];
          } else {
            // For mixed or untagged reports, combine both pools
            pool = [...(processedData || []), ...(processedCadets || cadetData || [])];
          }

          return pool;
        };

        const reportCatalog = [
          {
            id: 'training',
            title: 'Most Needed Training',
            description: 'Moderated ET modules only  what VU instructors should teach next',
            icon: 'GraduationCap',
            accent: 'blue',
            tags: ['senior', 'education & training', 'readiness'],
            generate: (members) => generateMostNeededTraining(members)
          },
          {
            id: 'discrepancies',
            title: 'Track/Duty Discrepancies',
            description: 'Find members with duty assignments but missing required specialty tracks',
            icon: 'AlertTriangle',
            accent: 'amber',
            tags: ['senior', 'duty assignment', 'specialty track', 'compliance'],
            generate: (members) => generateDiscrepanciesReport(members)
          },
          {
            id: 'approval',
            title: 'Levels Needing Approval',
            description: 'Members who have completed all modules and need submission/approval for ET levels',
            icon: 'Stamp',
            accent: 'green',
            tags: ['senior', 'education & training', 'readiness'],
            generate: (members) => generateApprovalNeededReport(members)
          },
          {
            id: 'promotion',
            title: 'Promotion Eligibility',
            description: 'Senior members eligible for promotion based on TIG, education level, and duty requirements',
            icon: 'TrendingUp',
            accent: 'blue',
            tags: ['senior', 'readiness'],
            generate: (members) => generatePromotionEligibilityReport(members)
          },
          {
            id: 'near-promotion',
            title: 'Near Promotion',
            description: 'Members close to promotion eligibility - within 6 months of TIG, 5 or fewer tasks remaining, or approaching duty requirements',
            icon: 'Target',
            accent: 'amber',
            tags: ['senior', 'readiness', 'education & training'],
            generate: (members) => generateNearPromotionReport(members)
          },
          {
            id: 'cadet-no-promotion',
            title: 'Cadets - No Promotion in 120 Days',
            description: 'Cadets who have not been promoted in the last 120 days',
            icon: 'AlertCircle',
            accent: 'amber',
            tags: ['cadet', 'achievements', 'readiness'],
            generate: (members) => generateCadetNoPromotionReport(members)
          },
          {
            id: 'membership-lapse',
            title: 'Membership Expiring Soon',
            description: 'All members (seniors and cadets) whose membership will lapse in 90 days or less',
            icon: 'Clock',
            accent: 'amber',
            tags: ['cadet', 'senior', 'membership', 'compliance'],
            generate: (members) => generateMembershipLapseReport(members)
          },
            {
              id: 'cadet-protection',
              title: 'Cadet Protection Training',
              description: 'Seniors and cadets who are overdue or due soon on Cadet Protection training',
              icon: 'Shield',
              accent: 'amber',
              tags: ['cadet', 'senior', 'compliance', 'education & training'],
              generate: (members) => generateCadetProtectionReport(members)
            },
            {
              id: 'tlc-compliance',
              title: 'TLC Compliance',
              description: 'Training Leaders of Cadets status for senior members (unit summary when sub-units are included)',
              icon: 'ShieldCheck',
              accent: 'blue',
              tags: ['senior', 'education & training', 'compliance'],
              generate: (members) => generateTlcComplianceReport(members)
            },
            {
              id: 'aerospace-education',
              title: 'Aerospace Education Completion',
            description: 'All cadets showing detailed completion of the 7 Aerospace Dimensions modules - includes which achievement each module was for, completion type (interactive/test/both), and honor credit status',
            icon: 'BookOpen',
            accent: 'blue',
            tags: ['cadet', 'achievements', 'education & training'],
            generate: (members) => generateAerospaceEducationReport(members)
          },
          {
            id: 'encampment-status',
            title: 'Encampment Completion Status',
            description: 'All cadets in unit showing whether they have completed an encampment',
            icon: 'Tent',
            accent: 'blue',
            tags: ['cadet', 'activities', 'readiness'],
            generate: (members) => generateEncampmentReport(members)
          },
          {
            id: 'oflight-status',
            title: 'Orientation Flights Status',
            description: 'Powered O-Flight syllabus completion for all cadets - highlights cadets who have not had any O-Flights',
            icon: 'Plane',
            accent: 'blue',
            tags: ['cadet', 'activities', 'readiness'],
            generate: (members) => generateOFlightReport(members)
          },
          {
            id: 'recent-promotions',
            title: 'Cadets - Recent Promotions',
            description: 'Cadets who have been promoted in the past 30 or 60 days',
            icon: 'TrendingUp',
            accent: 'blue',
            tags: ['cadet', 'achievements', 'readiness'],
            generate: (members) => generateRecentPromotionsReport(members)
          },
          {
            id: 'promotion-requirements',
            title: 'Cadet Promotion Requirements',
            description: 'Full table of cadet promotion requirements for the unit showing current and next achievements',
            icon: 'List',
            accent: 'blue',
            tags: ['cadet', 'achievements', 'readiness'],
            generate: (members) => generatePromotionRequirementsReport(members)
          },
          {
            id: 'approaching-age-milestone',
            title: 'Cadets - Approaching Age 18 or 21',
            description: 'Cadets who will turn 18 or 21 within the next 6 months - plan for transitions and age-outs',
            icon: 'Calendar',
            accent: 'amber',
            tags: ['cadet', 'membership', 'readiness'],
            generate: (members) => generateApproachingAgeMilestoneReport(members)
          },
          {
            id: 'qcua',
            title: 'Quality Cadet Unit Award (QCUA)',
            description: 'Track unit progress toward the 10 QCUA criteria - 7 trackable, 3 require manual verification',
            icon: 'Award',
            accent: 'blue',
            tags: ['cadet', 'senior', 'readiness', 'compliance'],
            generate: (members) => generateQCUAReport(members)
          },
          {
            id: 'qua',
            title: 'Quality Unit Award (QUA)',
            description: 'Great Lakes Region award for Groups and Senior/Composite Squadrons - 7 of 10 criteria required (FY Oct-Sep)',
            icon: 'Award',
            accent: 'emerald',
            tags: ['senior', 'readiness', 'compliance', 'leadership'],
            generate: (members) => generateQUAReport(members)
          },
          {
            id: 'recruiting-trends',
            title: 'Recruiting Trends Analysis',
            description: 'Monthly recruiting patterns, seasonal trends, and year-over-year comparison of new member acquisition',
            icon: 'UserPlus',
            accent: 'blue',
            tags: ['senior', 'cadet', 'membership', 'recruiting', 'analytics'],
            generate: (members, options) => generateRecruitingTrendsReport(members, options)
          },
          {
            id: 'retention-analysis',
            title: 'Retention & Renewal Analysis',
            description: 'Renewal rates, attrition patterns, and members approaching membership expiration',
            icon: 'RefreshCw',
            accent: 'amber',
            tags: ['senior', 'cadet', 'membership', 'retention', 'analytics'],
            generate: (members, options) => generateRetentionAnalysisReport(members, options)
          }
        ];

        const availableReportTags = useMemo(() => {
          const tags = new Set();
          reportCatalog.forEach(def => def.tags.forEach(tag => tags.add(tag)));
          return Array.from(tags).sort((a, b) => a.localeCompare(b));
        }, []);

        const toggleReportTag = (tag) => {
          setReportTagFilter(prev => prev.includes(tag) ? prev.filter(t => t !== tag) : [...prev, tag]);
        };

          const filteredReports = !reportTagFilter.length
            ? reportCatalog
            : reportCatalog.filter(def =>
                reportTagFilter.every(tag => def.tags.map(normalizeReportTag).includes(normalizeReportTag(tag)))
              );

          const buildReportPayload = (reportDef, result) => {
            if (result && !Array.isArray(result) && Array.isArray(result.rows)) {
              return {
                ...reportDef,
                type: reportDef.id,
                data: result.rows,
                meta: result.meta || {}
              };
            }
            return {
              ...reportDef,
              type: reportDef.id,
              data: Array.isArray(result) ? result : []
            };
          };

          const handleGenerateReport = (reportDef, options = {}) => {
            const scopedMembers = getMembersForReport(reportDef.tags);
            const result = reportDef.generate(scopedMembers, options);
            const reportPayload = buildReportPayload(reportDef, result);
            // Store the options used to generate this report for regeneration
            reportPayload.options = options;
            setSelectedTaskMembers(null);
            setSelectedReport(reportPayload);
            setReportsCollapsed(true);
            const output = document.getElementById('report-output');
            if (output) {
              output.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
          };

          const handleRegenerateReport = (newOptions = {}) => {
            if (!selectedReport) return;
            // Find the report definition by type/id
            const reportDef = reportCatalog.find(r => r.id === selectedReport.type);
            if (!reportDef) return;
            // Merge existing options with new options
            const mergedOptions = { ...(selectedReport.options || {}), ...newOptions };
            handleGenerateReport(reportDef, mergedOptions);
        };

        useEffect(() => {
          if (!dataFiles.members.length || !unitFilter) {
            setOrgChartData(null);
            return;
          }

          const getMemberByCapid = (capid) => dataFiles.members.find(m => String(m.CAPID).trim() === String(capid).trim());
          
          const buildOrgChart = () => {
            let validOrgIds = unitFilter ? [unitFilter] : [];
            if (showAllDescendants && unitFilter) {
              const scopeIds = getDescendantOrgIds(unitFilter);
              validOrgIds = Array.isArray(scopeIds) ? scopeIds : validOrgIds;
            }
            
            const unitMembers = dataFiles.members.filter(m => validOrgIds.includes(m.ORGID));
            const unitOrg = dataFiles.organization.find(o => o.ORGID === unitFilter);
            const isComposite = unitOrg && unitOrg.Type && unitOrg.Type.toUpperCase().includes('COMPOSITE');
            const isCadetOnly = unitOrg && unitOrg.Type && unitOrg.Type.toUpperCase().includes('CADET');
            const isWing = unitOrg && unitOrg.Type && unitOrg.Type.toUpperCase().includes('WING');
            const isGroup = unitOrg && unitOrg.Type && unitOrg.Type.toUpperCase().includes('GROUP');

            // In command-chain view at Wing/Group level, always pull duty data for all descendant units
            const dutyOrgIds = (() => {
              if (showCommandChainOnly && (isWing || isGroup)) {
                const scope = getDescendantOrgIds(unitFilter);
                return Array.isArray(scope) ? scope : validOrgIds;
              }
              return validOrgIds;
            })();
            
            const orgStructure = {
              id: 'root',
              title: 'Commander',
              type: 'senior',
              members: [],
              children: []
            };
            // Build Cadet Advisory Council node helper (Wing/Group) using cadet duty titles, fallback to committees
            const buildCouncilNode = (keyword, nodeId, title, parentOrgIds, type = 'cadet', dutiesSource = null) => {
              const orgIds = Array.isArray(parentOrgIds) ? parentOrgIds : [];
              const keyUpper = keyword.toUpperCase();
              const chair = [];
              const vice = [];
              const recorder = [];
              const reps = [];

              const addFromCadetDuty = () => {
                const source = dutiesSource || allCadetDuties;
                if (!source) return;
                source
                  .filter(d => orgIds.includes(d.ORGID) && ((d.Duty || '').toUpperCase().includes(keyUpper)))
                  .forEach(d => {
                    const mem = getMemberByCapid(d.CAPID);
                    if (!mem) return;
                    const display = `${mem.Rank} ${mem.NameLast}, ${mem.NameFirst}||${mem.CAPID}`;
                    const dutyUpper = (d.Duty || '').toUpperCase();
                    if (dutyUpper.includes('VICE')) vice.push(display);
                    else if (dutyUpper.includes('RECORDER')) recorder.push(display);
                    else if (dutyUpper.includes('CHAIR')) chair.push(display);
                    else reps.push(display);
                  });
              };

              const addFromCommittees = () => {
                if (!dataFiles.committees || dataFiles.committees.length === 0) return;
                dataFiles.committees
                  .filter(c => orgIds.includes(c.ORGID) && (c.Committee || '').toUpperCase().includes(keyUpper))
                  .forEach(c => {
                    const mem = getMemberByCapid(c.CAPID);
                    if (!mem) return;
                    const display = `${mem.Rank} ${mem.NameLast}, ${mem.NameFirst}||${mem.CAPID}`;
                    const pos = ((c.Position || c.Role || c.Title || '') + '').toUpperCase();
                    if (c.Chair === "1" || pos.includes('CHAIR')) chair.push(display);
                    else if (pos.includes('VICE')) vice.push(display);
                    else if (pos.includes('RECORDER')) recorder.push(display);
                    else reps.push(display);
                  });
              };

              addFromCadetDuty();
              if (!chair.length && !vice.length && !recorder.length && !reps.length) addFromCommittees();

              const children = [];
              // Show vice/recorder/reps if they have members, or if hideVacant is false, or if there are reps (to show hierarchy)
              if (vice.length > 0 || (!hideVacant && chair.length > 0) || reps.length > 0) {
                children.push({ id: `${nodeId}_vice`, title: 'Vice Chair', type, members: vice, children: [] });
              }
              if (recorder.length > 0 || (!hideVacant && chair.length > 0) || reps.length > 0) {
                children.push({ id: `${nodeId}_rec`, title: 'Recorder', type, members: recorder, children: [] });
              }
              if (reps.length > 0 || !hideVacant) {
                children.push({ id: `${nodeId}_members`, title: 'Representatives', type, members: reps, children: [] });
              }

              const hasAny = chair.length || vice.length || recorder.length || reps.length;
              if (!hasAny && hideVacant) return null;

              return { id: nodeId, title, type, members: chair, children };
            };
            
            // Helper function to get direct squadrons only (excludes Groups)
            const getDirectSquadronOrgIds = (parentOrgId) => {
              const parent = String(parentOrgId).trim();
              const directChildren = unitChildrenMap.get(parent) || [];

              // Filter to only include squadrons (not Groups)
              const squadrons = directChildren.filter(childId => {
                const childOrg = dataFiles.organization.find(o => String(o.ORGID).trim() === childId);
                if (!childOrg) return false;
                const childType = (childOrg.Type || '').toUpperCase();
                // Exclude Groups - only include squadrons
                return !childType.includes('GROUP');
              });

              return [parent, ...squadrons];
            };

            // CAC scope always uses all descendants so reps/alternates show even without Sub-Units toggle
            const councilOrgIdsRaw = getDescendantOrgIds(unitFilter);
            const councilOrgIds = Array.isArray(councilOrgIdsRaw)
              ? councilOrgIdsRaw
              : (unitFilter ? [unitFilter] : []);

            // Wing CAC should only include Wing + direct squadrons (not Groups or their subordinates)
            const wingCouncilOrgIds = isWing ? getDirectSquadronOrgIds(unitFilter) : [];

            // Get duty assignments - FIXED: Use cadet duty file
            const allDuties = dataFiles.duty.filter(d => dutyOrgIds.includes(d.ORGID));
            const allCadetDuties = dataFiles.cadetDuty
              ? dataFiles.cadetDuty
                  .filter(d => dutyOrgIds.includes(d.ORGID))
                  .filter(d => d.Duty && !d.Duty.toUpperCase().includes('#REF'))
              : [];
            const councilCadetDuties = dataFiles.cadetDuty
              ? dataFiles.cadetDuty
                  .filter(d => councilOrgIds.includes(d.ORGID))
                  .filter(d => d.Duty && !d.Duty.toUpperCase().includes('#REF'))
              : [];
            const wingCouncilCadetDuties = dataFiles.cadetDuty
              ? dataFiles.cadetDuty
                  .filter(d => wingCouncilOrgIds.includes(d.ORGID))
                  .filter(d => d.Duty && !d.Duty.toUpperCase().includes('#REF'))
              : [];
            
            // Helper function with assistant marking
            const findMembersByTitles = (titles = [], options = {}) => {
              const { excludeWords = [], useCadetData = false, orgFilter = null } = options;
              const dataSource = useCadetData ? allCadetDuties : allDuties;
              const upperTitles = titles.map(t => t.toUpperCase());
              const upperExclude = excludeWords.map(e => e.toUpperCase());
              return dataSource
                .filter(d => {
                  const dutyUpper = (d.Duty || "").toUpperCase();
                  if (orgFilter && !orgFilter.includes(String(d.ORGID).trim())) return false;
                  const matches = upperTitles.some(t => dutyUpper.includes(t));
                  const excluded = upperExclude.some(word => dutyUpper.includes(word));
                  return matches && !excluded;
                })
                .map(d => {
                  const mem = getMemberByCapid(d.CAPID);
                  if (!mem) return null;
                  const asst = d.Asst === "1" ? " (A)" : "";
                  return `${mem.Rank} ${mem.NameLast}, ${mem.NameFirst}${asst}||${mem.CAPID}`;
                })
                .filter(Boolean);
            };
            const findMembersByDuty = (title, excludeWords = [], useCadetData = false) =>
              findMembersByTitles([title], { excludeWords, useCadetData });
            const findMembersByTitlesForOrgs = (titles = [], orgIds = []) =>
              findMembersByTitles(titles, { orgFilter: orgIds });
            
            // FIXED: Commander only - exclude deputies/advisors and scope strictly to the current unit
            const commanderExclude = ['DEPUTY', 'CADET', 'VICE', 'ADVISOR'];
            const commanderOnly = dataFiles.duty
              .filter(d => String(d.ORGID).trim() === String(unitFilter).trim())
              .filter(d => {
                const dutyUpper = (d.Duty || '').toUpperCase();
                if (!dutyUpper.includes('COMMANDER')) return false;
                return !commanderExclude.some(w => dutyUpper.includes(w));
              })
              .map(d => {
                const mem = getMemberByCapid(d.CAPID);
                if (!mem) return null;
                const asst = d.Asst === "1" ? " (A)" : "";
                return `${mem.Rank} ${mem.NameLast}, ${mem.NameFirst}${asst}||${mem.CAPID}`;
              })
              .filter(Boolean);
            orgStructure.members = commanderOnly;
            
            const stripAssistantMarker = (member = '') => member.replace(' (A)||', '||').replace(' (A)', '');
            const deputyCommanderMembers = findMembersByTitles(['DEPUTY COMMANDER'], { excludeWords: ['FOR SENIORS', 'FOR CADETS'] });
            const wingDeputyOpsMembers = deputyCommanderMembers.filter(m => !m.includes('(A)')).map(stripAssistantMarker);
            const wingDeputySupportMembers = deputyCommanderMembers.filter(m => m.includes('(A)')).map(stripAssistantMarker);

            const deputyNode = { 
              id: 'deputy', 
              title: 'Deputy Commander', 
              type: 'senior', 
              members: deputyCommanderMembers, 
              children: [] 
            };
            
            const deputyOpsNode = {
              id: 'deputy_ops',
              title: 'Deputy Commander for Operations',
              type: 'senior',
              members: wingDeputyOpsMembers,
              children: []
            };
            
            const deputySupportNode = {
              id: 'deputy_support',
              title: 'Deputy Commander for Support',
              type: 'senior',
              members: wingDeputySupportMembers,
              children: []
            };
            
            const deputySeniorNode = { 
              id: 'cds', 
              title: 'Deputy Commander for Seniors', 
              type: 'senior', 
              members: findMembersByTitles(['DEPUTY COMMANDER FOR SENIORS']), 
              children: [] 
            };
            
            const deputyCadetNode = {
              id: 'cdc',
              title: 'Deputy Commander for Cadets',
              type: 'senior',
              members: findMembersByTitles(['DEPUTY COMMANDER FOR CADETS']),
              children: []
            };

            // Wing-specific positions
            const communicationsNode = { id: 'comm', title: 'Communications', type: 'senior', members: findMembersByTitles(['DIRECTOR OF COMMUNICATIONS','COMMUNICATIONS OFFICER','COMMUNICATIONS ENGINEERING OFFICER','COMMUNICATIONS LICENSING OFFICER','COMMUNICATIONS TRAINING OFFICER','CIS OFFICER']) };
            // Chief of Staff oversees: Admin, Personnel, Historian, Health Services, IT, Logistics, PA, Plans & Programs, Recruiting, Chaplain
            const plansProgramsNode = { id: 'plans', title: 'Plans and Programs', type: 'senior', members: findMembersByTitles(['PLANS AND PROGRAMS OFFICER']) };
            const chiefOfStaffStaff = [
              { id: 'admin', title: 'Administration', type: 'senior', members: findMembersByTitles(['DIRECTOR OF ADMINISTRATION','ADMINISTRATIVE OFFICER'], { excludeWords: ['CADET'] }) },
              { id: 'personnel', title: 'Personnel', type: 'senior', members: findMembersByTitles(['PERSONNEL OFFICER']) },
              plansProgramsNode,
              { id: 'historian', title: 'Historian', type: 'senior', members: findMembersByTitles(['HISTORIAN']) },
              { id: 'health', title: 'Health Services', type: 'senior', members: findMembersByTitles(['HEALTH SERVICES OFFICER']) },
              { id: 'it', title: 'Information Technology', type: 'senior', members: findMembersByTitles(['DIRECTOR OF IT','INFORMATION TECHNOLOGIES OFFICER']), children: [
                  { id: 'websec', title: 'Web Security', type: 'senior', members: findMembersByTitles(['WEB SECURITY ADMIN']) }
              ]},
              {
                id: 'log',
                title: 'Logistics',
                type: 'senior',
                members: findMembersByTitles(['DIRECTOR OF LOGISTICS','LOGISTICS OFFICER']),
                children: [
                  { id: 'supply', title: 'Supply', type: 'senior', members: findMembersByTitles(['SUPPLY OFFICER'], { excludeWords: ['CADET'] }) },
                  { id: 'transport', title: 'Transportation', type: 'senior', members: findMembersByTitles(['TRANSPORTATION OFFICER']) },
                  { id: 'maint', title: 'Maintenance', type: 'senior', members: findMembersByTitles(['MAINTENANCE OFFICER']) },
                  communicationsNode
                ]
              },
              { id: 'pa', title: 'Public Affairs', type: 'senior', members: findMembersByTitles(['DIRECTOR OF PUBLIC AFFAIRS','PUBLIC AFFAIRS OFFICER'], { excludeWords: ['CADET'] }) },
              { id: 'recruiting', title: 'Recruiting', type: 'senior', members: findMembersByTitles(['DIRECTOR OF RECRUITING','RECRUITING OFFICER','CADET PROGRAMS OFFICER']) },
              { id: 'chaplain', title: 'Chaplain', type: 'senior', members: findMembersByTitles(['CHAPLAIN','WING CHAPLAIN COORDINATOR']), children: [
                  { id: 'cdi', title: 'Character Development', type: 'senior', members: findMembersByTitles(['CHARACTER DEVELOPMENT INSTRUCTOR']) }
              ] },
              { id: 'finance', title: 'Finance', type: 'senior', members: findMembersByTitles(['DIRECTOR OF FINANCE','FINANCE OFFICER']) }
            ];

            const chiefOfStaffNode = {
              id: 'chief_staff',
              title: 'Chief of Staff',
              type: 'senior',
              members: findMembersByTitles(['CHIEF OF STAFF']),
              children: isWing ? [...chiefOfStaffStaff, { id: 'dev', title: 'Development', type: 'senior', members: findMembersByTitles(['DIRECTOR OF DEVELOPMENT','DIVERSITY OFFICER']) }] : chiefOfStaffStaff
            };

            const seniorEnlistedLeaderNode = {
              id: 'senior_enlisted',
              title: 'Senior Enlisted Leader',
              type: 'senior',
              members: findMembersByTitles(['SENIOR ENLISTED LEADER']),
              children: []
            };
            if (isWing) {
              const ncoChildren = findMembersByTitles(['NCO ADVISOR','GROUP NCO']);
              if (ncoChildren.length > 0) seniorEnlistedLeaderNode.children.push({ id: 'nco', title: 'NCO Advisor', type: 'senior', members: ncoChildren, children: [] });
            }

            // Deputy Commander staff
            const educationTrainingNode = { id: 'pd', title: 'Education and Training', type: 'senior', members: findMembersByTitles(['DIRECTOR OF EDUCATION AND TRAINING','EDUCATION AND TRAINING OFFICER','PROFESSIONAL DEVELOPMENT OFFICER','DIRECTOR OF EDUCATION AND TRAINING']), children: isWing ? [
                { id: 'test', title: 'Testing', type: 'senior', members: findMembersByTitles(['TESTING OFFICER']) }
            ] : [] };
            const aerospaceEducationNode = { id: 'ae', title: 'Aerospace Education', type: 'senior', members: findMembersByTitles(['DIRECTOR OF AEROSPACE EDUCATION','AEROSPACE EDUCATION OFFICER','CYBER EDUCATION OFFICER']), children: isWing ? [
                { id: 'ae_internal', title: 'Internal Aerospace Education', type: 'senior', members: findMembersByTitles(['INTERNAL AEROSPACE EDUCATION OFFICER']) },
                { id: 'ae_external', title: 'External Aerospace Education', type: 'senior', members: findMembersByTitles(['EXTERNAL AEROSPACE EDUCATION OFFICER']) }
            ] : [] };
            const cadetProgramsNode = { id: 'dcp', title: 'Cadet Programs', type: 'senior', members: findMembersByTitles(['DIRECTOR OF CADET PROGRAMS','CADET PROGRAMS DEVELOPMENT OFFICER']), children: [
                { id: 'act', title: 'Activities', type: 'senior', members: findMembersByTitles(['ACTIVITIES OFFICER']) },
                { id: 'fitness', title: 'Fitness', type: 'senior', members: findMembersByTitles(['FITNESS OFFICER']) },
                { id: 'lead', title: 'Leadership', type: 'senior', members: findMembersByTitles(['LEADERSHIP OFFICER']) }
            ]};
            const stanevalNode = { id: 'staneval', title: 'Standardization/Evaluation', type: 'senior', members: findMembersByTitles(['STANDARDIZATION/EVALUATION OFFICER','STANDARDIZATION AND EVALUATION OFFICER']) };
            const homelandSecurityNode = { id: 'homeland', title: 'Homeland Security', type: 'senior', members: findMembersByTitles(['HOMELAND SECURITY OFFICER']) };
            const emergencyServicesNode = {
              id: 'es',
              title: 'Emergency Services',
              type: 'senior',
              members: findMembersByTitles(['DIRECTOR OF EMERGENCY SERVICES','EMERGENCY SERVICES OFFICER','DISASTER RELIEF OFFICER','DISASTER PREPAREDNESS OFFICER']),
              children: [
                { id: 'sar', title: 'Search and Rescue', type: 'senior', members: findMembersByTitles(['SEARCH AND RESCUE OFFICER']) },
                { id: 'training', title: 'Emergency Services Training', type: 'senior', members: findMembersByTitles(['EMERGENCY SERVICES TRAINING OFFICER']) },
                { id: 'disaster', title: 'Disaster Preparedness', type: 'senior', members: findMembersByTitles(['DISASTER PREPAREDNESS OFFICER']) },
                ...(isWing ? [] : [homelandSecurityNode])
              ]
            };
            const alertingNode = { id: 'alerting', title: 'Alerting', type: 'senior', members: findMembersByTitles(['ALERTING OFFICER']) };
            const operationsChildren = [
              stanevalNode,
              ...(isWing ? [] : [emergencyServicesNode]),
              alertingNode,
              ...(isWing ? [{ id: 'suas', title: 'Small Unmanned Aerial Systems', type: 'senior', members: findMembersByTitles(['SMALL UNMANNED AERIAL SYSTEMS OFFICER']) }] : [])
            ];
            const operationsNode = {
              id: 'ops',
              title: 'Operations',
              type: 'senior',
              members: findMembersByTitles(['DIRECTOR OF OPERATIONS','OPERATIONS OFFICER','COUNTERDRUG OFFICER']),
              children: operationsChildren
            };

            const wingDeputySupportStaff = [educationTrainingNode, cadetProgramsNode, aerospaceEducationNode];
            const wingDeputyOperationsStaff = [operationsNode, emergencyServicesNode, homelandSecurityNode];
            const deputyCommanderStaff = [...wingDeputySupportStaff, ...wingDeputyOperationsStaff];

            // For non-Wing units, use traditional direct staff structure
            const directStaff = [];
            directStaff.push({ id: 'legal', title: 'Legal', type: 'senior', members: findMembersByTitles(['LEGAL OFFICER']) });
            directStaff.push({ id: 'safety', title: 'Safety', type: 'senior', members: findMembersByTitles(['DIRECTOR OF SAFETY','SAFETY OFFICER'], { excludeWords: ['CADET'] }) });
            directStaff.push({ id: 'ig', title: 'Inspector General', type: 'senior', members: findMembersByTitles(['INSPECTOR GENERAL']) });
            if (!isWing) {
              directStaff.push({ id: 'nco', title: 'NCO Advisor', type: 'senior', members: findMembersByTitles(['NCO ADVISOR','GROUP NCO']) });
              directStaff.push({ id: 'chaplain', title: 'Chaplain', type: 'senior', members: findMembersByTitles(['CHAPLAIN','WING CHAPLAIN COORDINATOR']), children: [
                  { id: 'cdi', title: 'Character Development', type: 'senior', members: findMembersByTitles(['CHARACTER DEVELOPMENT INSTRUCTOR']) }
              ] });
              directStaff.push({ id: 'pa', title: 'Public Affairs', type: 'senior', members: findMembersByTitles(['PUBLIC AFFAIRS OFFICER','DIRECTOR OF PUBLIC AFFAIRS'], { excludeWords: ['CADET'] }) });
              directStaff.push({ id: 'admin', title: 'Administration', type: 'senior', members: findMembersByTitles(['ADMINISTRATIVE OFFICER','DIRECTOR OF ADMINISTRATION'], { excludeWords: ['CADET'] }) });
              directStaff.push({ id: 'finance', title: 'Finance', type: 'senior', members: findMembersByTitles(['FINANCE OFFICER','DIRECTOR OF FINANCE']) });
            }

            // For non-Wing units, traditional senior staff
            const seniorStaff = [
              {
                id: 'ops',
                title: 'Operations',
                type: 'senior',
                members: findMembersByTitles(['DIRECTOR OF OPERATIONS','OPERATIONS OFFICER'], { excludeWords: ['DEPUTY','CADET'] }),
                children: [
                  { id: 'staneval', title: 'Standardization/Evaluation', type: 'senior', members: findMembersByTitles(['STANDARDIZATION/EVALUATION OFFICER','STANDARDIZATION AND EVALUATION OFFICER']) },
                  {
                    id: 'es',
                    title: 'Emergency Services',
                    type: 'senior',
                    members: findMembersByTitles(['DIRECTOR OF EMERGENCY SERVICES','EMERGENCY SERVICES OFFICER','DISASTER RELIEF OFFICER']),
                    children: [
                      { id: 'sar', title: 'Search and Rescue', type: 'senior', members: findMembersByTitles(['SEARCH AND RESCUE OFFICER']) },
                      { id: 'training', title: 'Emergency Services Training', type: 'senior', members: findMembersByTitles(['EMERGENCY SERVICES TRAINING OFFICER']) },
                      { id: 'disaster', title: 'Disaster Preparedness', type: 'senior', members: findMembersByTitles(['DISASTER PREPAREDNESS OFFICER']) },
                      { id: 'homeland', title: 'Homeland Security', type: 'senior', members: findMembersByTitles(['HOMELAND SECURITY OFFICER']) }
                    ]
                  },
                  { id: 'alerting', title: 'Alerting', type: 'senior', members: findMembersByTitles(['ALERTING OFFICER']) }
                ]
              },
              {
                id: 'log',
                title: 'Logistics',
                type: 'senior',
                members: findMembersByTitles(['DIRECTOR OF LOGISTICS','LOGISTICS OFFICER']),
                children: [
                  { id: 'supply', title: 'Supply', type: 'senior', members: findMembersByTitles(['SUPPLY OFFICER'], { excludeWords: ['CADET'] }) },
                  { id: 'transport', title: 'Transportation', type: 'senior', members: findMembersByTitles(['TRANSPORTATION OFFICER']) },
                  { id: 'maint', title: 'Maintenance', type: 'senior', members: findMembersByTitles(['MAINTENANCE OFFICER']) }
                ]
              },
              communicationsNode,
              { id: 'pd', title: 'Education and Training', type: 'senior', members: findMembersByTitles(['DIRECTOR OF EDUCATION AND TRAINING','EDUCATION AND TRAINING OFFICER','PROFESSIONAL DEVELOPMENT OFFICER']) },
              { id: 'personnel', title: 'Personnel', type: 'senior', members: findMembersByTitles(['PERSONNEL OFFICER']) },
              { id: 'recruiting', title: 'Recruiting', type: 'senior', members: findMembersByTitles(['DIRECTOR OF RECRUITING','RECRUITING OFFICER']) },
              { id: 'it', title: 'Information Technology', type: 'senior', members: findMembersByTitles(['DIRECTOR OF IT','INFORMATION TECHNOLOGIES OFFICER']), children: [
                  { id: 'websec', title: 'Web Security', type: 'senior', members: findMembersByTitles(['WEB SECURITY ADMIN']) }
              ] }
            ];
            
            const cadetStaff = [
              { id: 'lead', title: 'Leadership', type: 'senior', members: findMembersByDuty('LEADERSHIP OFFICER') },
              { id: 'ae', title: 'Aerospace Education', type: 'senior', members: findMembersByDuty('AEROSPACE EDUCATION') },
              { id: 'act', title: 'Activities', type: 'senior', members: findMembersByDuty('ACTIVITIES OFFICER') },
              { id: 'fitness', title: 'Fitness', type: 'senior', members: findMembersByDuty('FITNESS OFFICER') }
            ];
            
            // FIXED: Use cadet duty data for cadet positions
            const cadetCommanders = findMembersByTitles(['CADET COMMANDER'], { useCadetData: true });
            const flightCommanders = findMembersByTitles(['CADET FLIGHT COMMANDER'], { useCadetData: true });
            const flightSergeants = findMembersByTitles(['CADET FLIGHT SERGEANT'], { useCadetData: true });
            
            // Calculate Flight Members - cadets without non-flight duty positions
            // Separate officers from NCOs/Airmen
            const flightMembersRaw = dataFiles.members
              .filter(m => {
                const isCadet = (m.Type || m.TYPE) === "CADET";
                const status = String(m.MbrStatus || "").toUpperCase();
                const isActive = status === "ACTIVE";
                if (!isCadet || !isActive) return false;
                // Only include cadets whose home unit is the current org (avoid wing-wide flooding)
                if (String(m.ORGID).trim() !== String(unitFilter).trim()) return false;

                const hasNonFlightDuty = allCadetDuties.some(d =>
                  d.CAPID === m.CAPID &&
                  !d.Duty.toUpperCase().includes('FLIGHT') &&
                  !d.Duty.toUpperCase().includes('ELEMENT')
                );

                return !hasNonFlightDuty;
              });

            // Officer ranks: C/2d Lt, C/1st Lt, C/Capt, C/Maj, C/Lt Col, C/Col
            const officerRanks = ['C/2DLT', 'C/1STLT', 'C/CAPT', 'C/MAJ', 'C/LTCOL', 'C/COL'];
            const flightOfficers = flightMembersRaw
              .filter(m => {
                const rankUpper = m.Rank.toUpperCase().replace(/\./g, '').trim();
                return officerRanks.includes(rankUpper);
              })
              .map(m => `${m.Rank} ${m.NameLast}, ${m.NameFirst}||${m.CAPID}`)
              .sort();

            const flightEnlisted = flightMembersRaw
              .filter(m => {
                const rankUpper = m.Rank.toUpperCase().replace(/\./g, '').trim();
                return !officerRanks.includes(rankUpper);
              })
              .map(m => `${m.Rank} ${m.NameLast}, ${m.NameFirst}||${m.CAPID}`)
              .sort();

            // Officer Flight Members node
            const flightOfficersNode = {
              id: 'flight_officers',
              title: 'Flight Member Officers',
              type: 'cadet',
              members: flightOfficers,
              children: []
            };

            // Enlisted Flight Members node
            const flightEnlistedNode = {
              id: 'flight_enlisted',
              title: 'Flight Member Airmen',
              type: 'cadet',
              members: flightEnlisted,
              children: []
            };

            const flightStructure = [];

            // Build flight structure with proper officer/enlisted separation
            if (flightCommanders.length > 0) {
              const flightCmdrChildren = [];

              // Officers report to Flight Commander
              if (flightOfficers.length > 0) {
                flightCmdrChildren.push(flightOfficersNode);
              }

              // Flight Sergeant reports to Flight Commander, enlisted report to Flight Sergeant
              if (flightSergeants.length > 0) {
                flightCmdrChildren.push({
                  id: 'flight_sgt',
                  title: 'Flight Sergeants',
                  type: 'cadet',
                  members: flightSergeants,
                  children: flightEnlisted.length > 0 ? [flightEnlistedNode] : []
                });
              } else if (flightEnlisted.length > 0) {
                // No Flight Sergeant, enlisted report directly to Flight Commander
                flightCmdrChildren.push(flightEnlistedNode);
              }

              flightStructure.push({
                id: 'flight_cmdr',
                title: 'Flight Commanders',
                type: 'cadet',
                members: flightCommanders,
                children: flightCmdrChildren
              });
            } else if (flightSergeants.length > 0) {
              // No Flight Commander, both report to Flight Sergeant (but officers should escalate to DC Ops)
              const flightSgtChildren = [];
              if (flightEnlisted.length > 0) {
                flightSgtChildren.push(flightEnlistedNode);
              }

              flightStructure.push({
                id: 'flight_sgt',
                title: 'Flight Sergeants',
                type: 'cadet',
                members: flightSergeants,
                children: flightSgtChildren
              });

              // Officers without Flight Commander report separately to DC Ops (will be added at DC Ops level)
              if (flightOfficers.length > 0) {
                flightStructure.push(flightOfficersNode);
              }
            } else {
              // No flight leadership - both types report directly to DC Ops
              if (flightOfficers.length > 0) {
                flightStructure.push(flightOfficersNode);
              }
              if (flightEnlisted.length > 0) {
                flightStructure.push(flightEnlistedNode);
              }
            }

            // Build cadet org children array dynamically
            const cadetOrgChildren = [
              { id: 'c_first', title: 'C/First Sergeant', type: 'cadet', members: findMembersByDuty('CADET FIRST SERGEANT', [], true) }
            ];

            // Build C/Dep Cmdr Support children array
            const cDepSupChildren = [
              { id: 'c_admin', title: 'C/Admin', type: 'cadet', members: findMembersByDuty('CADET ADMINISTRATIVE', [], true) },
              { id: 'c_pa', title: 'C/PA', type: 'cadet', members: findMembersByDuty('CADET PUBLIC AFFAIRS', [], true) },
              { id: 'c_comm', title: 'C/Communications', type: 'cadet', members: findMembersByDuty('CADET COMMUNICATIONS', [], true) },
              { id: 'c_supply', title: 'C/Supply', type: 'cadet', members: findMembersByDuty('CADET SUPPLY', [], true) },
              { id: 'c_safety', title: 'C/Safety', type: 'cadet', members: findMembersByDuty('CADET SAFETY', [], true) }
            ];

            cadetOrgChildren.push(
              {
                id: 'c_dep_ops',
                title: 'C/Dep Cmdr Operations',
                type: 'cadet',
                members: findMembersByDuty('CADET DEPUTY COMMANDER FOR OPERATIONS', [], true),
                children: flightStructure
              },
              {
                id: 'c_dep_sup',
                title: 'C/Dep Cmdr Support',
                type: 'cadet',
                members: findMembersByDuty('CADET DEPUTY COMMANDER FOR SUPPORT', [], true),
                children: cDepSupChildren
              }
            );

            const cadetOrg = {
              id: 'ccmdr',
              title: 'Cadet Commander',
              type: 'cadet',
              members: cadetCommanders,
              children: cadetOrgChildren
            };
            
            // Track all assigned members and find unassigned ones
            const assignedCAPIDs = new Set();
            [...allDuties, ...allCadetDuties].forEach(d => {
              if (d.CAPID) assignedCAPIDs.add(d.CAPID);
            });

            // Find unassigned senior members
            const unassignedSeniors = unitMembers
              .filter(m => {
                const isSenior = (m.Type || m.TYPE) === "SENIOR" || (m.Type || m.TYPE) === "LIFE";
                return isSenior && !assignedCAPIDs.has(m.CAPID);
              })
              .map(m => `${m.Rank} ${m.NameLast}, ${m.NameFirst}`)
              .sort();

            const additionalMembersNode = {
              id: 'additional_members',
              title: `Additional Members (${unassignedSeniors.length})`,
              type: 'senior',
              members: unassignedSeniors,
              children: []
            };

            const nodeHasAnyMembers = (node) => {
              if (node.members && node.members.length > 0) return true;
              return (node.children || []).some(child => nodeHasAnyMembers(child));
            };

            const buildWingDeputyNodes = () => {
              const nodes = [];
              const opsChildren = [...wingDeputyOperationsStaff];
              if (unassignedSeniors.length > 0) {
                opsChildren.push(additionalMembersNode);
              }
              const opsNode = { ...deputyOpsNode, children: opsChildren };
              const supportNode = { ...deputySupportNode, children: [...wingDeputySupportStaff] };

              const opsHasContent = nodeHasAnyMembers(opsNode) || !hideVacant;
              const supportHasContent = nodeHasAnyMembers(supportNode) || !hideVacant;

              if (opsHasContent) nodes.push(opsNode);
              if (supportHasContent) nodes.push(supportNode);

              return nodes;
            };

            // Build a minimal command-chain subtree for a specific unit (commander's immediate chain)
            const buildUnitCommandChain = (orgId) => {
              const chain = [];
              const orgScoped = [String(orgId).trim()];
              const orgEntry = dataFiles.organization.find(o => String(o.ORGID).trim() === String(orgId).trim());
              const orgType = (orgEntry?.Type || '').toUpperCase();
              const isGroupOrg = orgType.includes('GROUP');
              const isCompositeUnit = orgType.includes('COMPOSITE');
              const isCadetUnit = orgType.includes('CADET');
              const isSeniorUnit = orgType.includes('SENIOR') || (!isCompositeUnit && !isCadetUnit && !isGroupOrg && !orgType.includes('WING'));
              // Restrict vacant positions based on unit type (always, not just in command chain view)
              // Composite squadrons and groups should not show vacant "Deputy Commander"
              const restrictDeputyVacant = isCompositeUnit || isGroupOrg;
              // Cadet, senior squadrons, and groups should not show vacant "DC for Seniors/Cadets"
              const restrictDeputySpecialVacant = isCadetUnit || isSeniorUnit || isGroupOrg;
              // Groups should not show vacant cadet chain
              const restrictCadetChainVacant = isGroupOrg;
              const allowVacantCadetChain = !restrictCadetChainVacant;

              const commanderChildren = [];

              // Deputies
              const deputyChain = findMembersByTitles(['DEPUTY COMMANDER'], { excludeWords: ['FOR SENIORS', 'FOR CADETS'], orgFilter: orgScoped });
              const deputyNode = (deputyChain.length > 0 || (!hideVacant && !restrictDeputyVacant))
                ? { id: `${orgId}_deputy`, title: 'Deputy Commander', type: 'senior', members: deputyChain, children: [] }
                : null;

              // No Deputy Commander for Seniors / Cadets at Group level
              const includeDeputySeniors = !isGroupOrg;
              const includeDeputyCadets = !isGroupOrg;

              const deputySeniors = includeDeputySeniors ? findMembersByTitles(['DEPUTY COMMANDER FOR SENIORS'], { orgFilter: orgScoped }) : [];
              const deputyCadets = includeDeputyCadets ? findMembersByTitles(['DEPUTY COMMANDER FOR CADETS'], { orgFilter: orgScoped }) : [];

              const deputySeniorsNode = (deputySeniors.length > 0 || (!hideVacant && includeDeputySeniors && !restrictDeputySpecialVacant))
                ? { id: `${orgId}_cds`, title: 'Deputy Commander for Seniors', type: 'senior', members: deputySeniors, children: [] }
                : null;
              const deputyCadetsNode = (deputyCadets.length > 0 || (!hideVacant && includeDeputyCadets && !restrictDeputySpecialVacant))
                ? { id: `${orgId}_cdc`, title: 'Deputy Commander for Cadets', type: 'senior', members: deputyCadets, children: [] }
                : null;

              // Cadet chain
              const cadetCommander = findMembersByTitles(['CADET COMMANDER'], { useCadetData: true, orgFilter: orgScoped });
              const cadetFirstSgt = findMembersByTitles(['CADET FIRST SERGEANT'], { useCadetData: true, orgFilter: orgScoped });
              const cadetDepOps = findMembersByTitles(['CADET DEPUTY COMMANDER FOR OPERATIONS'], { useCadetData: true, orgFilter: orgScoped });
              const cadetDepSup = findMembersByTitles(['CADET DEPUTY COMMANDER FOR SUPPORT'], { useCadetData: true, orgFilter: orgScoped });
              const flightCommanders = findMembersByTitles(['CADET FLIGHT COMMANDER'], { useCadetData: true, orgFilter: orgScoped });
              const flightSergeants = findMembersByTitles(['CADET FLIGHT SERGEANT'], { useCadetData: true, orgFilter: orgScoped });

              // Build flight structure for command chain
              const flightChainChildren = [];
              if (flightSergeants.length > 0 || (!hideVacant && allowVacantCadetChain)) {
                flightChainChildren.push({ id: `${orgId}_flight_sgt`, title: 'Flight Sergeants', type: 'cadet', members: flightSergeants, children: [] });
              }

              // Build C/Dep Cmdr Operations with flight commanders
              const depOpsChildren = [];
              if (flightCommanders.length > 0 || (!hideVacant && allowVacantCadetChain)) {
                depOpsChildren.push({ id: `${orgId}_flight_cmdr`, title: 'Flight Commanders', type: 'cadet', members: flightCommanders, children: flightChainChildren });
              }

              const cadetChildren = [];
              // Add First Sergeant
              if (cadetFirstSgt.length > 0 || (!hideVacant && allowVacantCadetChain)) {
                cadetChildren.push({ id: `${orgId}_c_first`, title: 'C/First Sergeant', type: 'cadet', members: cadetFirstSgt, children: [] });
              }
              // Add Deputy Commanders
              if (cadetDepOps.length > 0 || depOpsChildren.length > 0 || (!hideVacant && allowVacantCadetChain)) {
                cadetChildren.push({ id: `${orgId}_c_dep_ops`, title: 'C/Dep Cmdr Operations', type: 'cadet', members: cadetDepOps, children: depOpsChildren });
              }
              if (cadetDepSup.length > 0 || (!hideVacant && allowVacantCadetChain)) {
                cadetChildren.push({ id: `${orgId}_c_dep_sup`, title: 'C/Dep Cmdr Support', type: 'cadet', members: cadetDepSup, children: [] });
              }

              const cadetCommanderNode = (cadetCommander.length > 0 || cadetChildren.length > 0 || (!hideVacant && allowVacantCadetChain))
                ? { id: `${orgId}_ccmdr`, title: 'Cadet Commander', type: 'cadet', members: cadetCommander, children: cadetChildren }
                : null;

              // Attach cadet commander under DCC if present, else Deputy Commander, else top-level
              if (deputyCadetsNode && cadetCommanderNode) {
                deputyCadetsNode.children.push(cadetCommanderNode);
              } else if (deputyNode && cadetCommanderNode) {
                deputyNode.children.push(cadetCommanderNode);
              } else if (cadetCommanderNode) {
                commanderChildren.push(cadetCommanderNode);
              }

              if (deputySeniorsNode) commanderChildren.push(deputySeniorsNode);
              if (deputyCadetsNode) commanderChildren.push(deputyCadetsNode);
              if (deputyNode) commanderChildren.unshift(deputyNode);

              return commanderChildren;
            };

            // Group Commanders (Wing-level chain)
            let groupCommandNodes = [];
            if (isWing) {
              const groupOrgs = dataFiles.organization
                .filter(o => o.Type && o.Type.toUpperCase().includes('GROUP') && String(o.NextLevel).trim() === String(unitFilter).trim());

              if (showCommandChainOnly) {
                // Command Chain Only: Create separate node for each group with squadron commanders
                groupOrgs.forEach((groupOrg, index) => {
                  const groupOrgId = String(groupOrg.ORGID).trim();
                  const groupName = groupOrg.Name || `Group ${index + 1}`;

                  // Find group commander
                  const groupCmdrs = dataFiles.duty
                    .filter(d => String(d.ORGID).trim() === groupOrgId)
                    .filter(d => {
                      const dutyUpper = (d.Duty || '').toUpperCase();
                      if (!dutyUpper.includes('COMMANDER')) return false;
                      return !['DEPUTY', 'CADET', 'VICE', 'ADVISOR'].some(w => dutyUpper.includes(w));
                    })
                    .map(d => {
                      const mem = getMemberByCapid(d.CAPID);
                      if (!mem) return null;
                      const asst = d.Asst === "1" ? " (A)" : "";
                      return `${mem.Rank} ${mem.NameLast}, ${mem.NameFirst}${asst}||${mem.CAPID}`;
                    })
                    .filter(Boolean);

                  // Find squadron commanders under this group
                  const squadronChildren = unitChildrenMap.get(groupOrgId) || [];
                  const squadronNodes = squadronChildren
                    .map(squadronOrgId => {
                      const squadronOrg = dataFiles.organization.find(o => String(o.ORGID).trim() === squadronOrgId);
                      if (!squadronOrg) return null;

                      const squadronName = squadronOrg.Name || 'Squadron';
                      const squadronCmdrs = dataFiles.duty
                        .filter(d => String(d.ORGID).trim() === squadronOrgId)
                        .filter(d => {
                          const dutyUpper = (d.Duty || '').toUpperCase();
                          if (!dutyUpper.includes('COMMANDER')) return false;
                          return !['DEPUTY', 'CADET', 'VICE', 'ADVISOR'].some(w => dutyUpper.includes(w));
                        })
                        .map(d => {
                          const mem = getMemberByCapid(d.CAPID);
                          if (!mem) return null;
                          const asst = d.Asst === "1" ? " (A)" : "";
                          return `${mem.Rank} ${mem.NameLast}, ${mem.NameFirst}${asst}||${mem.CAPID}`;
                        })
                        .filter(Boolean);

                  return {
                    id: `squadron_cmdr_${squadronOrgId}`,
                    title: `${squadronName} Commander`,
                    type: 'senior',
                    members: squadronCmdrs,
                    children: buildUnitCommandChain(squadronOrgId)
                  };
                })
                .filter(Boolean);

                  const groupChain = buildUnitCommandChain(groupOrgId);
                  groupCommandNodes.push({
                    id: `group_cmdr_${groupOrgId}`,
                    title: `${groupName} Commander`,
                    type: 'senior',
                    members: groupCmdrs,
                    children: [...groupChain, ...squadronNodes]
                  });
                });
              } else {
                // Normal view: All group commanders in one box
                const groupOrgIds = groupOrgs.map(o => String(o.ORGID).trim());
                const groupCmdrs = dataFiles.duty
                  .filter(d => groupOrgIds.includes(String(d.ORGID).trim()))
                  .filter(d => {
                    const dutyUpper = (d.Duty || '').toUpperCase();
                    if (!dutyUpper.includes('COMMANDER')) return false;
                    return !['DEPUTY', 'CADET', 'VICE', 'ADVISOR'].some(w => dutyUpper.includes(w));
                  })
                  .map(d => {
                    const mem = getMemberByCapid(d.CAPID);
                    if (!mem) return null;
                    const asst = d.Asst === "1" ? " (A)" : "";
                    return `${mem.Rank} ${mem.NameLast}, ${mem.NameFirst}${asst}||${mem.CAPID}`;
                  })
                  .filter(Boolean);
                if (groupCmdrs.length > 0) {
                  groupCommandNodes.push({ id: 'group_cmdr', title: 'Group Commander', type: 'senior', members: groupCmdrs, children: [] });
                }
              }
            }

            // Squadron Commanders (Group-level chain)
            let squadronCommandNodes = [];
            if (isGroup) {
              const squadronChildren = unitChildrenMap.get(String(unitFilter).trim()) || [];

              if (showCommandChainOnly) {
                squadronCommandNodes = squadronChildren
                  .map(squadronOrgId => {
                    const squadronOrg = dataFiles.organization.find(o => String(o.ORGID).trim() === squadronOrgId);
                    if (!squadronOrg) return null;

                    const squadronName = squadronOrg.Name || 'Squadron';
                    const squadronCmdrs = dataFiles.duty
                      .filter(d => String(d.ORGID).trim() === squadronOrgId)
                      .filter(d => {
                        const dutyUpper = (d.Duty || '').toUpperCase();
                        if (!dutyUpper.includes('COMMANDER')) return false;
                        return !['DEPUTY', 'CADET', 'VICE', 'ADVISOR'].some(w => dutyUpper.includes(w));
                      })
                      .map(d => {
                        const mem = getMemberByCapid(d.CAPID);
                        if (!mem) return null;
                        const asst = d.Asst === "1" ? " (A)" : "";
                        return `${mem.Rank} ${mem.NameLast}, ${mem.NameFirst}${asst}||${mem.CAPID}`;
                      })
                      .filter(Boolean);

                    const squadronChain = buildUnitCommandChain(squadronOrgId);
                    return {
                      id: `squadron_cmdr_${squadronOrgId}`,
                      title: `${squadronName} Commander`,
                      type: 'senior',
                      members: squadronCmdrs,
                      children: squadronChain
                    };
                  })
                  .filter(Boolean);
              } else {
                const squadronCmdrs = [];
                squadronChildren.forEach(squadronOrgId => {
                  const squadronOrg = dataFiles.organization.find(o => String(o.ORGID).trim() === squadronOrgId);
                  if (!squadronOrg) return;

                  const squadronName = squadronOrg.Name || 'Squadron';
                  const commanders = dataFiles.duty
                    .filter(d => String(d.ORGID).trim() === squadronOrgId)
                    .filter(d => {
                      const dutyUpper = (d.Duty || '').toUpperCase();
                      if (!dutyUpper.includes('COMMANDER')) return false;
                      return !['DEPUTY', 'CADET', 'VICE', 'ADVISOR'].some(w => dutyUpper.includes(w));
                    })
                    .map(d => {
                      const mem = getMemberByCapid(d.CAPID);
                      if (!mem) return null;
                      const asst = d.Asst === "1" ? " (A)" : "";
                      return `${mem.Rank} ${mem.NameLast}, ${mem.NameFirst}${asst}||${mem.CAPID}`;
                    })
                    .filter(Boolean);

                  if (commanders.length > 0) {
                    squadronCmdrs.push(...commanders);
                  } else if (!hideVacant) {
                    squadronCmdrs.push(`Vacant`);
                  }
                });

                if (squadronCmdrs.length > 0 || !hideVacant) {
                  squadronCommandNodes.push({
                    id: 'squadron_cmdr',
                    title: 'Squadron Commanders',
                    type: 'senior',
                    members: squadronCmdrs,
                    children: []
                  });
                }
              }
            }

            // Build structure based on unit type
            if (isComposite) {
              // Add Wing-specific positions for Wings
              if (isWing) {
                if (chiefOfStaffNode.members.length > 0 || !hideVacant) {
                  orgStructure.children.push(chiefOfStaffNode);
                }
                if (seniorEnlistedLeaderNode.members.length > 0 || !hideVacant) {
                  orgStructure.children.push(seniorEnlistedLeaderNode);
                }
              }

              // Note: CACs (WCAC/GCAC) are now shown in the Committees panel, not on the org chart

              if (isWing) {
                if (deputySeniorNode.members.length > 0) {
                  deputySeniorNode.children = deputyCommanderStaff;
                  orgStructure.children.push(deputySeniorNode);
                }

                const wingDeputyNodes = buildWingDeputyNodes();
                if (wingDeputyNodes.length > 0) {
                  orgStructure.children.push(...wingDeputyNodes);
                } else {
                  orgStructure.children.push(...wingDeputySupportStaff, ...wingDeputyOperationsStaff);
                }
              } else {
                if (deputySeniorNode.members.length > 0) {
                  deputySeniorNode.children = seniorStaff;
                  // Add unassigned seniors under Deputy Commander for Seniors
                  if (unassignedSeniors.length > 0) {
                    deputySeniorNode.children.push(additionalMembersNode);
                  }
                  orgStructure.children.push(deputySeniorNode);
                } else if (deputyNode.members.length > 0) {
                  deputyNode.children = seniorStaff;
                  // Add unassigned seniors under Deputy Commander
                  if (unassignedSeniors.length > 0) {
                    deputyNode.children.push(additionalMembersNode);
                  }
                  orgStructure.children.push(deputyNode);
                } else {
                  orgStructure.children.push(...seniorStaff);
                }
              }
              
              if (deputyCadetNode.members.length > 0) {
                deputyCadetNode.children = [...cadetStaff, cadetOrg];
                orgStructure.children.push(deputyCadetNode);
              } else {
                orgStructure.children.push(...cadetStaff, cadetOrg);
              }
            } else if (isCadetOnly) {
              // Note: CACs (WCAC/GCAC) are now shown in the Committees panel, not on the org chart

              if (deputyNode.members.length > 0) {
                deputyNode.children = [...cadetStaff, cadetOrg];
                orgStructure.children.push(deputyNode);
              } else {
                orgStructure.children.push(...cadetStaff, cadetOrg);
              }
            } else {
              // Senior-only unit
              // Add Wing-specific positions for Wings
              if (isWing) {
                if (chiefOfStaffNode.members.length > 0 || !hideVacant) {
                  orgStructure.children.push(chiefOfStaffNode);
                }
                if (seniorEnlistedLeaderNode.members.length > 0 || !hideVacant) {
                  orgStructure.children.push(seniorEnlistedLeaderNode);
                }
              }

              if (isWing) {
                const wingDeputyNodes = buildWingDeputyNodes();
                if (wingDeputyNodes.length > 0) {
                  orgStructure.children.push(...wingDeputyNodes);
                } else {
                  orgStructure.children.push(...wingDeputySupportStaff, ...wingDeputyOperationsStaff);
                }
              } else if (deputyNode.members.length > 0) {
                deputyNode.children = seniorStaff;
                // Add unassigned seniors under Deputy Commander
                if (unassignedSeniors.length > 0) {
                  deputyNode.children.push(additionalMembersNode);
                }
                orgStructure.children.push(deputyNode);
              } else {
                orgStructure.children.push(...seniorStaff);
              }
            }

            // Create Commander's Staff grouping node
            const advisorNode = {
              id: 'advisor',
              title: 'Advisor to the Commander',
              type: 'senior',
              members: findMembersByDuty('ADVISOR TO THE COMMANDER'),
              children: []
            };
            const govRelationsAdvisorNode = {
              id: 'gov_relations',
              title: 'Government Relations Advisor',
              type: 'senior',
              members: findMembersByTitles(['GOVERNMENT RELATIONS ADVISOR']),
              children: []
            };

            // Combine all commander's staff positions into children array
            const commanderStaffChildren = [];

            // Add direct staff positions (Legal, Safety, Inspector General, etc.)
            directStaff.forEach(staffNode => {
              if (!hideVacant || staffNode.members.length > 0) {
                commanderStaffChildren.push(staffNode);
              }
            });

            // Add advisor positions
            if (advisorNode.members.length > 0 || !hideVacant) {
              commanderStaffChildren.push(advisorNode);
            }
            if (govRelationsAdvisorNode.members.length > 0 || !hideVacant) {
              commanderStaffChildren.push(govRelationsAdvisorNode);
            }

            // Create the Commander's Staff parent node
            const commanderStaffNode = {
              id: 'commander_staff',
              title: "Commander's Staff",
              type: 'senior',
              members: [], // No direct members, just a grouping
              children: commanderStaffChildren
            };

            // Only add Commander's Staff node if it has children
            if (commanderStaffChildren.length > 0) {
              orgStructure.children.unshift(commanderStaffNode);
            }

            if (groupCommandNodes.length > 0) {
              orgStructure.children.unshift(...groupCommandNodes);
            }

            if (squadronCommandNodes.length > 0) {
              orgStructure.children.unshift(...squadronCommandNodes);
            }

            return orgStructure;
          };

          setOrgChartData(buildOrgChart());
        }, [dataFiles, unitFilter, showAllDescendants, hideVacant, showCommandChainOnly]);

        const getAllNodeIds = (node) => {
          if (!node) return [];
          const ids = [node.id];
          if (node.children) {
            node.children.forEach(child => {
              ids.push(...getAllNodeIds(child));
            });
          }
          return ids;
        };

        // Auto-expand nodes when org chart is built (special handling for wing/group command-chain view)
        useEffect(() => {
          if (!orgChartData) return;

          const currentOrg = dataFiles.organization.find(o => o.ORGID === unitFilter);
          const currentType = currentOrg ? (currentOrg.Type || '').toUpperCase() : '';
          const isWing = currentType.includes('WING');
          const isGroup = currentType.includes('GROUP');

          if (showCommandChainOnly && (isWing || isGroup)) {
            const ids = new Set([orgChartData.id]);

            if (isWing) {
              // Wing: Expand root AND group commanders (to show squadron commanders)
              // But do NOT expand squadron commanders (so their deputies/cadet chain stay hidden)
              (orgChartData.children || []).forEach(child => {
                if (child.id.startsWith('group_cmdr_')) {
                  ids.add(child.id);
                }
              });
            }
            // Group: Only expand root, leave squadron commanders collapsed

            setExpandedSections(ids);
          } else {
            const allIds = getAllNodeIds(orgChartData);
            setExpandedSections(new Set(allIds));
          }
        }, [orgChartData, dataFiles.organization, unitFilter, showCommandChainOnly]);

        const toggleExpandCollapse = () => {
          if (!orgChartData) return;
          const allIds = getAllNodeIds(orgChartData);
          const isFullyExpanded = expandedSections.size === allIds.length;
          if (isFullyExpanded) setExpandedSections(new Set());
          else setExpandedSections(new Set(allIds));
        };

        const handleDragStart = (e, node) => {
          setDraggedNode(node);
          e.dataTransfer.effectAllowed = 'move';
        };

        const handleDrop = (e, targetNode) => {
          e.preventDefault();
          if (!draggedNode || draggedNode.id === targetNode.id) return;
          // Future: Implement custom org chart reorganization
        };

        const addNode = (parentId) => {
          // Future: Implement adding custom positions
        };

        const deleteNode = (nodeId) => {
          // Future: Implement removing positions
        };

        // Format last updated (remove seconds)
        const formatSyncTime = (isoString) => {
            if (!isoString) return 'N/A';
            const d = new Date(isoString);
            return d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) + 
                   (d.toDateString() !== new Date().toDateString() ? ` (${d.toLocaleDateString()})` : '');
        };

        const handleDownloadImage = async (format = 'png') => {
          const canvas = document.getElementById('org-chart-canvas');
          if (!canvas) {
            alert('Unable to find organization chart to export');
            return;
          }

          // Show loading indicator
          const loadingMsg = document.createElement('div');
          loadingMsg.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.8);color:white;padding:20px 40px;border-radius:8px;z-index:10000;font-size:16px;';
          loadingMsg.textContent = `Generating ${format.toUpperCase()}...`;
          document.body.appendChild(loadingMsg);

          try {
            // Temporarily remove scroll bars and expand container for capture
            const originalOverflow = canvas.style.overflow;
            const originalWidth = canvas.style.width;
            const originalHeight = canvas.style.height;

            canvas.style.overflow = 'visible';
            canvas.style.width = 'auto';
            canvas.style.height = 'auto';

            // Wait for layout to settle
            await new Promise(resolve => setTimeout(resolve, 100));

            // Capture with high quality settings
            const htmlCanvas = await html2canvas(canvas, {
              backgroundColor: '#ffffff',
              scale: 3, // Higher quality
              logging: false,
              useCORS: true,
              allowTaint: false,
              scrollX: 0,
              scrollY: 0,
              windowWidth: canvas.scrollWidth,
              windowHeight: canvas.scrollHeight,
              onclone: (clonedDoc) => {
                // Ensure all styles are preserved in clone
                const clonedCanvas = clonedDoc.getElementById('org-chart-canvas');
                if (clonedCanvas) {
                  clonedCanvas.style.overflow = 'visible';
                  clonedCanvas.style.minHeight = 'auto';
                  clonedCanvas.style.width = 'auto';
                  clonedCanvas.style.height = 'auto';

                  // Ensure background pattern is visible
                  clonedCanvas.style.background = 'radial-gradient(#e5e7eb 1px, transparent 1px)';
                  clonedCanvas.style.backgroundSize = '20px 20px';
                }
              }
            });

            // Restore original styles
            canvas.style.overflow = originalOverflow;
            canvas.style.width = originalWidth;
            canvas.style.height = originalHeight;

            if (format === 'pdf') {
              await exportOrgChartToPDF(htmlCanvas);
            } else {
              exportOrgChartToPNG(htmlCanvas);
            }
          } catch (error) {
            console.error('Error generating export:', error);
            alert('Error generating export. Please try again.');
          } finally {
            document.body.removeChild(loadingMsg);
          }
        };

        const exportOrgChartToPNG = (htmlCanvas) => {
          // Create high-quality PNG
          const imgData = htmlCanvas.toDataURL('image/png', 1.0);
          const link = document.createElement('a');
          const currentUnit = availableUnits.find(u => u.id === unitFilter);
          const unitNum = currentUnit?.unitNum || '000';
          const date = new Date().toISOString().split('T')[0];
          link.download = `org-chart-unit-${unitNum}-${date}.png`;
          link.href = imgData;
          link.click();
        };

        const exportOrgChartToPDF = async (htmlCanvas) => {
          const { jsPDF } = window.jspdf;
          if (!jsPDF) {
            alert('PDF library not loaded. Please refresh and try again.');
            return;
          }

          const imgWidth = htmlCanvas.width;
          const imgHeight = htmlCanvas.height;

          // Constants for PDF sizing (in mm)
          const A4_WIDTH = 210;
          const A4_HEIGHT = 297;
          const MARGIN = 15;
          const HEADER_HEIGHT = 30;

          // Determine if we need landscape
          const isWide = imgWidth > imgHeight;
          const pageWidth = isWide ? A4_HEIGHT : A4_WIDTH;
          const pageHeight = isWide ? A4_WIDTH : A4_HEIGHT;

          const pdf = new jsPDF({
            orientation: isWide ? 'landscape' : 'portrait',
            unit: 'mm',
            format: 'a4',
            compress: true
          });

          // Add header with metadata
          const currentUnit = availableUnits.find(u => u.id === unitFilter);
          const unitText = currentUnit ? currentUnit.name : `Unit ${unitFilter}`;

          pdf.setFontSize(14);
          pdf.setFont(undefined, 'bold');
          pdf.text('Organization Chart', pageWidth / 2, MARGIN, { align: 'center' });

          pdf.setFontSize(10);
          pdf.setFont(undefined, 'normal');
          pdf.text(`${unitText}${showAllDescendants ? ' (with sub-units)' : ''}`, pageWidth / 2, MARGIN + 6, { align: 'center' });
          pdf.text(`Generated: ${new Date().toLocaleString()}`, pageWidth / 2, MARGIN + 11, { align: 'center' });

          // Calculate available space for chart
          const availableWidth = pageWidth - (2 * MARGIN);
          const availableHeight = pageHeight - HEADER_HEIGHT - (2 * MARGIN);

          // Convert image dimensions from pixels to mm (assuming 96 DPI)
          const pixelsToMm = 0.264583;
          const imgWidthMm = imgWidth * pixelsToMm;
          const imgHeightMm = imgHeight * pixelsToMm;

          // Determine if we need multiple pages
          const scaleToFitWidth = availableWidth / imgWidthMm;
          const scaleToFitHeight = availableHeight / imgHeightMm;
          const scale = Math.min(scaleToFitWidth, scaleToFitHeight, 1); // Don't scale up

          const finalWidth = imgWidthMm * scale;
          const finalHeight = imgHeightMm * scale;

          // Check if chart fits on one page
          const fitsOnOnePage = finalWidth <= availableWidth && finalHeight <= availableHeight;

          if (fitsOnOnePage) {
            // Single page - center the chart
            const xOffset = MARGIN + (availableWidth - finalWidth) / 2;
            const yOffset = HEADER_HEIGHT + MARGIN;

            const imgData = htmlCanvas.toDataURL('image/png', 0.95);
            pdf.addImage(imgData, 'PNG', xOffset, yOffset, finalWidth, finalHeight, undefined, 'FAST');
          } else {
            // Chart is too large - create tiled pages
            const pagesWide = Math.ceil(finalWidth / availableWidth);
            const pagesTall = Math.ceil(finalHeight / availableHeight);

            // Add warning on first page
            pdf.setFontSize(9);
            pdf.setTextColor(200, 0, 0);
            pdf.text(`Note: Chart spans ${pagesWide}  ${pagesTall} pages`, pageWidth / 2, MARGIN + 16, { align: 'center' });
            pdf.setTextColor(0, 0, 0);

            const imgData = htmlCanvas.toDataURL('image/png', 0.95);

            // Create a temporary canvas for tiling
            const tileCanvas = document.createElement('canvas');
            const tileCtx = tileCanvas.getContext('2d');
            const img = new Image();

            await new Promise((resolve) => {
              img.onload = () => {
                for (let row = 0; row < pagesTall; row++) {
                  for (let col = 0; col < pagesWide; col++) {
                    if (row > 0 || col > 0) {
                      pdf.addPage();
                      // Add header on each page
                      pdf.setFontSize(10);
                      pdf.setFont(undefined, 'bold');
                      pdf.text(`${unitText} - Page ${row * pagesWide + col + 1} of ${pagesWide * pagesTall}`, pageWidth / 2, MARGIN, { align: 'center' });
                    }

                    // Calculate source rectangle in original image
                    const srcX = col * (imgWidth / pagesWide);
                    const srcY = row * (imgHeight / pagesTall);
                    const srcWidth = Math.min(imgWidth / pagesWide, imgWidth - srcX);
                    const srcHeight = Math.min(imgHeight / pagesTall, imgHeight - srcY);

                    // Set tile canvas size
                    tileCanvas.width = srcWidth;
                    tileCanvas.height = srcHeight;

                    // Draw the tile
                    tileCtx.drawImage(img, srcX, srcY, srcWidth, srcHeight, 0, 0, srcWidth, srcHeight);

                    // Convert tile to data URL and add to PDF
                    const tileData = tileCanvas.toDataURL('image/png', 0.95);
                    const tileWidthMm = (srcWidth * pixelsToMm * scale);
                    const tileHeightMm = (srcHeight * pixelsToMm * scale);

                    pdf.addImage(tileData, 'PNG', MARGIN, HEADER_HEIGHT + MARGIN, tileWidthMm, tileHeightMm, undefined, 'FAST');
                  }
                }
                resolve();
              };
              img.src = imgData;
            });
          }

          // Save PDF
          const unitNum = currentUnit?.unitNum || '000';
          const date = new Date().toISOString().split('T')[0];
          pdf.save(`org-chart-unit-${unitNum}-${date}.pdf`);
        };

        // PDF Export Functions for Reports
        const detectOrientation = (report) => {
            const landscapeReports = [
              'promotion-requirements',
              'aerospace-education',
              'encampment-status',
              'near-promotion',
              'promotion',
              'tlc-compliance'
            ];

          if (report.data && report.data.length > 0) {
            const columnCount = Object.keys(report.data[0]).length;
            if (columnCount > 6 || landscapeReports.includes(report.type)) {
              return 'landscape';
            }
          }
          return 'portrait';
        };

        const generateFilename = (report) => {
          const currentUnit = availableUnits.find(u => u.id === unitFilter);
          const unitNum = currentUnit?.unitNum || '000';
          const reportSlug = report.title
            .toLowerCase()
            .replace(/[^a-z0-9]+/g, '-')
            .replace(/^-|-$/g, '');
          const date = new Date().toISOString().split('T')[0];

          return `unit-${unitNum}-${reportSlug}-${date}.pdf`;
        };

        const addPDFHeader = (pdf, report) => {
          let yPos = 15;

          // Title
          pdf.setFontSize(16);
          pdf.setFont(undefined, 'bold');
          pdf.text(report.title, pdf.internal.pageSize.getWidth() / 2, yPos, { align: 'center' });
          yPos += 8;

          // Unit info
          pdf.setFontSize(10);
          pdf.setFont(undefined, 'normal');
          const currentUnit = availableUnits.find(u => u.id === unitFilter);
          const unitText = currentUnit ? currentUnit.name : unitFilter;
          const subUnitText = showAllDescendants ? ' (including sub-units)' : '';
          pdf.text(`Unit: ${unitText}${subUnitText}`, 15, yPos);
          yPos += 5;

          // Data sync timestamp
          pdf.text(`Data as of: ${formatSyncTime(lastUpdated)}`, 15, yPos);
          yPos += 5;

          // Generation timestamp
          pdf.text(`Generated: ${new Date().toLocaleString()}`, 15, yPos);

          return yPos + 10;
        };

        const renderTableReport = (pdf, report, startY) => {
          if (!report.data || report.data.length === 0) {
            pdf.setFontSize(12);
            pdf.text('No data to display', 15, startY);
            return;
          }

          const formatRequirementStatus = (value) => {
            if (value === null || value === undefined) return 'N/A';
            return value ? 'Yes' : 'No';
          };

          const formatAchievement = (name, phase) => {
            if (!name) return '';
            if (!phase || phase === 'Complete' || name === 'Completed All') return name;
            return `${name} (${phase})`;
          };

          const formatProgress = (row) => {
            if (!row || !row.progress) return '';
            if (row.progress === 'Complete' || row.progress === 'N/A') return row.progress;
            if (Number.isFinite(row.percentComplete)) return `${row.progress} (${row.percentComplete}%)`;
            return row.progress;
          };

          // Define column configurations for each report type
          const columnConfigs = {
            'approval': [
              { header: 'Member', dataKey: 'memberName' },
              { header: 'Rank', dataKey: 'rank' },
              { header: 'CAPID', dataKey: 'capid' },
              { header: 'Unit', dataKey: 'unit' },
              { header: 'Level', dataKey: 'levelName' },
              { header: 'Status', dataKey: 'status' }
            ],
            'promotion': [
              { header: 'Member', dataKey: 'memberName' },
              { header: 'CAPID', dataKey: 'capid' },
              { header: 'Current Rank', dataKey: 'rank' },
              { header: 'Next Rank', dataKey: 'nextRank' },
              { header: 'TIG', dataKey: 'tigDisplay' },
              { header: 'Level', dataKey: 'levelDisplay' },
              { header: 'Duty', dataKey: 'dutyStatus' }
            ],
            'near-promotion': [
              { header: 'Member', dataKey: 'memberName' },
              { header: 'CAPID', dataKey: 'capid' },
              { header: 'Rank', dataKey: 'rank' },
              { header: 'Next Rank', dataKey: 'nextRank' },
              { header: 'TIG Status', dataKey: 'tigStatus' },
              { header: 'Tasks Remaining', dataKey: 'tasksRemaining' },
              { header: 'Duty Status', dataKey: 'dutyStatus' }
            ],
            'cadet-no-promotion': [
              { header: 'Cadet Name', dataKey: 'memberName' },
              { header: 'CAPID', dataKey: 'capid' },
              { header: 'Unit', dataKey: 'unit' },
              { header: 'Rank', dataKey: 'rank' },
              { header: 'Last Promotion', dataKey: 'lastPromotion' },
              { header: 'Days Since', dataKey: 'daysSince' }
            ],
            'membership-lapse': [
              { header: 'Member Name', dataKey: 'memberName' },
              { header: 'CAPID', dataKey: 'capid' },
              { header: 'Unit', dataKey: 'unit' },
              { header: 'Type', dataKey: 'memberType' },
              { header: 'Rank', dataKey: 'rank' },
              { header: 'Expiration', dataKey: 'expiration' },
              { header: 'Days Until', dataKey: 'daysUntil' }
            ],
            'cadet-protection': [
              { header: 'Member', dataKey: 'memberName' },
              { header: 'CAPID', dataKey: 'capid' },
              { header: 'Unit', dataKey: 'unit' },
              { header: 'Type', dataKey: 'memberType' },
              { header: 'Rank', dataKey: 'rank' },
              { header: 'Course', dataKey: 'course' },
              { header: 'Requirement', dataKey: 'requirement' },
              { header: 'Status', dataKey: 'status' },
              { header: 'Last Completed', dataKey: 'lastCompleted' },
              { header: 'Expiration', dataKey: 'expiration' },
              { header: 'Days', dataKey: 'daysText' }
            ],
            'aerospace-education': [
              { header: 'Cadet Name', dataKey: 'memberName' },
              { header: 'CAPID', dataKey: 'capid' },
              { header: 'Unit', dataKey: 'unit' },
              { header: 'Rank', dataKey: 'rank' },
              { header: 'M1 Interactive', dataKey: (row) => row.module1?.interactiveCompleted ? (row.module1.interactiveDate || '') : '' },
              { header: 'M1 Test', dataKey: (row) => row.module1?.testCompleted ? `${row.module1.testScore}% (${row.module1.testDate})` : '' },
              { header: 'M2 Interactive', dataKey: (row) => row.module2?.interactiveCompleted ? (row.module2.interactiveDate || '') : '' },
              { header: 'M2 Test', dataKey: (row) => row.module2?.testCompleted ? `${row.module2.testScore}% (${row.module2.testDate})` : '' },
              { header: 'M3 Interactive', dataKey: (row) => row.module3?.interactiveCompleted ? (row.module3.interactiveDate || '') : '' },
              { header: 'M3 Test', dataKey: (row) => row.module3?.testCompleted ? `${row.module3.testScore}% (${row.module3.testDate})` : '' },
              { header: 'M4 Interactive', dataKey: (row) => row.module4?.interactiveCompleted ? (row.module4.interactiveDate || '') : '' },
              { header: 'M4 Test', dataKey: (row) => row.module4?.testCompleted ? `${row.module4.testScore}% (${row.module4.testDate})` : '' },
              { header: 'M5 Interactive', dataKey: (row) => row.module5?.interactiveCompleted ? (row.module5.interactiveDate || '') : '' },
              { header: 'M5 Test', dataKey: (row) => row.module5?.testCompleted ? `${row.module5.testScore}% (${row.module5.testDate})` : '' },
              { header: 'M6 Interactive', dataKey: (row) => row.module6?.interactiveCompleted ? (row.module6.interactiveDate || '') : '' },
              { header: 'M6 Test', dataKey: (row) => row.module6?.testCompleted ? `${row.module6.testScore}% (${row.module6.testDate})` : '' },
              { header: 'M7 Interactive', dataKey: (row) => row.module7?.interactiveCompleted ? (row.module7.interactiveDate || '') : '' },
              { header: 'M7 Test', dataKey: (row) => row.module7?.testCompleted ? `${row.module7.testScore}% (${row.module7.testDate})` : '' }
            ],
            'encampment-status': [
              { header: 'Cadet Name', dataKey: 'memberName' },
              { header: 'CAPID', dataKey: 'capid' },
              { header: 'Unit', dataKey: 'unit' },
              { header: 'Rank', dataKey: 'rank' },
              { header: 'Encampment', dataKey: 'encampmentStatus' },
              { header: 'Date', dataKey: 'completionDate' }
            ],
            'oflight-status': [
              { header: 'Cadet Name', dataKey: 'memberName' },
              { header: 'CAPID', dataKey: 'capid' },
              { header: 'Unit', dataKey: 'unit' },
              { header: 'Join Date', dataKey: 'joinDate' },
              { header: 'Age', dataKey: 'age' },
              { header: '6', dataKey: (row) => row.syllabus6?.completed ? (row.syllabus6.date || '') : '' },
              { header: '7', dataKey: (row) => row.syllabus7?.completed ? (row.syllabus7.date || '') : '' },
              { header: '8', dataKey: (row) => row.syllabus8?.completed ? (row.syllabus8.date || '') : '' },
              { header: '9', dataKey: (row) => row.syllabus9?.completed ? (row.syllabus9.date || '') : '' },
              { header: '10', dataKey: (row) => row.syllabus10?.completed ? (row.syllabus10.date || '') : '' },
              { header: 'Total', dataKey: (row) => row.backSeatRides > 0 ? `${row.totalPoweredFlights} (+${row.backSeatRides})` : String(row.totalPoweredFlights) }
            ],
            'recent-promotions': [
              { header: 'Member Name', dataKey: 'memberName' },
              { header: 'CAPID', dataKey: 'capid' },
              { header: 'Unit', dataKey: 'unit' },
              { header: 'New Rank', dataKey: 'rank' },
              { header: 'Date', dataKey: 'promotionDate' }
            ],
            'promotion-requirements': [
              { header: 'Cadet', dataKey: 'memberName' },
              { header: 'CAPID', dataKey: 'capid' },
              { header: 'Unit', dataKey: 'unit' },
              { header: 'Rank', dataKey: 'rank' },
              { header: 'Current', dataKey: (row) => formatAchievement(row.currentAchievement, row.currentPhase) },
              { header: 'Next', dataKey: (row) => formatAchievement(row.nextAchievement, row.nextPhase) },
              { header: 'Leadership', dataKey: (row) => formatRequirementStatus(row.leadership) },
              { header: 'Aerospace', dataKey: (row) => formatRequirementStatus(row.aerospace) },
              { header: 'Fitness', dataKey: (row) => formatRequirementStatus(row.fitness) },
              { header: 'Character', dataKey: (row) => formatRequirementStatus(row.character) },
              { header: 'Activity/Special', dataKey: (row) => formatRequirementStatus(row.activity) },
              { header: 'Progress', dataKey: (row) => formatProgress(row) }
            ],
            'approaching-age-milestone': [
              { header: 'Cadet Name', dataKey: 'memberName' },
              { header: 'CAPID', dataKey: 'capid' },
              { header: 'Unit', dataKey: 'unit' },
              { header: 'Rank', dataKey: 'rank' },
              { header: 'DOB', dataKey: 'dob' },
              { header: 'Current Age', dataKey: 'currentAge' },
              { header: 'Milestone', dataKey: 'milestoneLabel' },
              { header: 'Milestone Date', dataKey: 'milestoneDate' },
              { header: 'Days Until', dataKey: 'daysUntil' }
            ],
            'tlc-compliance': (report) => {
              const isUnitSummary = report.meta && report.meta.view === 'unit-summary';
              if (isUnitSummary) {
                return [
                  { header: 'Unit', dataKey: 'unit' },
                  { header: 'Qualified', dataKey: 'qualified' },
                  { header: 'Required', dataKey: 'required' },
                  { header: 'Status', dataKey: 'compliance' },
                  { header: 'Current', dataKey: 'current' },
                  { header: 'Due Soon', dataKey: 'dueSoon' },
                  { header: 'Expired', dataKey: 'expired' },
                  { header: 'Missing', dataKey: 'missing' },
                  { header: 'Total Seniors', dataKey: 'totalMembers' }
                ];
              }
              return [
                { header: 'Member', dataKey: 'memberName' },
                { header: 'CAPID', dataKey: 'capid' },
                { header: 'Unit', dataKey: 'unit' },
                { header: 'Rank', dataKey: 'rank' },
                { header: 'Duties', dataKey: 'dutySummary' },
                { header: 'TLC Course', dataKey: 'course' },
                { header: 'Status', dataKey: 'status' },
                { header: 'Completed', dataKey: 'completed' },
                { header: 'Expires', dataKey: 'expiration' },
                { header: 'Days', dataKey: 'daysText' }
              ];
            },
            'recruiting-trends': [
              { header: 'Month', dataKey: 'month' },
              { header: 'New', dataKey: 'totalNew' },
              { header: 'Rejoin', dataKey: 'totalRejoin' },
              { header: 'Total', dataKey: 'totalRecruited' },
              { header: 'Members', dataKey: 'totalMembers' }
            ],
            'retention-analysis': [
              { header: 'Member', dataKey: 'memberName' },
              { header: 'CAPID', dataKey: 'capid' },
              { header: 'Type', dataKey: 'memberType' },
              { header: 'Unit', dataKey: 'unit' },
              { header: 'Expires', dataKey: 'expiration' },
              { header: 'Days', dataKey: 'daysUntil' }
            ]
            };

            const config = columnConfigs[report.type];
            const columns = (typeof config === 'function' ? config(report) : config) ||
              Object.keys(report.data[0]).map(key => ({
                header: key.replace(/([A-Z])/g, ' $1').trim(),
                dataKey: key
              }));

          pdf.autoTable({
            startY,
            head: [columns.map(c => c.header)],
            body: report.data.map(row => columns.map(c => {
              const value = typeof c.dataKey === 'function' ? c.dataKey(row) : row[c.dataKey];
              if (typeof value === 'boolean') return value ? '' : '';
              if (value === null || value === undefined) return '';
              return String(value);
            })),
            styles: {
              fontSize: 8,
              cellPadding: 2
            },
            headStyles: {
              fillColor: [71, 85, 105],
              textColor: 255,
              fontStyle: 'bold',
              fontSize: 9
            },
            alternateRowStyles: {
              fillColor: [248, 250, 252]
            },
            margin: { left: 15, right: 15 },
            theme: 'grid'
          });
        };

        const renderTrainingReport = (pdf, report, startY) => {
          let yPos = startY;

          report.data.forEach((item, idx) => {
            if (yPos > pdf.internal.pageSize.getHeight() - 40) {
              pdf.addPage();
              yPos = 20;
            }

            pdf.setFontSize(11);
            pdf.setFont(undefined, 'bold');
            pdf.text(`${idx + 1}. ${item.taskName}`, 15, yPos);
            yPos += 6;

            pdf.setFontSize(8);
            pdf.setFont(undefined, 'normal');
            pdf.text(`Level: ${item.level} | Group: ${item.groupName}`, 20, yPos);
            yPos += 5;

            pdf.text(`Needed by: ${item.neededByCount} members (${item.percentageOfUnit}% of unit)`, 20, yPos);
            yPos += 5;

            if (item.description) {
              const descLines = pdf.splitTextToSize(item.description, 170);
              pdf.text(descLines, 20, yPos);
              yPos += descLines.length * 4;
            }

            yPos += 8;
          });
        };

        const renderDiscrepanciesReport = (pdf, report, startY) => {
          let yPos = startY;

          report.data.forEach((item, idx) => {
            if (yPos > pdf.internal.pageSize.getHeight() - 40) {
              pdf.addPage();
              yPos = 20;
            }

            pdf.setFontSize(10);
            pdf.setFont(undefined, 'bold');
            pdf.text(`${item.memberName} (${item.capid})`, 15, yPos);
            yPos += 5;

            pdf.setFontSize(8);
            pdf.setFont(undefined, 'normal');
            pdf.text(`Rank: ${item.rank}`, 20, yPos);
            yPos += 5;

            pdf.setFont(undefined, 'bold');
            pdf.text('Issues:', 20, yPos);
            yPos += 5;

            pdf.setFont(undefined, 'normal');
            if (item.issues && item.issues.length > 0) {
              item.issues.forEach(issue => {
                const issueText = `- ${issue.duty} requires ${issue.requiredTrack} track`;
                const issueLines = pdf.splitTextToSize(issueText, 165);
                pdf.text(issueLines, 25, yPos);
                yPos += issueLines.length * 5;
              });
            }

            yPos += 8;
          });
        };

        const renderAerospaceEducationReport = (pdf, report, startY) => {
          let yPos = startY;
          const pageWidth = pdf.internal.pageSize.getWidth();
          const pageHeight = pdf.internal.pageSize.getHeight();
          const marginLeft = 10;
          const marginRight = 10;
          const marginBottom = 15;
          const availableWidth = pageWidth - marginLeft - marginRight;
          const headerHeight = 12;
          const rowHeight = 12;
          const cellPaddingX = 1.5;
          const completeMark = 'OK';
          const incompleteMark = '--';
          const honorMark = '*';

          const colWidths = {
            name: 50,
            capid: 22,
            module: 0
          };
          const fixedWidth = colWidths.name + colWidths.capid;
          colWidths.module = (availableWidth - fixedWidth) / 7;

          const trimTextToWidth = (text, maxWidth) => {
            if (!text) return '';
            if (pdf.getTextWidth(text) <= maxWidth) return text;
            const ellipsis = '...';
            let trimmed = text;
            while (trimmed.length > 0 && pdf.getTextWidth(trimmed + ellipsis) > maxWidth) {
              trimmed = trimmed.slice(0, -1);
            }
            return trimmed ? trimmed + ellipsis : '';
          };

          const formatDateShort = (value) => {
            if (!value) return '';
            const raw = String(value).trim();
            if (!raw) return '';
            let match = raw.match(/^(\d{4})-(\d{1,2})-(\d{1,2})/);
            let year;
            let month;
            let day;
            if (match) {
              year = Number(match[1]);
              month = Number(match[2]);
              day = Number(match[3]);
            } else {
              match = raw.match(/^(\d{1,2})\/(\d{1,2})\/(\d{2,4})/);
              if (match) {
                month = Number(match[1]);
                day = Number(match[2]);
                year = Number(match[3]);
              } else {
                const parsed = new Date(raw);
                if (Number.isNaN(parsed.getTime())) {
                  return raw;
                }
                month = parsed.getMonth() + 1;
                day = parsed.getDate();
                year = parsed.getFullYear();
              }
            }
            if (!year || !month || !day) return raw;
            const yy = String(year).slice(-2);
            const mm = String(month).padStart(2, '0');
            const dd = String(day).padStart(2, '0');
            return `${mm}/${dd}/${yy}`;
          };

          pdf.setFontSize(7);
          pdf.setFont(undefined, 'normal');
          pdf.text('Legend: I=Interactive, T=Test, OK=Completed, --=Not started, *=Honor credit, Dates=MM/DD/YY', marginLeft, yPos);
          yPos += 6;

          const drawHeader = (topY) => {
            let xPos = marginLeft;
            const headerBaseline = topY + 8;
            const subHeaderY = topY + 10;

            pdf.setFillColor(244, 247, 252);
            pdf.rect(marginLeft, topY, availableWidth, headerHeight, 'F');

            pdf.setFontSize(8);
            pdf.setFont(undefined, 'bold');
            pdf.text('Cadet Name', xPos + cellPaddingX, headerBaseline);
            xPos += colWidths.name;
            pdf.text('CAPID', xPos + cellPaddingX, headerBaseline);
            xPos += colWidths.capid;

            for (let i = 1; i <= 7; i++) {
              pdf.text(`M${i}`, xPos + colWidths.module / 2, headerBaseline, { align: 'center' });
              xPos += colWidths.module;
            }

            pdf.setFontSize(6);
            pdf.setFont(undefined, 'normal');
            xPos = marginLeft + colWidths.name + colWidths.capid;
            for (let i = 1; i <= 7; i++) {
              pdf.text('I', xPos + colWidths.module * 0.25, subHeaderY);
              pdf.text('T', xPos + colWidths.module * 0.75, subHeaderY);
              xPos += colWidths.module;
            }

            pdf.setDrawColor(210);
            pdf.line(marginLeft, topY + headerHeight, pageWidth - marginRight, topY + headerHeight);
            return topY + headerHeight + 2;
          };

          const drawModuleCell = (module, x, topY) => {
            const half = colWidths.module / 2;
            const primaryY = topY + 4.5;
            const secondaryY = topY + 8.5;
            const interactiveDate = formatDateShort(module.interactiveDate);
            const testDate = formatDateShort(module.testDate);
            const leftCenterX = x + half / 2;
            const rightCenterX = x + half + half / 2;

            pdf.setDrawColor(220);
            pdf.setFillColor(module.interactiveCompleted ? 221 : 248, module.interactiveCompleted ? 243 : 248, module.interactiveCompleted ? 236 : 248);
            pdf.rect(x, topY, half, rowHeight, 'F');
            pdf.setFillColor(module.testCompleted ? 224 : 248, module.testCompleted ? 231 : 248, module.testCompleted ? 255 : 248);
            pdf.rect(x + half, topY, half, rowHeight, 'F');

            pdf.setDrawColor(220);
            pdf.rect(x, topY, colWidths.module, rowHeight);
            pdf.line(x + half, topY, x + half, topY + rowHeight);

            pdf.setFontSize(6);
            pdf.setFont(undefined, 'bold');
            pdf.setTextColor(module.interactiveCompleted ? 34 : 160, module.interactiveCompleted ? 139 : 160, module.interactiveCompleted ? 34 : 160);
            pdf.text(module.interactiveCompleted ? completeMark : incompleteMark, leftCenterX, primaryY, { align: 'center' });
            if (interactiveDate) {
              pdf.setFont(undefined, 'normal');
              pdf.text(trimTextToWidth(interactiveDate, half - 2), leftCenterX, secondaryY, { align: 'center' });
            }

            pdf.setFontSize(6);
            pdf.setFont(undefined, 'bold');
            pdf.setTextColor(module.testCompleted ? 25 : 160, module.testCompleted ? 118 : 160, module.testCompleted ? 210 : 160);
            if (module.testCompleted) {
              pdf.text(`${module.testScore}%`, rightCenterX, primaryY, { align: 'center' });
            } else {
              pdf.text(incompleteMark, rightCenterX, primaryY, { align: 'center' });
            }
            if (testDate) {
              pdf.setFont(undefined, 'normal');
              pdf.text(trimTextToWidth(testDate, half - 2), rightCenterX, secondaryY, { align: 'center' });
            }

            pdf.setTextColor(0);
          };

          yPos = drawHeader(yPos);

          report.data.forEach((cadet, idx) => {
            if (yPos + rowHeight > pageHeight - marginBottom) {
              pdf.addPage();
              yPos = 20;
              yPos = drawHeader(yPos);
            }

            if (idx % 2 === 1) {
              pdf.setFillColor(250, 251, 252);
              pdf.rect(marginLeft, yPos, availableWidth, rowHeight, 'F');
            }

            let xPos = marginLeft;

            pdf.setFontSize(7);
            pdf.setFont(undefined, 'normal');
            const nameText = trimTextToWidth(cadet.memberName, colWidths.name - 2);
            pdf.text(nameText, xPos + cellPaddingX, yPos + 7);
            xPos += colWidths.name;

            pdf.setFontSize(6.5);
            pdf.text(trimTextToWidth(String(cadet.capid), colWidths.capid - 2), xPos + cellPaddingX, yPos + 7);
            xPos += colWidths.capid;

            for (let i = 1; i <= 7; i++) {
              const module = cadet[`module${i}`] || {
                interactiveCompleted: false,
                interactiveDate: '',
                testCompleted: false,
                testScore: '',
                testDate: '',
                honorCredit: false
              };
              drawModuleCell(module, xPos, yPos);
              if (module.honorCredit) {
                pdf.setTextColor(255, 191, 0);
                pdf.setFontSize(7);
                pdf.text(honorMark, xPos + colWidths.module - 3, yPos + 3);
                pdf.setTextColor(0);
              }
              xPos += colWidths.module;
            }

            pdf.setDrawColor(235);
            pdf.line(marginLeft, yPos + rowHeight, pageWidth - marginRight, yPos + rowHeight);
            yPos += rowHeight + 1;
          });
        };

        const renderOFlightReport = (pdf, report, startY) => {
          let yPos = startY;
          const pageWidth = pdf.internal.pageSize.getWidth();

          // Calculate statistics
          const stats = (report.data || []).reduce((acc, row) => {
            acc.totalCadets += 1;
            if (!row.hasAnyFlight) acc.noFlights += 1;
            if (row.completedSyllabi === 5) acc.allComplete += 1;
            acc.totalPoweredFlights += row.totalPoweredFlights || 0;
            acc.totalBackSeat += row.backSeatRides || 0;
            for (let i = 6; i <= 10; i++) {
              if (row[`syllabus${i}`]?.completed) acc[`syl${i}`] = (acc[`syl${i}`] || 0) + 1;
            }
            return acc;
          }, { totalCadets: 0, noFlights: 0, allComplete: 0, totalPoweredFlights: 0, totalBackSeat: 0, syl6: 0, syl7: 0, syl8: 0, syl9: 0, syl10: 0 });

          const participationRate = stats.totalCadets > 0 ? Math.round(((stats.totalCadets - stats.noFlights) / stats.totalCadets) * 100) : 0;

          // Help text / legend
          pdf.setFontSize(8);
          pdf.setFont(undefined, 'normal');
          pdf.text('Syllabus Legend:', 15, yPos);
          yPos += 4;
          pdf.setFontSize(7);
          pdf.text('6: Ground Handling, Preflight, Takeoff & Landing  |  7: Normal Flight Maneuvers  |  8: Advanced Flight Maneuvers', 15, yPos);
          yPos += 3.5;
          pdf.text('9: Use of Instruments in Flight  |  10: Weather  |  Highlighted rows = No O-Flights yet', 15, yPos);
          yPos += 6;

          // Summary statistics
          pdf.setFontSize(9);
          pdf.setFont(undefined, 'bold');
          pdf.text('Summary Statistics', 15, yPos);
          yPos += 5;

          pdf.setFontSize(8);
          pdf.setFont(undefined, 'normal');
          const statsLine1 = `Total Cadets: ${stats.totalCadets}  |  No O-Flights: ${stats.noFlights}  |  All 5 Complete: ${stats.allComplete}  |  Participation Rate: ${participationRate}%`;
          pdf.text(statsLine1, 15, yPos);
          yPos += 4;

          const statsLine2 = `Total Powered Flights: ${stats.totalPoweredFlights}  |  Back Seat Rides: ${stats.totalBackSeat}`;
          pdf.text(statsLine2, 15, yPos);
          yPos += 5;

          // Syllabus breakdown
          const sylBreakdown = `Syllabus Completion:  6: ${stats.syl6}  |  7: ${stats.syl7}  |  8: ${stats.syl8}  |  9: ${stats.syl9}  |  10: ${stats.syl10}`;
          pdf.text(sylBreakdown, 15, yPos);
          yPos += 8;

          // Table with centered syllabus columns
          if (!report.data || report.data.length === 0) {
            pdf.setFontSize(10);
            pdf.text('No cadet data available.', 15, yPos);
            return;
          }

          const columns = [
            { header: 'Cadet Name', dataKey: 'memberName' },
            { header: 'CAPID', dataKey: 'capid' },
            { header: 'Unit', dataKey: 'unit' },
            { header: 'Join Date', dataKey: 'joinDate' },
            { header: 'Age', dataKey: 'age' },
            { header: '6', dataKey: (row) => row.syllabus6?.completed ? (row.syllabus6.date || '') : '' },
            { header: '7', dataKey: (row) => row.syllabus7?.completed ? (row.syllabus7.date || '') : '' },
            { header: '8', dataKey: (row) => row.syllabus8?.completed ? (row.syllabus8.date || '') : '' },
            { header: '9', dataKey: (row) => row.syllabus9?.completed ? (row.syllabus9.date || '') : '' },
            { header: '10', dataKey: (row) => row.syllabus10?.completed ? (row.syllabus10.date || '') : '' },
            { header: 'Total', dataKey: (row) => row.backSeatRides > 0 ? `${row.totalPoweredFlights} (+${row.backSeatRides})` : String(row.totalPoweredFlights) }
          ];

          pdf.autoTable({
            startY: yPos,
            head: [columns.map(c => c.header)],
            body: report.data.map(row => columns.map(c => {
              const value = typeof c.dataKey === 'function' ? c.dataKey(row) : row[c.dataKey];
              if (value === null || value === undefined) return '';
              return String(value);
            })),
            styles: {
              fontSize: 7,
              cellPadding: 1.5
            },
            headStyles: {
              fillColor: [14, 116, 144], // sky-700
              textColor: 255,
              fontStyle: 'bold',
              fontSize: 8,
              halign: 'center'
            },
            columnStyles: {
              0: { cellWidth: 'auto' }, // Cadet Name
              1: { cellWidth: 20 }, // CAPID
              2: { cellWidth: 22 }, // Unit
              3: { cellWidth: 18 }, // Join Date
              4: { cellWidth: 10, halign: 'center' }, // Age
              5: { cellWidth: 18, halign: 'center' }, // Syllabus 6
              6: { cellWidth: 18, halign: 'center' }, // Syllabus 7
              7: { cellWidth: 18, halign: 'center' }, // Syllabus 8
              8: { cellWidth: 18, halign: 'center' }, // Syllabus 9
              9: { cellWidth: 18, halign: 'center' }, // Syllabus 10
              10: { cellWidth: 14, halign: 'center' } // Total
            },
            alternateRowStyles: {
              fillColor: [248, 250, 252]
            },
            didParseCell: function(data) {
              // Highlight rows with no flights (amber background)
              if (data.section === 'body') {
                const rowData = report.data[data.row.index];
                if (rowData && !rowData.hasAnyFlight) {
                  data.cell.styles.fillColor = [254, 243, 199]; // amber-100
                }
              }
            },
            margin: { left: 15, right: 15 },
            theme: 'grid'
          });
        };

        const renderQCUAReport = (pdf, report, startY) => {
          const rows = report.data || [];
          const meta = report.meta || {};
          const isMultiUnit = meta.view === 'multi-unit';
          let yPos = startY;
          const pageHeight = pdf.internal.pageSize.getHeight();

          // Summary stats
          pdf.setFontSize(9);
          pdf.setFont(undefined, 'normal');
          pdf.text(`Award Cycle: ${meta.cycleStart || 'N/A'} to ${meta.cycleEnd || 'N/A'}`, 15, yPos);
          yPos += 5;
          pdf.text(`Total Units: ${meta.totalUnits || 0} | On Track: ${meta.onTrackUnits || 0} | Eligible (10+ cadets): ${meta.eligibleUnits || 0}`, 15, yPos);
          yPos += 8;

          if (isMultiUnit && rows.length > 0) {
            // Multi-unit summary table
            const tableHead = [['Unit', 'Cadets', 'Status', 'Score', 'WB', 'ENC', 'ENR', 'GES', 'ONB', 'OFL', 'TLC']];
            const tableBody = rows.map(unit => {
              const getSymbol = (c) => {
                if (!c.trackable) return '?';
                if (c.met === null) return '-';
                return c.met ? 'Y' : 'N';
              };
              return [
                unit.unitName,
                unit.totalCadets.toString(),
                unit.awardStatus === 'Ineligible (< 10 cadets)' ? '<10' : unit.awardStatus.replace('Potentially ', 'Pot. '),
                `${unit.criteriaMet}/10`,
                getSymbol(unit.criteria.cadetAchievement),
                getSymbol(unit.criteria.encampment),
                getSymbol(unit.criteria.enrollment),
                getSymbol(unit.criteria.emergencyServices),
                getSymbol(unit.criteria.onboarding),
                getSymbol(unit.criteria.orientationFlights),
                getSymbol(unit.criteria.tlcGraduates)
              ];
            });

            pdf.autoTable({
              head: tableHead,
              body: tableBody,
              startY: yPos,
              styles: { fontSize: 7, cellPadding: 2 },
              headStyles: { fillColor: [71, 85, 105], textColor: 255 },
              columnStyles: {
                0: { cellWidth: 35 },
                1: { cellWidth: 15, halign: 'center' },
                2: { cellWidth: 25, halign: 'center' },
                3: { cellWidth: 15, halign: 'center' },
                4: { cellWidth: 12, halign: 'center' },
                5: { cellWidth: 12, halign: 'center' },
                6: { cellWidth: 12, halign: 'center' },
                7: { cellWidth: 12, halign: 'center' },
                8: { cellWidth: 12, halign: 'center' },
                9: { cellWidth: 12, halign: 'center' },
                10: { cellWidth: 12, halign: 'center' }
              },
              margin: { left: 15, right: 15 },
              theme: 'grid'
            });

            yPos = pdf.lastAutoTable.finalY + 8;

            // Legend
            pdf.setFontSize(7);
            pdf.text('Legend: Y=Met, N=Not Met, ?=Not Trackable, -=N/A', 15, yPos);
            yPos += 4;
            pdf.text('WB=Wright Brothers, ENC=Encampment, ENR=Enrollment, GES=Emergency Services, ONB=Onboarding, OFL=O-Flights, TLC=TLC Graduates', 15, yPos);
            yPos += 4;
            pdf.text('+ 3 non-trackable: Aerospace (AEX/STEM Kit), Local Action (4 events), STEM Team', 15, yPos);
          } else {
            // Single unit detailed view
            rows.forEach((unit, idx) => {
              if (yPos > pageHeight - 60) {
                pdf.addPage();
                yPos = 20;
              }

              // Unit header
              pdf.setFontSize(12);
              pdf.setFont(undefined, 'bold');
              pdf.text(unit.unitName, 15, yPos);
              yPos += 6;

              pdf.setFontSize(9);
              pdf.setFont(undefined, 'normal');
              pdf.text(`Status: ${unit.awardStatus} | Criteria Met: ${unit.criteriaMet}/10 | Cadets: ${unit.totalCadets} | Seniors: ${unit.totalSeniors}`, 15, yPos);
              yPos += 8;

              // Criteria table for single unit
              const criteriaOrder = [
                ['cadetAchievement', 'Cadet Achievement (45% WB)'],
                ['encampment', 'Encampment (50%)'],
                ['enrollment', 'Enrollment (25+ cadets)'],
                ['emergencyServices', 'Emergency Services (60% GES)'],
                ['onboarding', 'Onboarding (70% in 8 wks)'],
                ['orientationFlights', 'Orientation Flights (70%)'],
                ['tlcGraduates', 'TLC Graduates (3+)'],
                ['aerospace', 'Aerospace (AEX/STEM Kit)'],
                ['localAction', 'Local Action (4 events)'],
                ['stemTeam', 'STEM Team']
              ];

              const tableBody = criteriaOrder.map(([key, label]) => {
                const c = unit.criteria[key];
                if (!c) return [label, '-', '-', '-'];

                const status = !c.trackable ? 'Not Trackable' : c.met === null ? 'N/A' : c.met ? 'MET' : 'NOT MET';
                let value = '';
                if (!c.trackable) {
                  value = c.notTrackableReason || 'N/A';
                } else if (c.noNewCadets) {
                  value = 'No new cadets';
                } else if (c.isCountBased) {
                  value = `${c.count}/${c.threshold}`;
                } else if (c.percent !== null) {
                  value = `${c.percent}% (${c.count}/${c.total})`;
                }

                return [label, status, value];
              });

              pdf.autoTable({
                head: [['Criterion', 'Status', 'Value']],
                body: tableBody,
                startY: yPos,
                styles: { fontSize: 8, cellPadding: 2 },
                headStyles: { fillColor: [71, 85, 105], textColor: 255 },
                columnStyles: {
                  0: { cellWidth: 70 },
                  1: { cellWidth: 30, halign: 'center' },
                  2: { cellWidth: 60 }
                },
                margin: { left: 15, right: 15 },
                theme: 'grid',
                didParseCell: function(data) {
                  if (data.section === 'body' && data.column.index === 1) {
                    const status = data.cell.raw;
                    if (status === 'MET') {
                      data.cell.styles.textColor = [22, 163, 74]; // emerald
                    } else if (status === 'NOT MET') {
                      data.cell.styles.textColor = [220, 38, 38]; // red
                    } else {
                      data.cell.styles.textColor = [100, 116, 139]; // slate
                    }
                  }
                }
              });

              yPos = pdf.lastAutoTable.finalY + 12;
            });
          }
        };

        // QUA (Quality Unit Award) PDF Report Renderer
        const renderQUAReport = (pdf, report, startY) => {
          const rows = report.data || [];
          const meta = report.meta || {};
          const isMultiUnit = meta.view === 'multi-unit';
          let yPos = startY;
          const pageHeight = pdf.internal.pageSize.getHeight();

          // Summary stats
          pdf.setFontSize(9);
          pdf.setFont(undefined, 'normal');
          pdf.text(`Award Cycle: ${meta.fyStart || 'N/A'} to ${meta.fyEnd || 'N/A'} (${meta.fyLabel || 'FY'})`, 15, yPos);
          yPos += 5;
          pdf.text(`Total Units: ${meta.totalUnits || 0} | On Track: ${meta.onTrackUnits || 0} | Potentially Eligible: ${meta.potentialUnits || 0}`, 15, yPos);
          yPos += 8;

          if (isMultiUnit && rows.length > 0) {
            // Multi-unit summary table
            const tableHead = [['Unit', 'Type', 'Seniors', 'Status', 'Score', 'CP', 'PD', 'RET', 'ES', 'CMD', 'ENC']];
            const tableBody = rows.map(unit => {
              const getSymbol = (c) => {
                if (!c || !c.trackable) return '?';
                if (c.met === null) return '-';
                return c.met ? 'Y' : 'N';
              };
              const getShortStatus = (status) => {
                if (status === 'On Track') return 'On Track';
                if (status === 'Potentially Eligible') return 'Pot. Elig';
                if (status === 'Required Criteria Not Met') return 'Req Not Met';
                if (status === 'Not On Track') return 'Not Track';
                return status;
              };
              return [
                unit.unitName,
                unit.unitCategoryLabel || unit.unitCategory,
                unit.totalSeniors.toString(),
                getShortStatus(unit.awardStatus),
                `${unit.criteriaMet}/10`,
                getSymbol(unit.criteria.cadetProtection),
                getSymbol(unit.criteria.professionalDevelopment),
                getSymbol(unit.criteria.retention),
                getSymbol(unit.criteria.esReadiness),
                getSymbol(unit.criteria.commandLeadership),
                getSymbol(unit.criteria.encampmentSupport)
              ];
            });

            pdf.autoTable({
              head: tableHead,
              body: tableBody,
              startY: yPos,
              styles: { fontSize: 7, cellPadding: 2 },
              headStyles: { fillColor: [71, 85, 105], textColor: 255 },
              columnStyles: {
                0: { cellWidth: 35 },
                1: { cellWidth: 22, halign: 'center' },
                2: { cellWidth: 15, halign: 'center' },
                3: { cellWidth: 22, halign: 'center' },
                4: { cellWidth: 15, halign: 'center' },
                5: { cellWidth: 12, halign: 'center' },
                6: { cellWidth: 12, halign: 'center' },
                7: { cellWidth: 12, halign: 'center' },
                8: { cellWidth: 12, halign: 'center' },
                9: { cellWidth: 12, halign: 'center' },
                10: { cellWidth: 12, halign: 'center' }
              },
              margin: { left: 15, right: 15 },
              theme: 'grid'
            });

            yPos = pdf.lastAutoTable.finalY + 8;

            // Legend
            pdf.setFontSize(7);
            pdf.text('Legend: Y=Met, N=Not Met, ?=Not Trackable, -=N/A', 15, yPos);
            yPos += 4;
            pdf.text('CP=Cadet Protection (Req), PD=Professional Development (Req), RET=Retention (Req), ES=ES Readiness, CMD=Command & Leadership, ENC=Encampment', 15, yPos);
            yPos += 4;
            pdf.text('+ 4 non-trackable: Aerospace Education, Community Engagement, Flying Excellence, Innovation & Cyber', 15, yPos);
          } else {
            // Single unit detailed view
            rows.forEach((unit, idx) => {
              if (yPos > pageHeight - 60) {
                pdf.addPage();
                yPos = 20;
              }

              // Unit header with colored status bar
              const statusColors = {
                'On Track': [22, 163, 74],           // emerald
                'Potentially Eligible': [234, 179, 8], // amber
                'Required Criteria Not Met': [220, 38, 38], // red
                'Not On Track': [100, 116, 139]      // slate
              };
              const statusColor = statusColors[unit.awardStatus] || [100, 116, 139];

              pdf.setFillColor(...statusColor);
              pdf.rect(15, yPos - 4, 180, 8, 'F');
              pdf.setTextColor(255, 255, 255);
              pdf.setFontSize(11);
              pdf.setFont(undefined, 'bold');
              pdf.text(unit.unitName, 17, yPos + 1);
              pdf.setFontSize(9);
              pdf.text(`${unit.criteriaMet}/10 Criteria`, 160, yPos + 1);
              yPos += 8;

              pdf.setTextColor(0, 0, 0);
              pdf.setFontSize(9);
              pdf.setFont(undefined, 'normal');
              pdf.text(`Status: ${unit.awardStatus} | Seniors: ${unit.totalSeniors} | Type: ${unit.unitCategoryLabel || unit.unitCategory}`, 15, yPos);
              yPos += 8;

              // Required Criteria Section
              pdf.setFillColor(239, 68, 68); // red-500
              pdf.rect(15, yPos - 3, 180, 6, 'F');
              pdf.setTextColor(255, 255, 255);
              pdf.setFontSize(9);
              pdf.setFont(undefined, 'bold');
              pdf.text('REQUIRED CRITERIA (Must meet all 3)', 17, yPos + 1);
              yPos += 7;
              pdf.setTextColor(0, 0, 0);

              // Required criteria table
              const requiredCriteria = [
                ['cadetProtection', 'Cadet Protection', '100% members with current training'],
                ['professionalDevelopment', 'Professional Development', `${unit.pdThreshold}% new Level II-V in FY + timely SM promotions`],
                ['retention', 'Recruitment & Retention', '5% growth OR 75% retention']
              ];

              const requiredBody = requiredCriteria.map(([key, name, desc]) => {
                const c = unit.criteria[key];
                if (!c) return [name, '-', '-', desc];

                const status = !c.trackable ? 'Manual' : c.met === null ? 'N/A' : c.met ? 'MET' : 'NOT MET';
                let value = '';

                if (!c.trackable) {
                  value = '-';
                } else if (key === 'retention') {
                  const growthStr = c.growth !== null ? `${c.growth >= 0 ? '+' : ''}${c.growth}%` : 'N/A';
                  const retStr = c.retention !== null ? `${c.retention}%` : 'N/A';
                  value = `Growth: ${growthStr} | Ret: ${retStr}`;
                } else if (key === 'professionalDevelopment' && c.subCriteria) {
                  const nl = c.subCriteria.newLevels;
                  const sm = c.subCriteria.smPromotion;
                  const nlStr = nl ? `${nl.count} (${nl.percent}%) new levels` : '';
                  const smStr = sm ? `${sm.violations} SM violations` : '';
                  value = [nlStr, smStr].filter(Boolean).join(' | ');
                } else if (c.percent !== null && c.percent !== undefined) {
                  value = `${c.percent}% (${c.count}/${c.total})`;
                }

                return [name, status, value, desc];
              });

              pdf.autoTable({
                head: [['Criterion', 'Status', 'Current Value', 'Requirement']],
                body: requiredBody,
                startY: yPos,
                styles: { fontSize: 8, cellPadding: 2 },
                headStyles: { fillColor: [254, 226, 226], textColor: [127, 29, 29] }, // red-100/red-900
                columnStyles: {
                  0: { cellWidth: 40 },
                  1: { cellWidth: 22, halign: 'center' },
                  2: { cellWidth: 50 },
                  3: { cellWidth: 68 }
                },
                margin: { left: 15, right: 15 },
                theme: 'grid',
                didParseCell: function(data) {
                  if (data.section === 'body') {
                    // Row background based on status
                    const status = data.row.raw[1];
                    if (status === 'MET') {
                      data.cell.styles.fillColor = [236, 253, 245]; // emerald-50
                    } else if (status === 'NOT MET') {
                      data.cell.styles.fillColor = [254, 242, 242]; // red-50
                    }
                    // Status text color
                    if (data.column.index === 1) {
                      if (status === 'MET') {
                        data.cell.styles.textColor = [22, 163, 74];
                        data.cell.styles.fontStyle = 'bold';
                      } else if (status === 'NOT MET') {
                        data.cell.styles.textColor = [220, 38, 38];
                        data.cell.styles.fontStyle = 'bold';
                      }
                    }
                  }
                }
              });

              yPos = pdf.lastAutoTable.finalY + 6;

              // Mission-Specific Criteria Section
              pdf.setFillColor(124, 58, 237); // purple-600
              pdf.rect(15, yPos - 3, 180, 6, 'F');
              pdf.setTextColor(255, 255, 255);
              pdf.setFontSize(9);
              pdf.setFont(undefined, 'bold');
              pdf.text('MISSION-SPECIFIC CRITERIA (Choose any 4 of 7)', 17, yPos + 1);
              yPos += 7;
              pdf.setTextColor(0, 0, 0);

              // Mission-specific criteria table
              const missionCriteria = [
                ['esReadiness', 'Emergency Services Readiness', '50% GES + 25% ICUT + 15% Op Eval'],
                ['commandLeadership', 'Command & Leadership', 'VOLU + 25% Yeager+ + 25% Capt+'],
                ['encampmentSupport', 'Encampment Support', '15% of seniors serving'],
                ['aerospaceEducation', 'Aerospace Education', 'AE programming events'],
                ['communityEngagement', 'Community Engagement', 'Community outreach activities'],
                ['flyingExcellence', 'Flying Excellence', 'Pilot currency maintained'],
                ['innovationCyber', 'Innovation & Cyber', 'Technology initiatives']
              ];

              const missionBody = missionCriteria.map(([key, name, desc]) => {
                const c = unit.criteria[key];
                if (!c) return [name, 'Manual', '-', desc];

                const status = !c.trackable ? 'Manual' : c.met === null ? 'N/A' : c.met ? 'MET' : 'NOT MET';
                let value = '-';

                if (c.trackable) {
                  if (c.subCriteria) {
                    const parts = [];
                    Object.entries(c.subCriteria).forEach(([subKey, sub]) => {
                      if (sub.percent !== undefined) {
                        const label = sub.name || subKey;
                        parts.push(`${label}: ${sub.percent}%`);
                      } else if (sub.count !== undefined) {
                        const label = sub.name || subKey;
                        parts.push(`${label}: ${sub.count}`);
                      }
                    });
                    value = parts.join(' | ') || '-';
                  } else if (c.percent !== null && c.percent !== undefined) {
                    value = `${c.percent}% (${c.count}/${c.total})`;
                  } else if (c.count !== undefined) {
                    value = `${c.count}`;
                  }
                }

                return [name, status, value, desc];
              });

              pdf.autoTable({
                head: [['Criterion', 'Status', 'Current Value', 'Requirement']],
                body: missionBody,
                startY: yPos,
                styles: { fontSize: 8, cellPadding: 2 },
                headStyles: { fillColor: [243, 232, 255], textColor: [88, 28, 135] }, // purple-100/purple-900
                columnStyles: {
                  0: { cellWidth: 40 },
                  1: { cellWidth: 22, halign: 'center' },
                  2: { cellWidth: 50 },
                  3: { cellWidth: 68 }
                },
                margin: { left: 15, right: 15 },
                theme: 'grid',
                didParseCell: function(data) {
                  if (data.section === 'body') {
                    const status = data.row.raw[1];
                    if (status === 'MET') {
                      data.cell.styles.fillColor = [236, 253, 245]; // emerald-50
                    } else if (status === 'NOT MET') {
                      data.cell.styles.fillColor = [254, 242, 242]; // red-50
                    } else if (status === 'Manual') {
                      data.cell.styles.fillColor = [248, 250, 252]; // slate-50
                    }
                    if (data.column.index === 1) {
                      if (status === 'MET') {
                        data.cell.styles.textColor = [22, 163, 74];
                        data.cell.styles.fontStyle = 'bold';
                      } else if (status === 'NOT MET') {
                        data.cell.styles.textColor = [220, 38, 38];
                        data.cell.styles.fontStyle = 'bold';
                      } else if (status === 'Manual') {
                        data.cell.styles.textColor = [100, 116, 139];
                        data.cell.styles.fontStyle = 'italic';
                      }
                    }
                  }
                }
              });

              yPos = pdf.lastAutoTable.finalY + 12;
            });
          }
        };

        const renderRecruitingTrendsReport = (pdf, report, startY) => {
          let yPos = startY;
          const meta = report.meta || {};
          const pageWidth = pdf.internal.pageSize.getWidth();

          // Time range header
          pdf.setFontSize(10);
          pdf.setFont(undefined, 'normal');
          pdf.setTextColor(71, 85, 105);
          const timeRangeText = meta.timeRange === 0 ? 'All time' : `Last ${meta.timeRange} months`;
          pdf.text(`Time Range: ${timeRangeText} | ${meta.dataPoints || 0} data points`, 15, yPos);
          yPos += 8;

          // Summary Statistics Box
          pdf.setFillColor(239, 246, 255); // blue-50
          pdf.rect(15, yPos, pageWidth - 30, 28, 'F');
          pdf.setDrawColor(191, 219, 254); // blue-200
          pdf.rect(15, yPos, pageWidth - 30, 28, 'S');

          const boxWidth = (pageWidth - 30) / 4;
          const statY = yPos + 10;
          const labelY = yPos + 18;

          // Stat 1: Total Recruited
          pdf.setFontSize(16);
          pdf.setFont(undefined, 'bold');
          pdf.setTextColor(30, 41, 59);
          pdf.text(String(meta.totalRecruited || 0), 15 + boxWidth * 0.5, statY, { align: 'center' });
          pdf.setFontSize(7);
          pdf.setFont(undefined, 'normal');
          pdf.setTextColor(100, 116, 139);
          pdf.text('TOTAL RECRUITED', 15 + boxWidth * 0.5, labelY, { align: 'center' });

          // Stat 2: Monthly Avg
          pdf.setFontSize(16);
          pdf.setFont(undefined, 'bold');
          pdf.setTextColor(30, 41, 59);
          pdf.text(String(meta.monthlyAverage || 0), 15 + boxWidth * 1.5, statY, { align: 'center' });
          pdf.setFontSize(7);
          pdf.setFont(undefined, 'normal');
          pdf.setTextColor(100, 116, 139);
          pdf.text('MONTHLY AVG', 15 + boxWidth * 1.5, labelY, { align: 'center' });

          // Stat 3: New Members
          pdf.setFontSize(16);
          pdf.setFont(undefined, 'bold');
          pdf.setTextColor(22, 163, 74); // emerald
          pdf.text(String(meta.newTotal || 0), 15 + boxWidth * 2.5, statY, { align: 'center' });
          pdf.setFontSize(7);
          pdf.setFont(undefined, 'normal');
          pdf.setTextColor(100, 116, 139);
          pdf.text('NEW MEMBERS', 15 + boxWidth * 2.5, labelY, { align: 'center' });

          // Stat 4: Rejoins
          pdf.setFontSize(16);
          pdf.setFont(undefined, 'bold');
          pdf.setTextColor(37, 99, 235); // blue
          pdf.text(String(meta.rejoinTotal || 0), 15 + boxWidth * 3.5, statY, { align: 'center' });
          pdf.setFontSize(7);
          pdf.setFont(undefined, 'normal');
          pdf.setTextColor(100, 116, 139);
          pdf.text('REJOINS', 15 + boxWidth * 3.5, labelY, { align: 'center' });

          yPos += 35;

          // Member Type Breakdown
          pdf.setFontSize(9);
          pdf.setFont(undefined, 'bold');
          pdf.setTextColor(51, 65, 85);
          pdf.text('Member Type Breakdown:', 15, yPos);
          yPos += 5;
          pdf.setFont(undefined, 'normal');
          pdf.setFontSize(8);
          pdf.text(`Senior Members: ${meta.seniorTotal || 0}  |  Cadets: ${meta.cadetTotal || 0}`, 20, yPos);
          yPos += 8;

          // Seasonality if available
          if (meta.seasonality) {
            pdf.setFontSize(9);
            pdf.setFont(undefined, 'bold');
            pdf.setTextColor(51, 65, 85);
            pdf.text('Seasonal Patterns:', 15, yPos);
            yPos += 5;
            pdf.setFont(undefined, 'normal');
            pdf.setFontSize(8);
            const peakMonths = meta.seasonality.peakMonths?.join(', ') || 'N/A';
            const lowMonths = meta.seasonality.lowMonths?.join(', ') || 'N/A';
            pdf.setTextColor(22, 163, 74);
            pdf.text(`Peak Months: ${peakMonths}`, 20, yPos);
            yPos += 4;
            pdf.setTextColor(220, 38, 38);
            pdf.text(`Low Months: ${lowMonths}`, 20, yPos);
            yPos += 8;
          }

          // Unit Breakdown Table (if aggregate)
          if (meta.isAggregate && meta.unitBreakdown && meta.unitBreakdown.length > 0) {
            pdf.setFontSize(9);
            pdf.setFont(undefined, 'bold');
            pdf.setTextColor(51, 65, 85);
            pdf.text('Unit Recruiting Rates:', 15, yPos);
            yPos += 3;

            pdf.autoTable({
              startY: yPos,
              head: [['Unit', 'Members', 'Avg/Month']],
              body: meta.unitBreakdown.slice(0, 10).map(u => [
                u.unitName || u.orgId,
                String(u.currentTotal || 0),
                u.recruitingRate || '--'
              ]),
              styles: { fontSize: 7, cellPadding: 1.5 },
              headStyles: { fillColor: [71, 85, 105], textColor: 255, fontStyle: 'bold', fontSize: 7 },
              alternateRowStyles: { fillColor: [248, 250, 252] },
              margin: { left: 15, right: 15 },
              theme: 'grid'
            });
            yPos = pdf.lastAutoTable.finalY + 8;
          }

          // Monthly Breakdown Table
          pdf.setFontSize(9);
          pdf.setFont(undefined, 'bold');
          pdf.setTextColor(51, 65, 85);
          pdf.text('Monthly Breakdown:', 15, yPos);
          yPos += 3;

          pdf.autoTable({
            startY: yPos,
            head: [['Month', 'New', 'Rejoin', 'Total', 'Members']],
            body: (report.data || []).slice(0, 24).map(row => [
              row.month || '',
              String(row.totalNew || 0),
              String(row.totalRejoin || 0),
              String(row.totalRecruited || 0),
              String(row.totalMembers || 0)
            ]),
            styles: { fontSize: 7, cellPadding: 1.5 },
            headStyles: { fillColor: [71, 85, 105], textColor: 255, fontStyle: 'bold', fontSize: 7 },
            alternateRowStyles: { fillColor: [248, 250, 252] },
            margin: { left: 15, right: 15 },
            theme: 'grid'
          });
        };

        const renderRetentionAnalysisReport = (pdf, report, startY) => {
          let yPos = startY;
          const meta = report.meta || {};
          const pageWidth = pdf.internal.pageSize.getWidth();

          // Time range header
          pdf.setFontSize(10);
          pdf.setFont(undefined, 'normal');
          pdf.setTextColor(71, 85, 105);
          const timeRangeText = meta.timeRange === 0 ? 'All time' : `Last ${meta.timeRange} months`;
          pdf.text(`Time Range: ${timeRangeText}`, 15, yPos);
          yPos += 8;

          // Health Status Banner
          const healthColor = meta.healthIndicator === 'healthy' ? [22, 163, 74] :
                              meta.healthIndicator === 'moderate' ? [217, 119, 6] :
                              meta.healthIndicator === 'at-risk' ? [220, 38, 38] : [100, 116, 139];
          const healthBg = meta.healthIndicator === 'healthy' ? [220, 252, 231] :
                           meta.healthIndicator === 'moderate' ? [254, 243, 199] :
                           meta.healthIndicator === 'at-risk' ? [254, 226, 226] : [241, 245, 249];
          const healthLabel = meta.healthIndicator === 'healthy' ? 'HEALTHY' :
                              meta.healthIndicator === 'moderate' ? 'MODERATE' :
                              meta.healthIndicator === 'at-risk' ? 'AT RISK' : 'UNKNOWN';

          pdf.setFillColor(...healthBg);
          pdf.rect(15, yPos, pageWidth - 30, 12, 'F');
          pdf.setFontSize(12);
          pdf.setFont(undefined, 'bold');
          pdf.setTextColor(...healthColor);
          pdf.text(`Retention Rate: ${meta.retentionRate !== null ? meta.retentionRate + '%' : '--'}  [${healthLabel}]`, pageWidth / 2, yPos + 8, { align: 'center' });
          yPos += 18;

          // Summary Statistics Box
          pdf.setFillColor(255, 251, 235); // amber-50
          pdf.rect(15, yPos, pageWidth - 30, 28, 'F');
          pdf.setDrawColor(253, 230, 138); // amber-200
          pdf.rect(15, yPos, pageWidth - 30, 28, 'S');

          const boxWidth = (pageWidth - 30) / 4;
          const statY = yPos + 10;
          const labelY = yPos + 18;

          // Stat 1: Current Members
          pdf.setFontSize(16);
          pdf.setFont(undefined, 'bold');
          pdf.setTextColor(30, 41, 59);
          pdf.text(String(meta.currentTotal || 0), 15 + boxWidth * 0.5, statY, { align: 'center' });
          pdf.setFontSize(7);
          pdf.setFont(undefined, 'normal');
          pdf.setTextColor(100, 116, 139);
          pdf.text('CURRENT MEMBERS', 15 + boxWidth * 0.5, labelY, { align: 'center' });

          // Stat 2: Renewals
          pdf.setFontSize(16);
          pdf.setFont(undefined, 'bold');
          pdf.setTextColor(22, 163, 74);
          pdf.text(String(meta.renewalsInPeriod || 0), 15 + boxWidth * 1.5, statY, { align: 'center' });
          pdf.setFontSize(7);
          pdf.setFont(undefined, 'normal');
          pdf.setTextColor(100, 116, 139);
          pdf.text('RENEWALS', 15 + boxWidth * 1.5, labelY, { align: 'center' });

          // Stat 3: Est. Attrition
          pdf.setFontSize(16);
          pdf.setFont(undefined, 'bold');
          pdf.setTextColor(220, 38, 38);
          pdf.text(String(meta.estimatedAttrition || 0), 15 + boxWidth * 2.5, statY, { align: 'center' });
          pdf.setFontSize(7);
          pdf.setFont(undefined, 'normal');
          pdf.setTextColor(100, 116, 139);
          pdf.text('EST. ATTRITION', 15 + boxWidth * 2.5, labelY, { align: 'center' });

          // Stat 4: Net Change
          const netChange = meta.netChange || 0;
          const netColor = netChange > 0 ? [22, 163, 74] : netChange < 0 ? [220, 38, 38] : [100, 116, 139];
          pdf.setFontSize(16);
          pdf.setFont(undefined, 'bold');
          pdf.setTextColor(...netColor);
          pdf.text((netChange > 0 ? '+' : '') + String(netChange), 15 + boxWidth * 3.5, statY, { align: 'center' });
          pdf.setFontSize(7);
          pdf.setFont(undefined, 'normal');
          pdf.setTextColor(100, 116, 139);
          pdf.text('NET CHANGE', 15 + boxWidth * 3.5, labelY, { align: 'center' });

          yPos += 35;

          // Expiring Members Summary
          pdf.setFontSize(9);
          pdf.setFont(undefined, 'bold');
          pdf.setTextColor(51, 65, 85);
          pdf.text('Members Due for Renewal:', 15, yPos);
          yPos += 5;
          pdf.setFont(undefined, 'normal');
          pdf.setFontSize(8);
          pdf.setTextColor(220, 38, 38);
          pdf.text(`30 days: ${meta.expiringIn30Days || 0}`, 20, yPos);
          pdf.setTextColor(217, 119, 6);
          pdf.text(`60 days: ${meta.expiringIn60Days || 0}`, 55, yPos);
          pdf.setTextColor(100, 116, 139);
          pdf.text(`90 days: ${meta.expiringIn90Days || 0}`, 90, yPos);
          yPos += 8;

          // Unit Breakdown Table (if aggregate)
          if (meta.isAggregate && meta.unitBreakdown && meta.unitBreakdown.length > 0) {
            pdf.setFontSize(9);
            pdf.setFont(undefined, 'bold');
            pdf.setTextColor(51, 65, 85);
            pdf.text('Unit Retention Rates:', 15, yPos);
            yPos += 3;

            pdf.autoTable({
              startY: yPos,
              head: [['Unit', 'Members', 'Retention', 'Status']],
              body: meta.unitBreakdown.slice(0, 10).map(u => [
                u.unitName || u.orgId,
                String(u.currentTotal || 0),
                u.retentionRate !== null ? u.retentionRate + '%' : '--',
                u.growthStatus || '--'
              ]),
              styles: { fontSize: 7, cellPadding: 1.5 },
              headStyles: { fillColor: [71, 85, 105], textColor: 255, fontStyle: 'bold', fontSize: 7 },
              alternateRowStyles: { fillColor: [248, 250, 252] },
              margin: { left: 15, right: 15 },
              theme: 'grid'
            });
            yPos = pdf.lastAutoTable.finalY + 8;
          }

          // Members Due for Renewal Table
          if (report.data && report.data.length > 0) {
            pdf.setFontSize(9);
            pdf.setFont(undefined, 'bold');
            pdf.setTextColor(51, 65, 85);
            pdf.text('Members Expiring Soon:', 15, yPos);
            yPos += 3;

            pdf.autoTable({
              startY: yPos,
              head: [['Member', 'CAPID', 'Type', 'Unit', 'Expires', 'Days']],
              body: report.data.map(row => [
                row.memberName || '',
                row.capid || '',
                row.memberType || '',
                row.unit || '',
                row.expiration || '',
                String(row.daysUntil || '')
              ]),
              styles: { fontSize: 7, cellPadding: 1.5 },
              headStyles: { fillColor: [71, 85, 105], textColor: 255, fontStyle: 'bold', fontSize: 7 },
              alternateRowStyles: { fillColor: [248, 250, 252] },
              margin: { left: 15, right: 15 },
              theme: 'grid',
              didParseCell: function(data) {
                if (data.section === 'body' && data.column.index === 5) {
                  const days = parseInt(data.cell.raw);
                  if (!isNaN(days)) {
                    if (days <= 30) {
                      data.cell.styles.textColor = [220, 38, 38]; // red
                    } else if (days <= 60) {
                      data.cell.styles.textColor = [217, 119, 6]; // amber
                    }
                  }
                }
              }
            });
          } else {
            pdf.setFontSize(9);
            pdf.setTextColor(100, 116, 139);
            pdf.text('No members expiring in the next 90 days.', 15, yPos);
          }
        };

        const addReportContent = (pdf, report) => {
          const startY = 45;

          switch (report.type) {
            case 'training':
              return renderTrainingReport(pdf, report, startY);
            case 'discrepancies':
              return renderDiscrepanciesReport(pdf, report, startY);
            case 'aerospace-education':
              return renderAerospaceEducationReport(pdf, report, startY);
            case 'oflight-status':
              return renderOFlightReport(pdf, report, startY);
            case 'qcua':
              return renderQCUAReport(pdf, report, startY);
            case 'qua':
              return renderQUAReport(pdf, report, startY);
            case 'recruiting-trends':
              return renderRecruitingTrendsReport(pdf, report, startY);
            case 'retention-analysis':
              return renderRetentionAnalysisReport(pdf, report, startY);
            default:
              return renderTableReport(pdf, report, startY);
          }
        };

        const exportReportToPDF = async (report) => {
          try {
            const { jsPDF } = window.jspdf;

            if (!jsPDF) {
              alert('PDF library not loaded. Please refresh the page and try again.');
              return;
            }

            const orientation = detectOrientation(report);
            const pdf = new jsPDF({
              orientation,
              unit: 'mm',
              format: 'a4'
            });

            addPDFHeader(pdf, report);
            await addReportContent(pdf, report);
            pdf.save(generateFilename(report));
          } catch (error) {
            console.error('Error generating PDF:', error);
            alert('Error generating PDF. Please try again.');
          }
        };

          const handleExportReportPDF = async (reportDef) => {
            try {
              const scopedMembers = getMembersForReport(reportDef.tags);
              const reportData = reportDef.generate(scopedMembers);
              const reportPayload = buildReportPayload(reportDef, reportData);
              await exportReportToPDF(reportPayload);
            } catch (error) {
              console.error('Error exporting report:', error);
              alert('Error exporting report. Please try again.');
            }
        };

        const handleExportCurrentReportPDF = async () => {
          if (!selectedReport) {
            alert('No report is currently displayed');
            return;
          }
          await exportReportToPDF(selectedReport);
        };

        if (loading) {
          return (
            <div className="flex flex-col items-center justify-center min-h-screen bg-slate-50">
              <div className="spinner mb-4"></div>
              <h2 className="text-xl font-bold text-slate-800">Loading {window.APP_CONFIG?.appName || APP_NAME}...</h2>
              <p className="text-slate-500 mt-2 text-sm">{loadingStatus}</p>
            </div>
          );
        }
        
        const activeFiltersCount = filters.ranks.length + filters.rankCategories.length + filters.functionalAreas.length + filters.tracks.length + filters.trackLevels.length + filters.duties.length + filters.dutyTypes.length + filters.memberTypes.length + (filterTlcQualified ? 1 : 0);

        return (
          <div className="min-h-screen bg-slate-50 font-sans text-slate-900 pb-20">
            <header className="bg-blue-900 text-white shadow sticky top-0 z-50 px-3 sm:px-4 py-2 md:py-3 flex flex-col md:flex-row justify-between items-center gap-2 md:gap-4">
              <div className="flex flex-col md:flex-row items-start md:items-center gap-2 md:gap-3 w-full md:w-auto">
                {/* Logo and title - hidden on mobile */}
                <div className="hidden md:flex items-center gap-3 min-w-0">
                    {window.APP_CONFIG?.logoUrl && (
                      <img src={window.APP_CONFIG.logoUrl} alt="Logo" className="w-10 h-10 object-contain mr-2" />
                    )}
                    <div className="min-w-0">
                      <h1 className="text-xl font-bold leading-tight">{window.APP_CONFIG?.appName || APP_NAME}</h1>
                      <p className="text-xs text-blue-200">Sync: {formatSyncTime(lastUpdated)}</p>
                    </div>
                </div>

                <div className="h-8 w-px bg-blue-700 hidden md:block mx-2"></div>

                <div className="flex items-center gap-2 w-full md:w-auto flex-nowrap">
                     <div className="relative flex-1 min-w-[200px]">
                        <select value={unitFilter} onChange={(e) => setUnitFilter(e.target.value)} className="bg-blue-800 border border-blue-700 text-white rounded pl-2 pr-8 py-2 text-sm font-bold cursor-pointer focus:ring-1 focus:ring-blue-400 appearance-none w-full sm:max-w-[320px] truncate">
                            {availableUnits.map(u => <option key={u.id} value={u.id}>{u.name}</option>)}
                        </select>
                        <Icon name="ChevronDown" className="w-4 h-4 text-blue-300 absolute right-2 top-2 pointer-events-none" />
                     </div>
                     <label
                       className="group relative flex items-center gap-2 shrink-0 cursor-pointer rounded-lg border border-blue-600 bg-blue-800/80 hover:bg-blue-800 px-3 py-2 text-xs font-semibold text-blue-50 shadow-sm transition-colors select-none"
                       title="Aggregate data from subordinate units"
                     >
                       <input
                         type="checkbox"
                         checked={showAllDescendants}
                         onChange={handleShowSubUnits}
                         className="sr-only"
                       />
                       <span className={`flex items-center justify-center w-4 h-4 rounded border ${showAllDescendants ? 'bg-green-500 border-green-400' : 'border-blue-300 bg-blue-900/60'}`}>
                         {showAllDescendants && <Icon name="Check" className="w-3 h-3 text-white" />}
                       </span>
                       <span className="flex-1 text-left whitespace-nowrap">{isAggregating ? "Loading..." : "Include Sub-Units"}</span>
                     </label>
                </div>
              </div>

              <div className="flex items-center gap-3 w-full md:w-auto flex-wrap md:flex-nowrap">
                 <div className="relative flex-1 min-w-[180px] md:w-64">
                    <Icon name="Search" className="absolute left-3 top-2 text-blue-300 w-4 h-4" />
                    <input type="text" placeholder="Search members, duties..." value={searchQuery} onChange={(e)=>setSearchQuery(e.target.value)} className="w-full pl-9 pr-3 py-1.5 bg-blue-800 border border-blue-700 text-white placeholder-blue-300 rounded focus:outline-none focus:ring-1 focus:ring-blue-400 text-sm" />
                 </div>

                 <button
                   className="md:hidden flex items-center gap-2 px-3 py-2 bg-blue-800 text-white rounded-lg border border-blue-700"
                   onClick={() => setIsNavOpen(v => !v)}
                 >
                   <Icon name="Menu" className="w-4 h-4" /> Menu
                 </button>

                 <nav className="hidden md:flex space-x-1 bg-blue-800 p-1 rounded-lg shrink-0 overflow-x-auto w-full md:w-auto max-w-full">
                    {navItems.map(tab => (
                       <button
                         key={tab.id}
                         onClick={() => setActiveTab(tab.id)}
                         className={`px-3 py-1.5 rounded text-sm font-semibold whitespace-nowrap transition-all ${
                           activeTab === tab.id ? 'bg-white text-blue-900 shadow-sm' : 'text-blue-200 hover:text-white'
                         }`}
                       >
                         {tab.label}
                       </button>
                   ))}
                 </nav>
              </div>

              {isNavOpen && (
                <div className="md:hidden w-full bg-blue-800 rounded-lg p-2 flex flex-col gap-1">
                  {navItems.map(tab => (
                    <button
                      key={`mobile-${tab.id}`}
                      onClick={() => {
                        setActiveTab(tab.id);
                        setIsNavOpen(false);
                      }}
                      className={`px-3 py-2 rounded text-sm font-semibold text-left transition-colors ${
                        activeTab === tab.id ? 'bg-white text-blue-900' : 'text-blue-100 hover:bg-blue-700'
                      }`}
                    >
                      {tab.label}
                    </button>
                  ))}
                </div>
              )}
            </header>

            <main className="max-w-[95%] mx-auto py-6">
              {activeTab === 'home' && (
                <HomeSection
                  activeTab={activeTab}
                  setActiveTab={setActiveTab}
                  baseUnitStats={baseUnitStats}
                  showAllDescendants={showAllDescendants}
                />
              )}

              {activeTab === 'unit' && (
                <UnitOverviewSection
                  baseUnitStats={baseUnitStats}
                  showAllDescendants={showAllDescendants}
                  processedData={processedData}
                  cadetData={cadetData}
                  orgChartData={orgChartData}
                  setActiveTab={setActiveTab}
                  unitFilter={unitFilter}
                  descendantOrgIds={getDescendantOrgIds(unitFilter)}
                  orgStatsService={orgStatsService}
                  esUnitAnalysisService={dataService?.getESUnitAnalysisService()}
                  googleAdoptionService={dataService?.getGoogleAdoptionService()}
                  dataFiles={dataFiles}
                  setRecruitingRetentionModal={setRecruitingRetentionModal}
                  setESReadinessModal={setESReadinessModal}
                />
              )}

              {activeTab === 'senior' && <SeniorDashboard {...{
                showSeniorFilters, setShowSeniorFilters, activeFiltersCount, filterPromoReady, levelFilter,
                searchQuery, clearFilters, activeFilterMenu, setActiveFilterMenu, filters, toggleFilter,
                trackSearchQuery, setTrackSearchQuery, dutySearchQuery, setDutySearchQuery,
                availableTracks, availableDuties, availableFunctionalAreas, availableRanks, processedData,
                setSelectedMemberProfile, setSelectedMember, setDetailLevel, setPromotionMember,
                getPromotionDetails, setReportsCollapsed, reportsCollapsed,
                unitStats, baseUnitStats, paginatedData, isMobile, currentPage, setCurrentPage,
                totalPages, handleLevelFilterClick, getEtSummary, displayData, DATA_CONSTANTS,
                LEVEL_DISPLAY_MAP, LEVELS, setFilterPromoReady, getTrainingIndicator,
                filterTlcQualified, setFilterTlcQualified
              }} />}

              {activeTab === 'cadet' && <CadetDashboard {...{
                phaseFilter, setPhaseFilter, cadetSearchQuery, setCadetSearchQuery,
                cadetData, setSelectedCadetProfile, selectedCadetProfile,
                setSelectedMemberProfile, processedCadets, searchQuery, filterStatus,
                setFilterStatus, filters, toggleFilter, setFilters, showCadetFilters,
                setShowCadetFilters, getRankInsigniaUrl, getAchievementDisplayName,
                filterPhase, setFilterPhase, filter90Days, setFilter90Days, isMobile,
                activeFilterMenu, setActiveFilterMenu, dutySearchQuery, setDutySearchQuery,
                setSelectedCadet, selectedCadet, CADET_ACHIEVEMENT_TO_RANK, dataFiles, cadetDataService,
                getCadetProtectionStatus, baseUnitStats
              }} />}

              {activeTab === 'reports' && <ReportsSection {...{
                reportTagFilter, setReportTagFilter, selectedReport, setSelectedReport,
                allReports: reportCatalog, processedData, cadetData,
                reportsCollapsed, setReportsCollapsed, availableReportTags, toggleReportTag,
                formatReportTagLabel, reportTagClasses, filteredReports,
                handleGenerateReport, handleRegenerateReport, handleExportReportPDF, handleExportCurrentReportPDF,
                setSelectedTaskMembers, selectedTaskMembers, getMemberEmail, LEVEL_DISPLAY_MAP,
                setSelectedMemberTaskDetails, selectedMemberTaskDetails, isMobile
              }} />}

              {activeTab === 'org' && <OrgChartSection {...{
                orgChartData, expandedSections, setExpandedSections, showCommandChainOnly,
                setShowCommandChainOnly, drillDownPosition, setDrillDownPosition,
                showAllDescendants, toggleExpandCollapse, getAllNodeIds,
                hideVacant, setHideVacant, hasCommittees, showCommittees,
                setShowCommittees, handleDownloadImage, dataFiles, unitFilter,
                getDescendantOrgIds, processedData, buildMemberProfileData,
                setSelectedMemberProfile
              }} />}

              <FloatingHelpAndModals {...{
                showReference, setShowReference, selectedMember, detailLevel,
                setSelectedMember, setDetailLevel, getLevelBreakdown, LEVEL_DISPLAY_MAP,
                promotionMember, setPromotionMember, getPromotionDetails,
                selectedMemberProfile, setSelectedMemberProfile, getMemberEmail,
                dataFiles, drillDownPosition, setDrillDownPosition, unitFilter,
                getDescendantOrgIds, processedData, buildMemberProfileData,
                DUTY_TO_TRACK_MAP, LEVELS, getCadetProtectionStatus, getTlcStatus,
                dataService, activeTab
              }} />
            </main>

            {/* SHARED MODALS - rendered at app level */}
            <SeniorProfileModal
              isOpen={!!selectedMemberProfile}
              onClose={() => setSelectedMemberProfile(null)}
              member={selectedMemberProfile}
              getMemberEmail={getMemberEmail}
              getCadetProtectionStatus={getCadetProtectionStatus}
              getTlcStatus={getTlcStatus}
              getPromotionDetails={getPromotionDetails}
              normalizeTrackDisplayName={normalizeTrackDisplayName}
              dataFiles={dataFiles}
              trainingCourseIndex={trainingCourseIndex}
              voluInstructorIndex={voluInstructorIndex}
              LEVELS={LEVELS}
              PME_COURSE_DEFS={PME_COURSE_DEFS}
              CAP_LEADERSHIP_COURSE_DEFS={CAP_LEADERSHIP_COURSE_DEFS}
              LEGACY_LEADERSHIP_COURSE_DEFS={LEGACY_LEADERSHIP_COURSE_DEFS}
              ES_FUNCTIONAL_AREAS={ES_FUNCTIONAL_AREAS}
              setSelectedMember={setSelectedMember}
              setDetailLevel={setDetailLevel}
              setSelectedESQualification={setSelectedESQualification}
              setShowESTreeModal={setShowESTreeModal}
            />

            <CadetProfileModal
              isOpen={!!selectedCadet}
              onClose={() => setSelectedCadet(null)}
              cadet={selectedCadet}
              getRankInsigniaUrl={getRankInsigniaUrl}
              getAchievementDisplayName={getAchievementDisplayName}
              getCadetProtectionStatus={getCadetProtectionStatus}
              dataFiles={dataFiles}
              configFiles={configFiles}
              cadetDataService={cadetDataService}
              esDataService={dataService}
              CADET_ACHIEVEMENT_TO_RANK={CADET_ACHIEVEMENT_TO_RANK}
              ES_FUNCTIONAL_AREAS={ES_FUNCTIONAL_AREAS}
            />

            <LevelDetailModal
              isOpen={!!selectedMember && !!detailLevel}
              onClose={() => { setSelectedMember(null); setDetailLevel(null); }}
              member={selectedMember}
              level={detailLevel}
              getLevelBreakdown={getLevelBreakdown}
              LEVEL_DISPLAY_MAP={LEVEL_DISPLAY_MAP}
            />

            <PromotionCriteriaModal
              isOpen={!!promotionMember}
              onClose={() => setPromotionMember(null)}
              member={promotionMember}
              getPromotionDetails={getPromotionDetails}
            />

            <DrillDownPositionModal
              isOpen={!!drillDownPosition}
              onClose={() => setDrillDownPosition(null)}
              position={drillDownPosition}
              getDescendantOrgIds={getDescendantOrgIds}
              buildMemberProfileData={buildMemberProfileData}
              unitFilter={unitFilter}
              dataFiles={dataFiles}
              processedData={processedData}
              setSelectedMemberProfile={setSelectedMemberProfile}
              setDrillDownPosition={setDrillDownPosition}
            />

            <ReferenceModal
              isOpen={showReference}
              onClose={() => setShowReference(false)}
              activeTab={activeTab}
              DUTY_TO_TRACK_MAP={DUTY_TO_TRACK_MAP}
              unitFilter={unitFilter}
              showAllDescendants={showAllDescendants}
              lastUpdated={lastUpdated}
              dataFiles={dataFiles}
              availableUnits={availableUnits}
            />

            {/* Recruiting & Retention Modal */}
            <RecruitingRetentionModal
              isOpen={recruitingRetentionModal.isOpen}
              onClose={() => setRecruitingRetentionModal({ isOpen: false })}
              metrics={recruitingRetentionModal.metrics}
              unitFilter={unitFilter}
              showAllDescendants={showAllDescendants}
              timeRange={recruitingRetentionModal.timeRange}
              orgStatsService={orgStatsService}
              descendantOrgIds={getDescendantOrgIds(unitFilter)}
              dataFiles={dataFiles}
            />

            {/* ES Readiness Modal */}
            <ESReadinessModal
              isOpen={esReadinessModal.isOpen}
              onClose={() => setESReadinessModal({ isOpen: false, analysis: null })}
              esAnalysis={esReadinessModal.analysis}
              dataFiles={dataFiles}
              unitFilter={unitFilter}
            />

            {/* ES Modals - These need state at this level */}
            {dataService && selectedESQualification && selectedMemberProfile && (
              <ESQualificationDetailModal
                isOpen={!!selectedESQualification}
                onClose={() => setSelectedESQualification(null)}
                qualification={selectedESQualification}
                member={selectedMemberProfile}
                dataService={dataService}
              />
            )}

            {dataService && selectedMemberProfile && (
              <ESQualificationTreeModal
                isOpen={showESTreeModal}
                onClose={() => setShowESTreeModal(false)}
                member={selectedMemberProfile}
                dataService={dataService}
                allQualifications={dataService.getAllESAchievements ? dataService.getAllESAchievements() : []}
              />
            )}
          </div>
        );
      }



      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(
        <ErrorBoundary>
          <App />
        </ErrorBoundary>
      );
    </script>
  </body>
</html>
