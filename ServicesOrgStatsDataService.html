<script type="text/babel">
/**
 * ServicesOrgStatsDataService.html
 *
 * Recruiting & Retention data processing service.
 * Provides aggregation and analysis of historical membership statistics
 * from ORGStatistics data.
 *
 * Member Type Categories:
 * - Senior Program: SENIOR, FIFTY YEAR, LIFE (full senior members)
 * - Cadet Program: CADET (youth members)
 * - Cadet Sponsors: CADET SPONSOR (adults supporting cadet program only)
 * - Patron: PATRON (financial supporters, rarely used)
 * - Other: AEM, etc.
 *
 * Dependencies:
 * - UtilsDataParsing.html (parseCSV)
 */

function createOrgStatsDataService() {
  let _rawData = [];
  let _orgIndex = new Map();

  // === MEMBER TYPE CLASSIFICATION ===
  // Maps raw MbrType values to program categories
  const MEMBER_TYPE_MAP = {
    'SENIOR': 'senior',
    'FIFTY YEAR': 'senior',  // 50+ year members are still seniors
    'LIFE': 'senior',         // Life members are still seniors
    'CADET': 'cadet',
    'CADET SPONSOR': 'cadetSponsor',
    'PATRON': 'patron',
    'AEM': 'other'
  };

  // Which categories to include in "combined" totals (main operational membership)
  const OPERATIONAL_CATEGORIES = ['senior', 'cadet'];

  // Metric explanations for UI help text
  const METRIC_EXPLANATIONS = {
    recruitingRate: {
      label: 'Recruiting Rate',
      shortDesc: 'New + returning members per month',
      fullDesc: 'Average number of new members and rejoining former members your unit gains each month. This shows how effective your recruiting efforts are.',
      howToImprove: 'Host open houses, attend community events, leverage social media, partner with schools and community organizations.',
      goodValue: '2+ per month for squadrons',
      formula: '(New Members + Rejoins) ÷ Number of Months'
    },
    retentionRate: {
      label: 'Retention Rate',
      shortDesc: 'Percentage of members who renew',
      fullDesc: 'Of members eligible for renewal, what percentage actually renewed their membership. High retention means members find value in CAP.',
      howToImprove: 'Engage members in meaningful activities, recognize achievements, maintain regular communication, address concerns promptly.',
      goodValue: '80%+ is healthy',
      formula: 'Renewals ÷ (Renewals + Estimated Attrition) × 100'
    },
    netChange: {
      label: 'Net Growth',
      shortDesc: '12-month membership change',
      fullDesc: 'The difference between your current membership and 12 months ago. Positive means growth, negative means decline.',
      howToImprove: 'Focus on both recruiting AND retention. Growing units recruit enough to offset natural attrition plus add new members.',
      goodValue: 'Positive growth year-over-year',
      formula: 'Current Total - Total 12 Months Ago'
    },
    stability: {
      label: 'Stability',
      shortDesc: 'Month-to-month consistency',
      fullDesc: 'How consistent your membership numbers are month-to-month. High stability means predictable membership levels.',
      howToImprove: 'Steady recruiting throughout the year, proactive retention outreach before expiration dates.',
      goodValue: 'Low variation (<10%)',
      formula: 'Based on coefficient of variation in monthly totals'
    },
    attritionRate: {
      label: 'Attrition Rate',
      shortDesc: 'Members lost per year',
      fullDesc: 'The estimated number of members your unit loses annually through non-renewal or transfer. Understanding attrition helps you plan recruiting to maintain or grow membership.',
      howToImprove: 'Focus on member engagement, address concerns early, ensure meaningful activities for all members.',
      goodValue: 'Lower than recruiting rate',
      formula: 'Estimated from: Recruited - Net Change'
    },
    newMembers: {
      label: 'New Members',
      shortDesc: 'First-time joins + returning members',
      fullDesc: 'Total count of brand new members who joined plus former members who rejoined during the time period.',
      howToImprove: 'Host open houses, partner with schools, leverage social media, attend community events.',
      goodValue: 'At least 2 per month for squadrons'
    },
    renewals: {
      label: 'Renewals',
      shortDesc: 'Members who renewed membership',
      fullDesc: 'Count of existing members who renewed their annual membership during the time period. High renewals indicate member satisfaction.',
      howToImprove: 'Send reminders before expiration, keep members engaged with meaningful activities.',
      goodValue: 'Higher than attrition'
    },
    dataPoints: {
      label: 'Data Points',
      shortDesc: 'Months of data analyzed',
      fullDesc: 'The number of monthly data points included in this analysis. More data points provide more reliable trends and seasonality patterns.',
      howToImprove: 'Select a longer time range to see more historical data.',
      goodValue: '24+ months for seasonality analysis'
    },
    sustainability: {
      label: 'Sustainability Score',
      shortDesc: 'Overall membership health',
      fullDesc: 'A composite score (0-100) combining recruiting, retention, growth, and stability. Higher scores indicate a healthier, more sustainable unit.',
      howToImprove: 'Address your lowest-scoring component first for the biggest impact.',
      goodValue: '65+ is good, 80+ is excellent',
      formula: '25% Recruiting + 35% Retention + 25% Growth + 15% Stability'
    }
  };

  // === INITIALIZATION ===
  const initialize = (orgStatsRaw) => {
    if (!orgStatsRaw) {
      console.warn('OrgStatsDataService: No org stats data provided');
      return;
    }
    _rawData = parseCSV(orgStatsRaw) || [];
    buildIndexes();
  };

  const buildIndexes = () => {
    _orgIndex.clear();

    _rawData.forEach(row => {
      const orgId = row.ORGID;
      if (!_orgIndex.has(orgId)) _orgIndex.set(orgId, []);
      _orgIndex.get(orgId).push(row);
    });
  };

  /**
   * Classify a raw member type to a category
   */
  const classifyMemberType = (rawType) => {
    const normalized = (rawType || '').trim().toUpperCase();
    return MEMBER_TYPE_MAP[normalized] || 'other';
  };

  // === DATE UTILITIES ===
  const parseDate = (dateStr) => {
    if (!dateStr) return null;
    // Format: MM/DD/YYYY
    const parts = dateStr.split('/');
    if (parts.length !== 3) return null;
    const [month, day, year] = parts;
    return new Date(parseInt(year), parseInt(month) - 1, parseInt(day));
  };

  const getMonthsAgo = (months) => {
    const date = new Date();
    date.setMonth(date.getMonth() - months);
    return date;
  };

  const formatMonthLabel = (dateStr) => {
    const date = parseDate(dateStr);
    if (!date) return dateStr;
    return date.toLocaleDateString('en-US', { month: 'short', year: '2-digit' });
  };

  // === FILTERING ===
  const getDataForOrg = (orgId, includeDescendants = false, descendantOrgIds = []) => {
    const validOrgIds = includeDescendants
      ? new Set([String(orgId), ...descendantOrgIds.map(id => String(id))])
      : new Set([String(orgId)]);

    return _rawData.filter(row => validOrgIds.has(String(row.ORGID)));
  };

  const getDataInTimeRange = (data, startDate, endDate = new Date()) => {
    return data.filter(row => {
      const rowDate = parseDate(row.CntDate);
      if (!rowDate) return false;
      return rowDate >= startDate && rowDate <= endDate;
    });
  };

  // === AGGREGATION ===
  /**
   * Aggregate data by month with proper member type categorization
   *
   * Categories tracked:
   * - senior: SENIOR + FIFTY YEAR + LIFE (operational senior members)
   * - cadet: CADET (youth members)
   * - cadetSponsor: CADET SPONSOR (adult sponsors, tracked separately)
   * - combined: senior + cadet (main operational membership)
   * - all: everything including sponsors, patron
   */
  const aggregateByMonth = (data, filterCategories = null) => {
    const monthlyData = new Map();

    // Create empty bucket structure
    const createBucket = () => ({
      total: 0, new: 0, renew: 0, rejoin: 0
    });

    data.forEach(row => {
      const rawMbrType = (row.MbrType || '').trim().toUpperCase();
      const category = classifyMemberType(rawMbrType);

      // Skip if we're filtering and this category isn't included
      if (filterCategories && !filterCategories.includes(category)) return;

      const dateKey = row.CntDate;
      const cntType = (row.CntType || '').trim().toUpperCase();
      const quantity = parseInt(row.Quantity) || 0;

      if (!monthlyData.has(dateKey)) {
        monthlyData.set(dateKey, {
          date: dateKey,
          dateObj: parseDate(dateKey),
          label: formatMonthLabel(dateKey),
          senior: createBucket(),      // SENIOR + FIFTY YEAR + LIFE
          cadet: createBucket(),       // CADET only
          cadetSponsor: createBucket(),// CADET SPONSOR
          patron: createBucket(),      // PATRON
          combined: createBucket(),    // senior + cadet (operational)
          all: createBucket()          // everything
        });
      }

      const monthEntry = monthlyData.get(dateKey);

      // Add to the specific category bucket
      const targetBucket = monthEntry[category];
      if (targetBucket) {
        if (cntType === 'TOTAL') {
          targetBucket.total += quantity;
        } else if (cntType.includes('RENEW')) {
          // Check RENEW before NEW since 'RENEW' contains 'NEW'
          targetBucket.renew += quantity;
        } else if (cntType.includes('REJOIN')) {
          targetBucket.rejoin += quantity;
        } else if (cntType.includes('NEW')) {
          targetBucket.new += quantity;
        }
      }
    });

    // Calculate combined and all totals
    monthlyData.forEach(entry => {
      // Combined = senior + cadet (operational membership only)
      entry.combined.total = entry.senior.total + entry.cadet.total;
      entry.combined.new = entry.senior.new + entry.cadet.new;
      entry.combined.renew = entry.senior.renew + entry.cadet.renew;
      entry.combined.rejoin = entry.senior.rejoin + entry.cadet.rejoin;

      // All = everything
      entry.all.total = entry.senior.total + entry.cadet.total +
                        entry.cadetSponsor.total + entry.patron.total;
      entry.all.new = entry.senior.new + entry.cadet.new +
                      entry.cadetSponsor.new + entry.patron.new;
      entry.all.renew = entry.senior.renew + entry.cadet.renew +
                        entry.cadetSponsor.renew + entry.patron.renew;
      entry.all.rejoin = entry.senior.rejoin + entry.cadet.rejoin +
                         entry.cadetSponsor.rejoin + entry.patron.rejoin;
    });

    // Sort by date ascending
    return Array.from(monthlyData.values())
      .filter(entry => entry.dateObj) // Filter out entries with invalid dates
      .sort((a, b) => a.dateObj - b.dateObj);
  };

  // === METRIC CALCULATIONS ===

  /**
   * Calculate recruiting throughput (new + rejoin rate)
   * Measures how effectively the unit brings in new members
   * @param {Array} monthlyData - Full monthly data array
   * @param {string} mbrType - Member type filter
   * @param {number} timeRangeMonths - Number of months to analyze (0 = all)
   */
  const calculateRecruitingThroughput = (monthlyData, mbrType = 'combined', timeRangeMonths = 12) => {
    if (!monthlyData || monthlyData.length === 0) return null;

    // Use specified time range, or all data if timeRangeMonths is 0
    const numMonths = timeRangeMonths === 0 ? monthlyData.length : Math.min(timeRangeMonths, monthlyData.length);
    const recentMonths = monthlyData.slice(-numMonths);

    const totalRecruited = recentMonths.reduce((sum, m) =>
      sum + (m[mbrType]?.new || 0) + (m[mbrType]?.rejoin || 0), 0);
    const avgMonthlyRecruiting = totalRecruited / recentMonths.length;

    // Compare to prior period of same length if available
    let trend = 'stable';
    let trendPercent = 0;

    if (monthlyData.length >= numMonths * 2) {
      const priorMonths = monthlyData.slice(-numMonths * 2, -numMonths);
      const priorRecruited = priorMonths.reduce((sum, m) =>
        sum + (m[mbrType]?.new || 0) + (m[mbrType]?.rejoin || 0), 0);
      const priorAvg = priorRecruited / priorMonths.length;

      if (priorAvg > 0) {
        trendPercent = ((avgMonthlyRecruiting - priorAvg) / priorAvg) * 100;
        trend = trendPercent > 5 ? 'increasing' :
                trendPercent < -5 ? 'decreasing' : 'stable';
      }
    }

    return {
      totalInPeriod: totalRecruited,
      monthlyAverage: Math.round(avgMonthlyRecruiting * 10) / 10,
      trend,
      trendPercent: Math.round(trendPercent * 10) / 10,
      explanation: METRIC_EXPLANATIONS.recruitingRate
    };
  };

  /**
   * Calculate retention rate
   *
   * Method: Compare renewals against the pool of members who could have renewed.
   * We estimate the renewal-eligible pool as: previous period total - new members in current period
   *
   * A simpler, more meaningful approach:
   * - Look at how many members renewed vs how many were lost
   * - If renewals >> losses, retention is high
   * - If losses >> renewals, retention is low
   *
   * @param {Array} monthlyData - Full monthly data array
   * @param {string} mbrType - Member type filter
   * @param {number} timeRangeMonths - Number of months to analyze (0 = all)
   */
  const calculateRetentionLoad = (monthlyData, mbrType = 'combined', timeRangeMonths = 12) => {
    if (!monthlyData || monthlyData.length < 2) return null;

    // Use specified time range, or all data if timeRangeMonths is 0
    const numMonths = timeRangeMonths === 0 ? monthlyData.length : Math.min(timeRangeMonths, monthlyData.length);
    const recentMonths = monthlyData.slice(-numMonths);
    if (recentMonths.length < 2) return null;

    // Total renewals over the period
    const totalRenewals = recentMonths.reduce((sum, m) =>
      sum + (m[mbrType]?.renew || 0), 0);

    // Total new recruits (new + rejoin)
    const totalRecruited = recentMonths.reduce((sum, m) =>
      sum + (m[mbrType]?.new || 0) + (m[mbrType]?.rejoin || 0), 0);

    // Net change over the period
    const startTotal = recentMonths[0][mbrType]?.total || 0;
    const endTotal = recentMonths[recentMonths.length - 1][mbrType]?.total || 0;
    const netChange = endTotal - startTotal;

    // Estimated attrition = recruited - net change
    // (If you recruited 10 but only grew by 2, you lost 8)
    const estimatedAttrition = Math.max(0, totalRecruited - netChange);

    // Retention rate: what percentage of the "renewal eligible" stayed?
    // Renewal eligible ≈ previous total (those who could have left but didn't)
    // Simpler: Renewals / (Renewals + Attrition)
    let retentionRate = null;
    if (totalRenewals + estimatedAttrition > 0) {
      retentionRate = (totalRenewals / (totalRenewals + estimatedAttrition)) * 100;
    } else if (startTotal > 0 && endTotal >= startTotal) {
      // No attrition detected, and membership stable or growing = good retention
      retentionRate = 95;
    } else if (totalRenewals > 0) {
      // Have renewals but can't calculate attrition = assume decent retention
      retentionRate = 75;
    }

    // Sanity check: cap at 100%
    if (retentionRate !== null) {
      retentionRate = Math.min(100, Math.max(0, retentionRate));
    }

    const healthIndicator = retentionRate === null ? 'unknown' :
                           retentionRate >= 80 ? 'healthy' :
                           retentionRate >= 60 ? 'moderate' : 'at-risk';

    // Calculate annualized attrition rate as a percentage
    const monthsOfData = recentMonths.length;
    const annualizedAttrition = startTotal > 0
      ? (estimatedAttrition / startTotal) * 100 * (12 / monthsOfData)
      : null;

    return {
      renewalsInPeriod: totalRenewals,
      estimatedAttrition: Math.round(estimatedAttrition),
      annualizedAttritionRate: annualizedAttrition !== null ? Math.round(annualizedAttrition * 10) / 10 : null,
      retentionRate: retentionRate !== null ? Math.round(retentionRate * 10) / 10 : null,
      healthIndicator,
      explanation: METRIC_EXPLANATIONS.retentionRate,
      attritionExplanation: METRIC_EXPLANATIONS.attritionRate
    };
  };

  /**
   * Calculate growth vs replacement ratio
   * Shows if recruiting is growing the unit or just replacing losses
   * @param {Array} monthlyData - Full monthly data array
   * @param {string} mbrType - Member type filter
   * @param {number} timeRangeMonths - Number of months to analyze (0 = all)
   */
  const calculateGrowthAnalysis = (monthlyData, mbrType = 'combined', timeRangeMonths = 12) => {
    if (!monthlyData || monthlyData.length < 2) return null;

    // Use specified time range, or all data if timeRangeMonths is 0
    const numMonths = timeRangeMonths === 0 ? monthlyData.length : Math.min(timeRangeMonths, monthlyData.length);
    const recentMonths = monthlyData.slice(-numMonths);
    if (recentMonths.length < 2) return null;

    const firstMonth = recentMonths[0][mbrType]?.total || 0;
    const lastMonth = recentMonths[recentMonths.length - 1][mbrType]?.total || 0;

    const netChange = lastMonth - firstMonth;
    const totalRecruited = recentMonths.reduce((sum, m) =>
      sum + (m[mbrType]?.new || 0) + (m[mbrType]?.rejoin || 0), 0);

    const replacementNeeded = totalRecruited - netChange;
    const growthContribution = netChange > 0 ? netChange : 0;

    const growthRatio = totalRecruited > 0
      ? (growthContribution / totalRecruited) * 100
      : 0;

    return {
      netChangeInPeriod: netChange,
      totalRecruited: totalRecruited,
      replacementNeeded: Math.max(0, replacementNeeded),
      growthContribution: growthContribution,
      growthRatio: Math.round(growthRatio),
      status: netChange > 0 ? 'growing' :
              netChange === 0 ? 'stable' : 'declining',
      explanation: METRIC_EXPLANATIONS.netChange
    };
  };

  /**
   * Calculate seasonality patterns
   * Identifies which months have highest/lowest recruiting
   */
  const calculateSeasonality = (monthlyData, mbrType = 'combined') => {
    if (!monthlyData || monthlyData.length < 24) return null;

    const monthlyAverages = Array(12).fill(null).map(() => ({
      count: 0,
      totalNew: 0,
      totalRejoin: 0,
      totalRenew: 0
    }));

    monthlyData.forEach(m => {
      if (!m.dateObj) return;
      const monthIndex = m.dateObj.getMonth();
      const bucket = monthlyAverages[monthIndex];
      bucket.count++;
      bucket.totalNew += m[mbrType]?.new || 0;
      bucket.totalRejoin += m[mbrType]?.rejoin || 0;
      bucket.totalRenew += m[mbrType]?.renew || 0;
    });

    const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                        'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

    const patterns = monthlyAverages.map((bucket, idx) => ({
      month: monthNames[idx],
      monthIndex: idx,
      avgRecruiting: bucket.count > 0
        ? (bucket.totalNew + bucket.totalRejoin) / bucket.count
        : 0,
      avgRenewals: bucket.count > 0 ? bucket.totalRenew / bucket.count : 0
    }));

    const sorted = [...patterns].sort((a, b) => b.avgRecruiting - a.avgRecruiting);

    return {
      patterns,
      peakMonths: sorted.slice(0, 3).map(p => p.month),
      lowMonths: sorted.slice(-3).reverse().map(p => p.month)
    };
  };

  /**
   * Calculate volatility indicators
   * Measures month-to-month membership stability
   * @param {Array} monthlyData - Full monthly data array
   * @param {string} mbrType - Member type filter
   * @param {number} timeRangeMonths - Number of months to analyze (0 = all)
   */
  const calculateVolatility = (monthlyData, mbrType = 'combined', timeRangeMonths = 12) => {
    if (!monthlyData || monthlyData.length < 6) return null;

    // Use specified time range, or all data if timeRangeMonths is 0
    const numMonths = timeRangeMonths === 0 ? monthlyData.length : Math.min(timeRangeMonths, monthlyData.length);
    const recentMonths = monthlyData.slice(-numMonths);
    const totals = recentMonths.map(m => m[mbrType]?.total || 0).filter(t => t > 0);

    if (totals.length < 3) return null;

    const mean = totals.reduce((sum, t) => sum + t, 0) / totals.length;
    const variance = totals.reduce((sum, t) => sum + Math.pow(t - mean, 2), 0) / totals.length;
    const stdDev = Math.sqrt(variance);
    const coeffOfVariation = mean > 0 ? (stdDev / mean) * 100 : 0;

    // Calculate max swing
    let maxSwing = 0;
    for (let i = 1; i < totals.length; i++) {
      const swing = Math.abs(totals[i] - totals[i-1]);
      if (swing > maxSwing) maxSwing = swing;
    }

    return {
      standardDeviation: Math.round(stdDev * 10) / 10,
      coefficientOfVariation: Math.round(coeffOfVariation * 10) / 10,
      maxMonthlySwing: maxSwing,
      stabilityRating: coeffOfVariation < 5 ? 'very-stable' :
                       coeffOfVariation < 10 ? 'stable' :
                       coeffOfVariation < 20 ? 'moderate' : 'volatile',
      explanation: METRIC_EXPLANATIONS.stability
    };
  };

  /**
   * Calculate long-term sustainability score
   * Composite metric for overall membership health
   * @param {Array} monthlyData - Full monthly data array
   * @param {string} mbrType - Member type filter
   * @param {number} timeRangeMonths - Number of months to analyze (0 = all)
   */
  const calculateSustainability = (monthlyData, mbrType = 'combined', timeRangeMonths = 12) => {
    const recruiting = calculateRecruitingThroughput(monthlyData, mbrType, timeRangeMonths);
    const retention = calculateRetentionLoad(monthlyData, mbrType, timeRangeMonths);
    const growth = calculateGrowthAnalysis(monthlyData, mbrType, timeRangeMonths);
    const volatility = calculateVolatility(monthlyData, mbrType, timeRangeMonths);

    if (!recruiting && !retention && !growth && !volatility) return null;

    // Score components (0-100 each)
    const recruitingScore = recruiting
      ? Math.min(100, (recruiting.monthlyAverage || 0) * 20)
      : 50;
    const retentionScore = retention?.retentionRate || 50;
    const growthScore = growth
      ? (growth.status === 'growing' ? 80 + Math.min(20, (growth.netChangeInPeriod || 0) * 2) :
         growth.status === 'stable' ? 60 :
         Math.max(0, 50 + (growth.netChangeInPeriod || 0) * 5))
      : 50;
    const stabilityScore = volatility
      ? (volatility.stabilityRating === 'very-stable' ? 100 :
         volatility.stabilityRating === 'stable' ? 80 :
         volatility.stabilityRating === 'moderate' ? 60 : 40)
      : 70;

    const overallScore = (recruitingScore * 0.25 +
                          retentionScore * 0.35 +
                          growthScore * 0.25 +
                          stabilityScore * 0.15);

    // Find lowest component to suggest focus area
    const componentScores = [
      { name: 'recruiting', score: recruitingScore, label: 'Recruiting' },
      { name: 'retention', score: retentionScore, label: 'Retention' },
      { name: 'growth', score: growthScore, label: 'Growth' },
      { name: 'stability', score: stabilityScore, label: 'Stability' }
    ];
    const lowestComponent = [...componentScores].sort((a, b) => a.score - b.score)[0];

    return {
      overallScore: Math.round(overallScore),
      components: {
        recruiting: Math.round(recruitingScore),
        retention: Math.round(retentionScore),
        growth: Math.round(growthScore),
        stability: Math.round(stabilityScore)
      },
      rating: overallScore >= 80 ? 'excellent' :
              overallScore >= 65 ? 'good' :
              overallScore >= 50 ? 'fair' : 'needs-attention',
      summary: overallScore >= 80 ? 'Unit membership is healthy and sustainable' :
               overallScore >= 65 ? 'Unit membership is stable with room for improvement' :
               overallScore >= 50 ? 'Unit should focus on retention and recruiting' :
               'Unit membership needs immediate attention',
      focusArea: lowestComponent,
      explanation: METRIC_EXPLANATIONS.sustainability
    };
  };

  // === MAIN API ===

  /**
   * Get comprehensive recruiting/retention metrics for a unit
   */
  const getMetricsForUnit = (orgId, options = {}) => {
    const {
      includeDescendants = false,
      descendantOrgIds = [],
      timeRangeMonths = 12,
      mbrType = 'combined'
    } = options;

    if (!orgId) return null;

    const unitData = getDataForOrg(orgId, includeDescendants, descendantOrgIds);
    if (unitData.length === 0) {
      return null;
    }

    // For "all time" (0), use all available data
    // Otherwise, get extra months for trend analysis (at least 24 months or 2x requested)
    const isAllTime = timeRangeMonths === 0;
    const analysisMonths = isAllTime ? 999 : Math.max(timeRangeMonths * 2, 24);
    const startDate = isAllTime ? new Date(2000, 0, 1) : getMonthsAgo(analysisMonths);
    const filteredData = getDataInTimeRange(unitData, startDate);
    const monthlyData = aggregateByMonth(filteredData);

    // Limit to requested time range for display (all-time shows everything)
    const displayData = isAllTime
      ? monthlyData
      : monthlyData.slice(-timeRangeMonths);

    const currentTotal = displayData.length > 0
      ? displayData[displayData.length - 1][mbrType]?.total || 0
      : 0;

    const yearAgoTotal = monthlyData.length >= 12
      ? monthlyData[monthlyData.length - 12]?.[mbrType]?.total || null
      : null;

    // Get latest month's breakdown by member type
    const latestMonth = displayData.length > 0 ? displayData[displayData.length - 1] : null;
    const memberBreakdown = latestMonth ? {
      senior: latestMonth.senior?.total || 0,
      cadet: latestMonth.cadet?.total || 0,
      cadetSponsor: latestMonth.cadetSponsor?.total || 0,
      patron: latestMonth.patron?.total || 0,
      combined: latestMonth.combined?.total || 0,
      all: latestMonth.all?.total || 0
    } : null;

    // Pass timeRangeMonths to all calculation functions so metrics reflect the selected period
    return {
      monthlyData: displayData,
      metrics: {
        recruiting: calculateRecruitingThroughput(monthlyData, mbrType, timeRangeMonths),
        retention: calculateRetentionLoad(monthlyData, mbrType, timeRangeMonths),
        growth: calculateGrowthAnalysis(monthlyData, mbrType, timeRangeMonths),
        seasonality: calculateSeasonality(monthlyData, mbrType),  // Seasonality uses all available data for pattern detection
        volatility: calculateVolatility(monthlyData, mbrType, timeRangeMonths),
        sustainability: calculateSustainability(monthlyData, mbrType, timeRangeMonths)
      },
      summary: {
        currentTotal,
        yearAgoTotal,
        dataPointCount: displayData.length,
        memberBreakdown
      }
    };
  };

  /**
   * Get key data for collapsed section view
   */
  const getKeyDataForUnit = (orgId, options = {}) => {
    const fullMetrics = getMetricsForUnit(orgId, options);

    if (!fullMetrics) {
      return {
        currentTotal: 0,
        yearOverYearChange: null,
        sustainabilityScore: null,
        sustainabilityRating: 'unknown',
        trendDirection: 'unknown',
        retentionRate: null
      };
    }

    return {
      currentTotal: fullMetrics.summary.currentTotal,
      yearOverYearChange: fullMetrics.summary.yearAgoTotal
        ? fullMetrics.summary.currentTotal - fullMetrics.summary.yearAgoTotal
        : null,
      sustainabilityScore: fullMetrics.metrics.sustainability?.overallScore || null,
      sustainabilityRating: fullMetrics.metrics.sustainability?.rating || 'unknown',
      trendDirection: fullMetrics.metrics.recruiting?.trend || 'unknown',
      retentionRate: fullMetrics.metrics.retention?.retentionRate || null
    };
  };

  /**
   * Check if data is available for a unit
   */
  const hasDataForUnit = (orgId, includeDescendants = false, descendantOrgIds = []) => {
    const validOrgIds = includeDescendants
      ? new Set([String(orgId), ...descendantOrgIds.map(id => String(id))])
      : new Set([String(orgId)]);

    return _rawData.some(row => validOrgIds.has(String(row.ORGID)));
  };

  /**
   * Get metrics for multiple units at once (for unit comparison table)
   * Returns an array of unit metrics sorted by sustainability score
   */
  const getMetricsForMultipleUnits = (orgIds, options = {}) => {
    const {
      timeRangeMonths = 12,
      mbrType = 'combined'
    } = options;

    if (!orgIds || orgIds.length === 0) return [];

    const results = orgIds.map(orgId => {
      const metrics = getMetricsForUnit(orgId, {
        includeDescendants: false,
        descendantOrgIds: [],
        timeRangeMonths,
        mbrType
      });

      return {
        orgId: String(orgId),
        hasData: metrics !== null,
        currentTotal: metrics?.summary?.currentTotal || 0,
        yearOverYearChange: metrics?.summary?.yearAgoTotal
          ? metrics.summary.currentTotal - metrics.summary.yearAgoTotal
          : null,
        sustainabilityScore: metrics?.metrics?.sustainability?.overallScore || null,
        sustainabilityRating: metrics?.metrics?.sustainability?.rating || 'unknown',
        retentionRate: metrics?.metrics?.retention?.retentionRate || null,
        recruitingRate: metrics?.metrics?.recruiting?.monthlyAverage || null,
        growthStatus: metrics?.metrics?.growth?.status || 'unknown',
        netChange: metrics?.metrics?.growth?.netChangeInPeriod || null,
        memberBreakdown: metrics?.summary?.memberBreakdown || null
      };
    }).filter(r => r.hasData);

    // Sort by sustainability score (highest first)
    return results.sort((a, b) => (b.sustainabilityScore || 0) - (a.sustainabilityScore || 0));
  };

  /**
   * Get explanation text for a specific metric
   */
  const getMetricExplanation = (metricKey) => {
    return METRIC_EXPLANATIONS[metricKey] || null;
  };

  /**
   * Get all metric explanations
   */
  const getMetricExplanations = () => METRIC_EXPLANATIONS;

  /**
   * Get member type categories for UI display
   */
  const getMemberTypeCategories = () => ({
    senior: {
      label: 'Senior Members',
      description: 'Includes SENIOR, FIFTY YEAR, and LIFE members',
      includes: ['SENIOR', 'FIFTY YEAR', 'LIFE']
    },
    cadet: {
      label: 'Cadets',
      description: 'Youth members aged 12-18',
      includes: ['CADET']
    },
    cadetSponsor: {
      label: 'Cadet Sponsors',
      description: 'Adults who support the cadet program only',
      includes: ['CADET SPONSOR']
    },
    patron: {
      label: 'Patrons',
      description: 'Financial supporters (rarely used)',
      includes: ['PATRON']
    },
    combined: {
      label: 'Operational Membership',
      description: 'Senior + Cadet members (primary mission workforce)',
      includes: ['SENIOR', 'FIFTY YEAR', 'LIFE', 'CADET']
    }
  });

  return {
    initialize,
    getMetricsForUnit,
    getMetricsForMultipleUnits,
    getKeyDataForUnit,
    hasDataForUnit,
    // Expose explanations for UI
    getMetricExplanation,
    getMetricExplanations,
    getMemberTypeCategories,
    // Expose for charts
    aggregateByMonth,
    getDataForOrg,
    getDataInTimeRange,
    // Expose individual calculations if needed
    calculateRecruitingThroughput,
    calculateRetentionLoad,
    calculateGrowthAnalysis,
    calculateSeasonality,
    calculateVolatility,
    calculateSustainability
  };
}
</script>
